#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/outputs.h>

#include "bepo_bindings.h"

// SETTINGS
#define _MACRO_INTERVAL   3  // max 5
#define _MACRO_TAP_FOR    3  // max 5

#define _COMBO_TIMEOUT    17 // min 16

#define _TAP_TERM_SLOTH   700
#define _TAP_TERM_SLOW    300
#define _TAP_TERM         300 //default 250
#define _TAP_TERM_QUICK   200
#define _TAP_TERM_BLAZIN  120

#define _QUICK_TAP        200

#define _STICKY_TIMEOUT   2000 // min 1000

// LAYERS
#define BASE 0 
#define CPWD 1 
#define NUM  2 
#define UTIL 3 
#define SYM  4 
#define ACNT 5 
#define ACCP 6 
#define NAV  7
#define FUNC 8 
#define GAME 9 
#define GAM2 10

// combos shouldn't work on game layer, to minimize delay
#define ALL_LAYERS   BASE CPWD UTIL SYM ACNT ACCP NUM NAV FUNC GAME GAM2
#define NOT_GAME     BASE CPWD UTIL SYM ACNT ACCP NUM NAV FUNC
#define NOT_CPWD     BASE      UTIL SYM ACNT ACCP NUM NAV FUNC

&lt { // tap for kp, hold for layer
	tapping-term-ms = <_TAP_TERM>;
	flavor = "balanced";
};

&mt { // hold-tap
	tapping-term-ms = <_TAP_TERM_BLAZIN>;
};

&sk { // one-shot layer
	release-after-ms = <_STICKY_TIMEOUT>;
	quick-release;
};

/ {
	behaviors {
		#define DEFINE_HOLDTAP(NAME, FLAVOR, DELAY, BINDINGS...) \
			NAME: ht_##NAME { \
				label = #NAME; \
				flavor = #FLAVOR; \
				tapping-term-ms = <DELAY>; \
				bindings = BINDINGS; \
				#binding-cells = <2>; \
				compatible = "zmk,behavior-hold-tap"; \
				quick-tap-ms = <_QUICK_TAP>;

		#define HOLDTAP(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM, BINDINGS) \
			};

		#define HOLDTAP_QUICK(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM_QUICK, BINDINGS) \
			};

		#define HOLDTAP_BAL(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, balanced, _TAP_TERM, BINDINGS) \
			};

		#define HRMOD_POS(NAME, POSITIONS) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM, <&kp>, <&kp>) \
					hold-trigger-key-positions = <POSITIONS>; \
			};

		#define HOLDTAP_SLOW(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM_SLOW, BINDINGS) \
			};
			
		#define SECURITY_HOLD(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM_SLOTH, BINDINGS) \
			};

		// HOLDTAP(ht_qu,   <&kp>, <&m_Q_U_>)    // qu              &kp
		// HOLDTAP(ht_aact, <&kp>, <&m_ACUT_A_>) // á               &kp
		// HOLDTAP(ht_uact, <&kp>, <&m_ACUT_U_>) // ú               &kp
		// HOLDTAP(ht_iact, <&kp>, <&m_ACUT_I_>) // í               &kp

		// home-row mods                    // PRESS           HOLD
		HOLDTAP(     ht,     <&kp>, <&kp>) // &kp             &kp
		HOLDTAP_SLOW(htslow, <&kp>, <&kp>)
		HOLDTAP(     htsk,   <&sk>, <&kp>) // &kp             sticky layer
		HOLDTAP_BAL( lsk,    <&mo>, <&sk>) // one-shot mod    hold layer
		HOLDTAP_BAL( lsl,    <&mo>, <&sl>) // one-shot layer  hold layer
		HOLDTAP_BAL( htcpwd, <&mo>, <&m_spc_cpwd>) // space then desactivate capsword    hold layer

		// gotta hold these for a long time just to make sure
		SECURITY_HOLD(sechold_cutall,   <&m_cut_all>,   <&kp>)
		SECURITY_HOLD(sechold_copyall,  <&m_copy_all>,  <&kp>)
		SECURITY_HOLD(sechold_pasteall, <&m_paste_all>, <&kp>)

		// hrm for opposite hand only (used for shift)
		HRMOD_POS(htl, 5 6 7 8 9 15 16 17 18 19 25 26 27 28 29 32 33)
		HRMOD_POS(htr, 0 1 2 3 4 10 11 12 13 14 20 21 22 23 24 30 31)

		// automatic nbsp on tap
		HOLDTAP(ht_lglm, <&kp>, <&m_nbsp_lglm>)
		HOLDTAP(ht_rglm, <&kp>, <&m_nbsp_rglm>)

		// automatic nbsp on hold
		HOLDTAP_QUICK(ht_coln, <&m_nbsp_coln>, <&kp>)
		HOLDTAP_QUICK(ht_scln, <&m_nbsp_scln>, <&kp>)
		HOLDTAP_QUICK(ht_qmrk, <&m_nbsp_qmrk>, <&kp>)
		HOLDTAP_QUICK(ht_excl, <&m_nbsp_excl>, <&kp>)
	};

	macros {
		#define RELEASE_SHIFT <&macro_release &kp LSHFT &kp RSHFT>

		#define MACRO(NAME, BINDINGS...) \
			ZMK_MACRO(m_##NAME, \
				tap-ms   = <_MACRO_TAP_FOR>; \
				wait-ms  = <_MACRO_INTERVAL>; \
				bindings = BINDINGS; \
				)

		// names the macro "m_FIRST##SECOND", eg "m_Q_U_"
		#define MACRO_SIMPLE(FIRST, SECOND) \
			MACRO(FIRST##SECOND, <&macro_tap &kp FIRST>, RELEASE_SHIFT, <&macro_tap &kp SECOND>)
			
		#define MACRO_TAP(NAME, BINDINGS...) \
			MACRO(NAME, <&macro_tap BINDINGS>)
		
		// MACRO(FIRST##SECOND, <&macro_tap &kp FIRST &kp SECOND>)


		#define MACRO_SIMPLE_SHIFT(FIRST, SECOND) \
			MACRO(cp_##FIRST##SECOND, <&macro_tap &kp FIRST &kp SECOND>)

		#define MACRO_ACCENT(FIRST, SECOND) \
			MACRO_SIMPLE( FIRST, SECOND ) \
			MACRO_SIMPLE_SHIFT(FIRST, SECOND)
		// #define MACRO_ACCENT(FIRST, SECOND) \
			// MACRO(FIRST##SECOND, <&macro_tap &kp FIRST &kp SECOND>)


		// accented letters
		MACRO_ACCENT(ACUT_, A_)
		MACRO_ACCENT(ACUT_, I_)
		MACRO_ACCENT(ACUT_, O_)
		MACRO_ACCENT(ACUT_, U_)

		MACRO_ACCENT(CFLX_, A_)
		MACRO_ACCENT(CFLX_, E_)
		MACRO_ACCENT(CFLX_, I_)
		MACRO_ACCENT(CFLX_, O_)
		MACRO_ACCENT(CFLX_, U_)

		MACRO_ACCENT(GRAV_, E_)
		MACRO_ACCENT(GRAV_, O_)
		MACRO_ACCENT(GRAV_, U_)

		MACRO_ACCENT(TILD_, A_)
		MACRO_ACCENT(TILD_, O_)
		MACRO_ACCENT(TILD_, N_)

		MACRO_ACCENT(TRMA_, I_)

		// MACRO_SIMPLE(ACUT_, A_)
		// MACRO_SIMPLE(ACUT_, I_)
		// MACRO_SIMPLE(ACUT_, O_)
		// MACRO_SIMPLE(ACUT_, U_)

		// MACRO_SIMPLE(CFLX_, A_)
		// MACRO_SIMPLE(CFLX_, E_)
		// MACRO_SIMPLE(CFLX_, I_)
		// MACRO_SIMPLE(CFLX_, O_)
		// MACRO_SIMPLE(CFLX_, U_)

		// MACRO_SIMPLE(GRAV_, O_)
		// MACRO_SIMPLE(GRAV_, U_)

		// MACRO_SIMPLE(TILD_, A_)
		// MACRO_SIMPLE(TILD_, O_)
		// MACRO_SIMPLE(TILD_, N_)

		// MACRO_SIMPLE(TRMA_, I_)

		// caps accented letters
		// MACRO_TAP(cp_ACUT_A_,  &kp ACUT_  &kp LS(A_))
		// MACRO_TAP(cp_ACUT_I_,  &kp ACUT_  &kp LS(I_))
		// MACRO_TAP(cp_ACUT_O_,  &kp ACUT_  &kp LS(O_))
		// MACRO_TAP(cp_ACUT_U_,  &kp ACUT_  &kp LS(U_))
						  
		// MACRO_TAP(cp_CFLX_A_,  &kp CFLX_  &kp LS(A_))
		// MACRO_TAP(cp_CFLX_E_,  &kp CFLX_  &kp LS(E_))
		// MACRO_TAP(cp_CFLX_I_,  &kp CFLX_  &kp LS(I_))
		// MACRO_TAP(cp_CFLX_O_,  &kp CFLX_  &kp LS(O_))
		// MACRO_TAP(cp_CFLX_U_,  &kp CFLX_  &kp LS(U_))
							  
		// MACRO_TAP(cp_GRAV_E_,  &kp GRAV_  &kp LS(E_))
		// MACRO_TAP(cp_GRAV_O_,  &kp GRAV_  &kp LS(O_))
		// MACRO_TAP(cp_GRAV_U_,  &kp GRAV_  &kp LS(U_))
						  
		// MACRO_TAP(cp_TILD_A_,  &kp TILD_  &kp LS(A_))
		// MACRO_TAP(cp_TILD_O_,  &kp TILD_  &kp LS(O_))
		// MACRO_TAP(cp_TILD_N_,  &kp TILD_  &kp LS(N_))
					  
		// MACRO_TAP(cp_TRMA_I_,  &kp TRMA_  &kp LS(I_))


		/* qu  */  MACRO_SIMPLE(Q_, U_)
		/* bj  */  MACRO_SIMPLE(B_, J_)
		
		/* QU  */  MACRO_TAP(cp_qu,      &kp LS(Q_) &kp LS(U_))
		/* BJ  */  MACRO_TAP(cp_bj,      &kp LS(B_) &kp LS(J_))
		
		/*  Ñ  */  MACRO_TAP(cp_tl_n,    &kp TILD_  &kp LS(N_))
		
		
		/* ãe  */  MACRO_TAP(ae,         &kp TILD_  &kp A_  &kp E_)
		/* ão  */  MACRO_TAP(ao,         &kp TILD_  &kp A_  &kp O_)
		/* õe  */  MACRO_TAP(oe,         &kp TILD_  &kp O_  &kp E_)
		
		/* ÃE  */  MACRO_TAP(cp_ae,      &kp TILD_  &kp LS(A_)  &kp LS(E_))
		/* ÃO  */  MACRO_TAP(cp_ao,      &kp TILD_  &kp LS(A_)  &kp LS(O_))
		/* ÕE  */  MACRO_TAP(cp_oe,      &kp TILD_  &kp LS(O_)  &kp LS(E_))
		
		
		/*  ß  */  MACRO_TAP(eszett,     &kp RA(S_)  &kp    S_)
		/*  ẞ  */  MACRO_TAP(cp_sztt,    &kp RA(S_)  &kp LS(S_))


		/* ■?  */  MACRO_TAP(nbsp_qmrk,  &kp LS(SPACE)  &kp LS(QMRK_))
		/* ■!  */  MACRO_TAP(nbsp_excl,  &kp LS(SPACE)  &kp LS(EXCL_))
		/* ■:□ */  MACRO_TAP(nbsp_coln,  &kp LS(SPACE)  &kp LS(DOT_)   &kp SPACE)
		/* ■;□ */  MACRO_TAP(nbsp_scln,  &kp LS(SPACE)  &kp LS(COMM_)  &kp SPACE)
		/* ■»□ */  MACRO_TAP(nbsp_rglm,  &kp LS(SPACE)  &kp RGLM_)
		/* □«■ */  MACRO_TAP(nbsp_lglm,  &kp LGLM_      &kp LS(SPACE))
			   
			   
		/*  ^  */  MACRO_TAP(cfxloos,    &kp CFLX_  &kp SPACE)
		/*  `  */  MACRO_TAP(grvloos,    &kp GRAV_  &kp SPACE)

		// key and turn off capsword
		MACRO_TAP(spc_cpwd,  &kp SPACE  &tog CPWD)
		MACRO_TAP(tab_cpwd,  &kp TAB    &tog CPWD)
		MACRO_TAP(entr_cpwd, &kp ENTER  &tog CPWD)
		MACRO_TAP(esc_cpwd,  &kp ESC    &tog CPWD)
		
		// used with security_hold
		MACRO_TAP(cut_all,   &kp LC(A_) &kp LS(X_))
		MACRO_TAP(copy_all,  &kp LC(A_) &kp LS(C_))
		MACRO_TAP(paste_all, &kp LC(A_) &kp LS(V_))
		
		// doesn't work but maybe one day
		// MACRO(ctrltab,   <&macro_press &kp LCTRL>,           <&macro_tap &kp TAB>,  <&macro_pause_for_release>,  <&macro_release &kp LCTRL>)
		// MACRO(ctshtab,   <&macro_press &kp LSHFT &kp LCTRL>, <&macro_tap &kp TAB>,  <&macro_pause_for_release>,  <&macro_release &kp LCTRL &kp LSHFT>)
		// MACRO(alttab,    <&macro_press &kp LALT>,            <&macro_tap &kp TAB>,  <&macro_pause_for_release>,  <&macro_release &kp LALT>)
		// MACRO(altshtab,  <&macro_press &kp LSHFT &kp LALT>,  <&macro_tap &kp TAB>,  <&macro_pause_for_release>,  <&macro_release &kp LALT  &kp LSHFT>)
	};

	combos {
		compatible = "zmk,combos";

		#define DEFINE_COMBO(LAYERS, BINDINGS, POSITIONS, NAME) \
			combo_##NAME { \
				layers = <LAYERS>; \
				bindings = <BINDINGS>; \
				key-positions = <POSITIONS>; \
				timeout-ms = <_COMBO_TIMEOUT>; \
			};

		// when not defining layers, will default to NOT_GAME
		// TODO: ok to omit line breaks between defs?
		// TODO: all combos define layers
		#define COMBO(BINDINGS, POSITIONS, RANDOM_NAME) \
			DEFINE_COMBO(NOT_GAME, BINDINGS, POSITIONS, RANDOM_NAME)

		#define COMBO_LAYER(LAYERS, BINDINGS, POSITIONS, RANDOM_NAME) \
			DEFINE_COMBO(LAYERS, BINDINGS, POSITIONS, RANDOM_NAME)

		// single key press
		#define COMBO_KP(KEY, SUFFIX, POSITIONS) \
			DEFINE_COMBO(NOT_GAME, &kp KEY, POSITIONS, KEY##SUFFIX)

		#define COMBO_KP_LAYER(KEY, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS, &kp KEY, POSITIONS, KEY##SUFFIX)

		// macrco
		#define COMBO_MACRO(MACRO, POSITIONS) \
			DEFINE_COMBO(NOT_GAME, &m_##MACRO, POSITIONS, MACRO)

		#define COMBO_MACRO_LAYER(MACRO, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS, &m_##MACRO, POSITIONS, MACRO##SUFFIX)


	/*
	    0   1   2   3      4 | 5      6   7   8   9
	    10  11  12  13    14 | 15    16  17  18  19
	    20  21  22  23    24 | 25    26  27  28  29
							 |
	                   30 31 | 32 33
	*/


		// fake tab
		// COMBO(&kp SPACE &kp SPACE &kp SPACE &kp SPACE, 10 11 12 13,       gslqaiogrnqsl) // whatever name. enjoy
		// COMBO(&kp SPACE &kp SPACE &kp SPACE &kp SPACE, 16 17 18 19,       rgsaiornqsj)

		COMBO_KP(SPACE,l,                    11 12 13)
		COMBO_KP(SPACE,r,                    16 17 18)

		// backspace and del, with and wo ctrl
		COMBO_KP( BSPC,,                     11 12)
		COMBO_KP( DEL,,                      21 22)
		COMBO(&kp LC(BSPC),                  17 18, gslqgrnqsl) // whatever name. enjoy
		COMBO(&kp LC(DEL),                   27 28, rgsrnteqsj)

		// one-shot shift on both thumb keys at once
		COMBO(&lsk FUNC LSHIFT,              30 31, dljsdiqsrt)
		COMBO(&sk  RSHIFT,                   32 33, sqljqrjqsl)
								              
		COMBO_MACRO_LAYER(Q_U_,,   26 27, BASE) /* qu */  
		COMBO_MACRO_LAYER(ae,,     13 30, BASE) /* ãe */  
		COMBO_MACRO_LAYER(ao,,     13 11, BASE) /* ão */  
		COMBO_MACRO_LAYER(oe,,     11 30, BASE) /* õe */  
					                            			
		COMBO_MACRO_LAYER(cp_qu,,  26 27, CPWD) /* QU */  
		COMBO_MACRO_LAYER(cp_ae,,  13 30, CPWD) /* ÃE */  
		COMBO_MACRO_LAYER(cp_ao,,  13 11, CPWD) /* ÃO */  
		COMBO_MACRO_LAYER(cp_oe,,  11 30, CPWD) /* ÕE */  
								      
		// tab, enter, esc            
		COMBO_KP_LAYER(TAB,,                 12 13, NOT_CPWD)
		COMBO_KP_LAYER(ENTER,,               16 17, NOT_CPWD)
		COMBO_KP_LAYER(ESC,,                 10 11, NOT_CPWD)
		
		COMBO_MACRO_LAYER(tab_cpwd,,         12 13, CPWD)
		COMBO_MACRO_LAYER(entr_cpwd,,        16 17, CPWD)
		COMBO_MACRO_LAYER(esc_cpwd,,         10 11, CPWD)
		
		COMBO(&kp LC(Z_),                    20 21, rgsriaiaiqsj)
		COMBO_LAYER(FUNC, &sys_reset,         0  4, aiouaiouaiou)
		COMBO_LAYER(FUNC, &bootloader,       20 24, ayuqaioueaio)
		COMBO_LAYER(FUNC, &tog GAME,          4 14, aiouayopaipo)
		COMBO_LAYER(FUNC, &tog GAM2,         14 24, aiopoappyaio)
	};

	keymap {
		compatible = "zmk,keymap";

        // readability
		#define _____      &trans
		#define xxxxx      &none
		#define _________  &trans
		#define xxxxxxxxx  &none

        // readability also
		#define C_S_DEL      &kp LC(LS(DEL))    // task manager
		#define PASTEPLAIN   &kp LC(LG(LA(V_))) // power toys plaintext paste (no &kp bc used in &ht)
		#define RESET_LEFT   &sys_reset   	    // mnemonic (called on the right it resets both)

		// home-row mods
		#define HMLS    &htl     LSHIFT // left shift only works for keys on right hand
		#define HMRS    &htr     RSHIFT // rite shift only works for keys on lefft hand
		#define HMLC    &ht      LCTRL
		#define HMRC    &ht      RCTRL
		#define HMLA    &ht      LALT
		#define HMRA    &ht      RALT
		#define HMLG    &htslow  LGUI // i kept holding GUI by accident,
		#define HMRG    &htslow  RGUI // so i made it slower
		
		 // sticky mods in nav layer
		#define SKLS    &htsk   LSHIFT
		#define SKLC    &htsk   LCTRL
		#define SKLA    &htsk   LALT
		#define SKLG    &htsk   LGUI

		// tap/hold  (□ = space, ■ = nbsp)             // TAP      HOLD
		#define DLLR_EURO   &mt        EURO_ DLLR_     //  $        €
		#define EQUL_DIFF   &mt        DIFF_ EQUL_     //  =        ≠
													   
		#define NBSP_QMRK   &ht_qmrk   0     QMRK_     // (?)       ■?
		#define NBSP_EXCL   &ht_excl   0     EXCL_     // (!)       ■!
		#define DOT_COLN    &ht_coln   0     DOT_      // (.)       ■:□
		#define COMM_SCLN   &ht_scln   0     COMM_     // (,)       ■;□
									  	     	       
		#define NBSP_LGLM   &ht_lglm   LGLM_ 0         // «■       («)
		#define NBSP_RGLM   &ht_rglm   RGLM_ 0         //  ■»      (»)

		#define CUT_ALL     &sechold_cutall   0 LC(A_) // ^A        cut   all	// DANGEROUS STUFF!
		#define COPY_ALL    &sechold_copyall  0 LC(A_) // ^A        copy  all	//  must hold for
		#define PASTE_ALL   &sechold_pasteall 0 LC(A_) // ^A        paste all	//  very long time
												    
		// #define HT_CTRZ      &ht     LC(Y_)  LC(Z_)  // ^Z       ^Y
		// #define HT_CTRV      &ht PASTEPLAIN  LC(V_)  // ^V       plaintext paste (powertoys)

		// thumb keys
		#define TH_L_MAIN      &lt   NUM E_
		#define TH_L_MAIN_CW   &lt   NUM LS(E_) // capsword

		#define TH_L_AUX       &lsl  SYM SYM

		#define TH_R_MAIN      &lt      NAV SPACE
		#define TH_R_MAIN_CW   &htcpwd  NAV 0  // capsword

		#define TH_R_AUX       &lsl  ACNT ACNT


                                      // --- left hand --- //      // --- right hand --- //
		#define _THUMBS_CAPSWORD_     TH_L_MAIN_CW _________       _________  TH_R_MAIN_CW
		#define _THUMBS_LEFT_         TH_L_MAIN    TH_L_AUX
		#define _THUMBS_RIGHT_                                      TH_R_AUX  TH_R_MAIN
		#define _THUMBS_DEFAULT_          _THUMBS_LEFT_                _THUMBS_RIGHT_
	


		// todo reorder layers according to thumbs
		base_layer {
			bindings = <
				&kp  Q_      HMRA MIN_   &kp  Y_  DOT_COLN   NBSP_QMRK         &kp K_   &kp  C_   &kp  H_   &kp  W_   &kp  J_
				HMLG U_      HMLA O_     HMLC I_  HMLS A_    &kp F_            &kp G_   HMRS T_   HMRC R_   HMRA S_   HMRG N_
				&lt UTIL Z_  HMLC EACT_  &kp  P_  COMM_SCLN  &kp X_            &kp V_   &kp  D_   &kp  M_   &kp  L_   &lt UTIL B_
				//
															       _THUMBS_DEFAULT_
			>;
		};

		caps_word_layer {
			bindings = <
				&kp  LS(Q_)	 HMRA MIN_       &kp  LS(Y_)  DOT_COLN       _________          &kp LS(K_)    &kp  LS(C_)  &kp  LS(H_)  &kp  LS(W_)  &kp  LS(J_)
				HMLG LS(U_)	 HMLA LS(O_)	 HMLC LS(I_)  HMLS LS(A_)    &kp LS(F_)         &kp LS(G_)    HMRS LS(T_)  HMRC LS(R_)  HMRA LS(S_)  HMRG LS(N_)
				&kp  LS(Z_)	 HMLC LS(EACT_)	 &kp  LS(P_)  COMM_SCLN      &kp LS(X_)         &kp LS(V_)    &kp  LS(D_)  &kp  LS(M_)  &kp  LS(L_)  &kp  LS(B_)
				//
														                     _THUMBS_CAPSWORD_
			>;
		};

		num_layer {
			bindings = <
				&kp PIPE_  &kp N7_  &kp N8_  &kp N9_    xxxxxxxxx         DLLR_EURO    &kp  LBRK_  &kp  RBRK_   &kp  HASH_   &kp  PCNT_
				&kp N0_    &kp N1_  &kp N2_  &kp N3_    &kp DOT_          xxxxxxxxx    HMRS PLUS_  HMRC MIN_    HMLA STAR_   HMRG FSLA_
				xxxxxxxxx  &kp N4_  &kp N5_  &kp N6_    &kp COMM_         xxxxxxxxx    &kp  LT_    &kp  GT_	    EQUL_DIFF    &kp  BSLA_
				//
				                                    _THUMBS_LEFT_         &kp ULIN_    _________
			>;
		};

		utility_layer {
			bindings = <
				xxxxxxxxx   xxxxxxxxx    xxxxxxxxx        xxxxxxxxx      xxxxx         xxxxx    xxxxx xxxxx xxxxx xxxxx
				xxxxxxxxx   xxxxxxxxx    &kp LS(LC(TAB))  &kp LC(TAB)    xxxxx         xxxxx    xxxxx xxxxx xxxxx xxxxx
				xxxxxxxxx   &kp LG(TAB)  &kp LS(LA(TAB))  &kp LA(TAB)    xxxxx         xxxxx    xxxxx xxxxx xxxxx xxxxx
				//
			                                                    xxxxx    xxxxx         xxxxx   xxxxx
			>;
		};

		sym_layer {
			bindings = <
				&kp AE_		 &kp AT_       &kp AMPR_   &kp OE_       NBSP_EXCL         xxxxx    DLLR_EURO    xxxxxxxxx    xxxxxxxxx    xxxxxxxxx
				SKLG LCRL_	 SKLA RCRL_    SKLC LPAR_  SKLS RPAR_    &kp MDSH_         xxxxx    HMRS xxxxx   HMRC xxxxx   HMRA xxxxx   HMRG PIPE_
				&kp NDSH_	 &kp MDSH_     NBSP_LGLM   NBSP_RGLM     xxxxxxxxx         xxxxx    xxxxxxxxx    &m_grvloos   &m_cfxloos   xxxxxxxxx
				//
								                       _________     &kp ULIN_        _THUMBS_RIGHT_
			>;
		};

		accent_layer {
			bindings = <
				&m_CFLX_U_  &m_CFLX_O_  &m_CFLX_I_  &m_CFLX_A_    xxxxxxxxx          xxxxxxxxx    &kp  CCED_  &kp  APST_  &kp  QUOT_  &m_B_J_
				&m_ACUT_U_  &m_ACUT_O_  &m_ACUT_I_  &m_ACUT_A_    &m_TILD_A_         xxxxxxxxx    HMRS ACUT_  HMRC GRAV_  HMLA CFLX_  &m_TILD_N_
				&m_GRAV_U_  &m_TILD_O_  &m_TRMA_I_  &kp AGRV_     xxxxxxxxx          xxxxxxxxx    &kp  TRMA_  xxxxxxxxx   &m_eszett   &kp TILD_
				//
												    &m_CFLX_E_    &kp EGRV_         _THUMBS_RIGHT_
			>;
		};

		accent_caps_layer {
			bindings = <
				&m_cp_CFLX_U_  &m_cp_CFLX_O_  &m_cp_CFLX_I_  &m_cp_CFLX_A_    xxxxxxxxx             xxxxxxxxx    &kp  CCED_  &kp  APST_  &kp  QUOT_  &m_cp_bj
				&m_cp_ACUT_U_  &m_cp_ACUT_O_  &m_cp_ACUT_I_  &m_cp_ACUT_A_    &m_cp_TILD_A_         xxxxxxxxx    HMRS ACUT_  HMRC GRAV_  HMLA CFLX_  &m_cp_tl_n
				&m_cp_GRAV_U_  &m_cp_TILD_O_  &m_cp_TRMA_I_  &kp LS(AGRV_)    xxxxxxxxx             xxxxxxxxx    &kp  TRMA_  xxxxxxxxx   &m_cp_sztt  &kp TILD_
				//
												             &m_cp_CFLX_E_    &kp LS(EGRV_)        _THUMBS_RIGHT_
			>;
		};

		nav_layer {
			bindings = <
				&kp xxxxx	CUT_ALL	    COPY_ALL     PASTE_ALL     C_S_DEL            &sk  RALT    HMLS LC(HOME)   HMLC PG_DN   HMLA PG_UP   HMRG LC(END)
				HMLG LC(Y_) HMLA INSERT	HMLC PSCRN	 HMLS PSBRK    &kp CAPS           &tog CPWD    &kp  LC(LEFT)   &kp  DOWN	&kp  UP	     &kp  LC(RIGHT)
				&kp  LC(Z_)	&kp  LC(X_)	&kp  LC(C_)	 &kp  LC(V_)   PASTEPLAIN         xxxxxxxxx    &kp  HOME       &kp  LEFT	&kp  RIGHT   &kp  END
				//
												                           _THUMBS_DEFAULT_
			>;
		};

		func_layer {
			bindings = <
				&bt  BT_CLR     &bt  BT_SEL 0   &bt  BT_SEL 1   &bt  BT_SEL 2  &bt BT_SEL 3         RESET_LEFT    &kp F7  &kp F8  &kp F9  &kp F10
				HMLG C_BRI_UP   HMLA C_NEXT     HMLC C_VOL_UP   HMLS C_PP  	   &kp LSLCK            &out OUT_BLE  &kp F1  &kp F2  &kp F3  &kp F11
				&kp  C_BRI_DN   &kp  C_PREV     &kp  C_VOL_DN   &kp  C_MUTE    &kp LNLCK            &out OUT_USB  &kp F4  &kp F5  &kp F6  &kp F12
				//
															                           _THUMBS_DEFAULT_
			>;
		};

		game_layer {
			bindings = <
				&kp Q_      &kp MIN_   &kp Y_     &kp DOT_     &kp R_            &kp  K_      &kp C_     &kp H_     &kp W_     &kp J_
				&kp U_      &kp O_     &kp I_     &kp A_       &kp F_            &kp  G_      &kp LEFT   &kp UP     &kp RIGHT  &kp N_
				&kp Z_      &kp S_     &kp P_     &kp COMM_    &kp X_            &tog GAME    &kp D_     &kp DOWN   &kp L_     &kp B_
				//
											      &kp ENTER    &kp SPACE         &kp  TAB     &kp LALT
			>;
		};

		game_layer_2 {
			bindings = <
				&kp LSHIFT  &kp A_     &kp EACT_  &kp I_      &kp O_            &kp  Y_      &kp U_     &kp I_     &kp O_     &kp P_
				&kp LCTRL   &kp B_     &kp U_     &kp P_      &kp E_            &kp  H_      &kp J_     &kp K_     &kp L_     &kp N_
				&kp ESC     &kp AGRV_  &kp Y_     &kp X_      &kp DOT           &tog GAM2    &kp M_     &kp COMM_	 &kp DOT_   &kp BSPC
				//
												  &kp ENTER   &kp SPACE         &kp  TAB   &kp LALT
			>;
		};

		/* FOR DEBUGGING:
			bindings = <
				xxxxx xxxxx xxxxx xxxxx   xxxxx         xxxxx   xxxxx xxxxx xxxxx xxxxx
				xxxxx xxxxx xxxxx xxxxx   xxxxx         xxxxx   xxxxx xxxxx xxxxx xxxxx
				xxxxx xxxxx xxxxx xxxxx   xxxxx         xxxxx   xxxxx xxxxx xxxxx xxxxx
			                   xxxxx   xxxxx         xxxxx   xxxxx
			>;
		*/
	};
};