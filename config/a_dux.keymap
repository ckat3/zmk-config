#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/outputs.h>

#include "bepo_bindings.h"

// SETTINGS
#define _STICKY_TIMEOUT      2000

#define _MACRO_INTERVAL      3    // delay between key presses
#define _MACRO_TAP_FOR       3    // how long to hold tapped key

#define _COMBO_TIMEOUT       18   // maximum interval between keys to form combo
#define _COMBO_TIMEOUT_SLOW  50

// holdtap settings
#define _HT_TAPLIMIT_SLOW       300  // how long must hold to not be tap
#define _HT_TAPLIMIT            260  // (280 is good)
#define _HT_TAPLIMIT_FAST       200  // 
#define _HT_TAPLIMIT_FASTER     120  // 

#define _HT_QUICK_TAP           200  // how fast must press twice for second to start repeating tap


// LAYERS
#define _l_BASE 0
#define _l_CAPS 1
#define _l_OSCP 2
#define _l_NUM  3
#define _l_SYM  4
#define _l_UTIL 5
#define _l_NAV  6
#define _l_NAVC 7
#define _l_ACNT 8
#define _l_ACCP 9
#define _l_FUNC 10
#define _l_GAME 11
#define _l_GAM2 12

// combos shouldn't work on game layer, to minimize delay
#define _l_ALL_LAYERS   _l_BASE  _l_CAPS  _l_OSCP  _l_NUM  _l_SYM  _l_UTIL  _l_NAV  _l_NAVC  _l_ACNT  _l_ACCP  _l_FUNC  _l_GAME  _l_GAM2
#define _ll_NOTGAME     _l_BASE  _l_CAPS  _l_OSCP  _l_NUM  _l_SYM  _l_UTIL  _l_NAV  _l_NAVC  _l_ACNT  _l_ACCP  _l_FUNC
#define _ll_NOTCAPS     _l_BASE                    _l_NUM  _l_SYM  _l_UTIL  _l_NAV  _l_NAVC  _l_ACNT  _l_ACCP  _l_FUNC
#define _ll_CAPS        _l_CAPS  _l_OSCP
#define _ll_CPWD        _l_CAPS 


&lt { // tap for kp, hold for layer
	flavor          = "balanced";
	tapping-term-ms = <_HT_TAPLIMIT>;
	quick-tap-ms    = <_HT_QUICK_TAP>;
};

&mt { // hold-tap
	tapping-term-ms = <_HT_TAPLIMIT_FASTER>;
	quick-tap-ms    = <_HT_QUICK_TAP>;
};

&sk { // one-shot layer
	release-after-ms = <_STICKY_TIMEOUT>;
	quick-release;
};


// mo  = layer while held
// lt  = hold-tap layer/kp
// to  = enables only this layer
// tog = toggle layer

/ {
	behaviors {
		#define _POSITIONS_LH   0 1 2 3 4 10 11 12 13 14 20 21 22 23 24 30 31
		#define _POSITIONS_RH   5 6 7 8 9 15 16 17 18 19 25 26 27 28 29 32 33
		#define _ALL_POSITIONS  _POSITIONS_LH  _POSITIONS_RH
		// #define _ALL_POSITIONS 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33

		#define DEFINE_HOLDTAP(NAME, FLAVOR, DELAY, POSITIONS, BINDINGS...) \
			NAME: ht_##NAME { \
				label           = #NAME; \
				flavor          = #FLAVOR; \
				tapping-term-ms = <DELAY>; \
				quick-tap-ms    = <_HT_QUICK_TAP>; \
				bindings        = BINDINGS; \
				 \
				#binding-cells  = <2>; \
				compatible      = "zmk,behavior-hold-tap"; \
				 \
				hold-trigger-key-positions = <POSITIONS>; \
			};

		#define HT(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _HT_TAPLIMIT, _ALL_POSITIONS, BINDINGS)

		#define HT_FAST(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _HT_TAPLIMIT_FAST, _ALL_POSITIONS, BINDINGS)

		#define HT_BAL(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, balanced, _HT_TAPLIMIT, _ALL_POSITIONS, BINDINGS)

		#define HRMOD_POS(NAME, POSITIONS) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _HT_TAPLIMIT, POSITIONS, <&kp>, <&kp>)

		#define HT_SLOW(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _HT_TAPLIMIT_SLOW, _ALL_POSITIONS, BINDINGS)

	 // HOME-ROW MODS                       // HOLD           TAP             
		HT(      ht,     <&kp>,  <&kp> )    // kp             kp                tap-preferred
		HT_SLOW( htslow, <&kp>,  <&kp> )    // kp (slow)      kp (slow)         tap-preferred (from HT)
		HT(      httog,  <&kp>,  <&tog> )   // kp             one-shot layer    tap-preferred (from HT)
		HT(      htsl,   <&kp>,  <&sl> )    // kp             one-shot layer    tap-preferred (from HT)
		HT_BAL(  lsl,    <&mo>,  <&sl> )    // layer          one-shot layer    balanced
		HT_BAL(  lsk,    <&mo>,  <&sk> )    // layer          one-shot mod      balanced
		HT(      ltt,    <&mo>,  <&kp> )    // layer          kp                tap-preferred (from HT)


	 // hrm for opposite hand only (used for shift)
		HRMOD_POS( htl, _POSITIONS_RH )
		HRMOD_POS( htr, _POSITIONS_LH )


	 // OTHER HOLDTAPS : deactivates capsword, then…                    // HOLD                       TAP    
		HT_BAL(  ht_cw_l_NAV_SPC, <&m_mo_cw_l_NAV>,  <&m_cw_SPC> )      // hold _l_NAV -> to base     SPC    -> to base   balanced
		HT_BAL( lsl_cw_l_SYM,       <&mo>,           <&m_sl_cw_l_SYM> ) // hold layer                 sl SYM -> to base   balanced
		HT_SLOW(   ltt_l_UTIL,    <&m_mo_l_UTIL>,    <&kp> )            // hold _l_UTIL               kp                  tap-preferred (from HT)


	 // loose accents on tap
		HT( ht_CFX, <&kp>, <&m_CFX_loose> )
		HT( ht_GRV, <&kp>, <&m_GRV_loose> )
		HT( ht_TLD, <&kp>, <&m_TLD_loose> )
		
		
	 // NBSP STUFF (for french) ------------------
	 // automatic nbsp on tap
		HT( ht_LGLM, <&kp>, <&m_nbsp_LGLM> )
		HT( ht_RGLM, <&kp>, <&m_nbsp_RGLM> )

	 // automatic nbsp on hold
		HT_FAST( ht_COLN, <&m_nbsp_COLN>, <&kp> )
		HT_FAST( ht_SCLN, <&m_nbsp_SCLN>, <&kp> )
		HT_FAST( ht_QMRK, <&m_nbsp_QMRK>, <&kp> )
		HT_FAST( ht_EXCL, <&m_nbsp_EXCL>, <&kp> )
	};



	macros {
		// syntactic sugar
		#define M_TAP         &macro_tap
		#define M_HOLD        &macro_press
		#define M_REL         &macro_release

		#define M_KP          &macro_tap &kp
		#define M_KP_HOLD     &macro_press &kp
		#define M_KP_REL      &macro_release &kp

		#define M_WAIT_REL    &macro_pause_for_release

		#define M_HOLD_SHIFT  <M_KP_HOLD LSHFT>
		#define M_REL_SHIFT   <M_KP_REL  LSHFT>, <M_KP_REL RSHFT>

		// BASE MACRO
		// (all macro names will be prefixed by m_)
		#define MACRO(NAME, BINDINGS...) \
			ZMK_MACRO(m_##NAME, \
				tap-ms   = <_MACRO_TAP_FOR>; \
				wait-ms  = <_MACRO_INTERVAL>; \
				bindings = BINDINGS; \
				)

		#define MACRO_TWO_KP(NAME, ONE, TWO) \
			NAME: NAME { \
				compatible = "zmk,behavior-macro-two-param"; \
				label = "M2_##NAME"; \
				#binding-cells = <2>; \
				tap-ms   = <_MACRO_TAP_FOR>; \
				wait-ms  = <_MACRO_INTERVAL>; \
				bindings = <&macro_param_1to1>, <&kp MACRO_PLACEHOLDER>, <&macro_param_2to1>, <&kp MACRO_PLACEHOLDER>; \
			};


		// MACRO_TAP : tap whatever command sequence is given
		#define MACRO_TAP(NAME, BINDINGS...) \
			MACRO(NAME, <M_TAP BINDINGS>)


		// MACRO_DIGRAM : tap a key, release shift if held, tap another
		//                (so can eg hold shift and do &m_Q_U_ to get Qu)
		//                also defines a capsword version which holds shift during both
		#define MACRO_DIGRAM(FIRST, SECOND) \
			MACRO(FIRST##SECOND,                      <M_KP FIRST>, M_REL_SHIFT, <M_KP SECOND>) \
			\
			MACRO(cw_##FIRST##SECOND,  M_HOLD_SHIFT,  <M_KP FIRST>,              <M_KP SECOND>,  M_REL_SHIFT)

		// TODO : this was meant for the eszett, but if it doesn't work i might as well merge it with ACCENT_1.
		#define MACRO_ACCENT_NAMED(NAME, ACCENT, LETTER) \
			MACRO(NAME,      <M_KP ACCENT>, M_REL_SHIFT,  <M_KP LETTER>) \
			\
			MACRO(cw_##NAME, <M_KP ACCENT>, M_HOLD_SHIFT, <M_KP LETTER>, M_REL_SHIFT)


		#define MACRO_ACCENT_SINGLE(ACCENT, LETTER) \
			MACRO_ACCENT_NAMED(ACCENT##LETTER, ACCENT, LETTER)


		#define MACRO_ACCENT_DOUBLE(ACCENT, FIRST, SECOND) \
			MACRO(     ACCENT##FIRST##SECOND, <M_KP ACCENT>,               <M_KP FIRST>, M_REL_SHIFT, <M_KP SECOND>) \
			\
			MACRO(cw_##ACCENT##FIRST##SECOND, <M_KP ACCENT>, M_HOLD_SHIFT, <M_KP FIRST>,              <M_KP SECOND>,  M_REL_SHIFT)



	 //
	 // TODO
	 //
	 // MACRO_ACCENT_NAMED(SZTT,     SZTTMOD_,   S_)
		MACRO_TAP(    SZTT,  &kp RA(S_)  &kp    S_ )
		MACRO_TAP( cw_SZTT,  &kp RA(S_)  &kp LS(S_))


	 //
	 // INCONVENIENT DIGRAMS ------------------
	 // also defines a caps version (eg &m_cw_Q_U_)
	 //
		MACRO_DIGRAM(Q_, U_)
		MACRO_DIGRAM(B_, J_)


	 //
	 // ACCENTED LETTERS ------------------
	 // also defines a caps version (eg &m_cw_ACUT_A_)
	 //
		MACRO_ACCENT_SINGLE( ACUT_, A_ )
		MACRO_ACCENT_SINGLE( ACUT_, I_ )
		MACRO_ACCENT_SINGLE( ACUT_, O_ )
		MACRO_ACCENT_SINGLE( ACUT_, U_ )

		MACRO_ACCENT_SINGLE( CFLX_, A_ )
		MACRO_ACCENT_SINGLE( CFLX_, E_ )
		MACRO_ACCENT_SINGLE( CFLX_, I_ )
		MACRO_ACCENT_SINGLE( CFLX_, O_ )
		MACRO_ACCENT_SINGLE( CFLX_, U_ )

		MACRO_ACCENT_SINGLE( GRAV_, E_ )
		MACRO_ACCENT_SINGLE( GRAV_, O_ )
		MACRO_ACCENT_SINGLE( GRAV_, U_ )

		MACRO_ACCENT_SINGLE( TILD_, A_ )
		MACRO_ACCENT_SINGLE( TILD_, O_ )
		MACRO_ACCENT_SINGLE( TILD_, N_ )
		MACRO_ACCENT_DOUBLE( TILD_, A_, E_ )
		MACRO_ACCENT_DOUBLE( TILD_, A_, O_ )
		MACRO_ACCENT_DOUBLE( TILD_, O_, E_ )

		MACRO_ACCENT_SINGLE( TRMA_, I_ )


	 //
	 // NBSP STUFF (for french) ------------------
	 //
		MACRO_TAP( nbsp_QMRK,  &kp NBSP_  &kp QMRK_ )
		MACRO_TAP( nbsp_EXCL,  &kp NBSP_  &kp EXCL_ )
		MACRO_TAP( nbsp_COLN,  &kp NBSP_  &kp COLN_  &kp SPACE )
		MACRO_TAP( nbsp_SCLN,  &kp NBSP_  &kp SCLN_  &kp SPACE )
		MACRO_TAP( nbsp_RGLM,  &kp NBSP_  &kp RGLM_ )
		MACRO_TAP( nbsp_LGLM,  &kp LGLM_  &kp NBSP_ )


	 //
	 // LOOSE ACCENTS ------------------
	 //
		MACRO_TAP( CFX_loose,  &kp CFLX_  &kp SPACE )
		MACRO_TAP( GRV_loose,  &kp GRAV_  &kp SPACE )
		MACRO_TAP( TLD_loose,  &kp TILD_  &kp SPACE )


	 //
	 // CAPSWORD ------------------
	 //
	 // key -> capsword off
		MACRO_TAP( cw_SPC,  &kp SPACE  &to _l_BASE )
		MACRO_TAP( cw_TAB,  &kp TAB    &to _l_BASE )
		MACRO_TAP( cw_ENTR, &kp ENTER  &to _l_BASE )
		MACRO_TAP( cw_ESC,  &kp ESC    &to _l_BASE )

	 // capsword off + hold layer
		MACRO( mo_cw_l_NAV,   < M_TAP  &to _l_BASE  &tog _l_NAV  &tog _l_NAVC >,   <M_WAIT_REL>,  < M_TAP  &to _l_BASE > )
		
	 // capsword off + one-shot layer
		MACRO( sl_cw_l_SYM,   < M_TAP  &to _l_BASE  &sl _l_SYM  > )
		MACRO( sl_cw_l_ACNT,  < M_TAP  &to _l_BASE  &sl _l_ACNT > )

	 // new sentence
	    MACRO_TAP(   oneshotCAPS,                       &sl _l_CAPS  &sl _l_OSCP )
		MACRO_TAP(     SPC_upper,            &kp SPACE  &sl _l_CAPS              )
		MACRO_TAP( DOT_SPC_upper,  &kp DOT_  &kp SPACE  &sl _l_CAPS              )


	 //
	 // UTIL LAYER ------------------
	 // upon entering this layer, shift + control + alt are held.
	 // each key releases some mods, then holds them all again.
	 // this allows us e.g. to alt-tab without letting go of alt.
	 //
		#define  ALL_MODS   M_HOLD  &kp LSHIFT  &kp LCTRL  &kp LALT
		#define   NO_MODS   M_REL   &kp LSHIFT  &kp LCTRL  &kp LALT
		#define HOLD_CTRL   M_REL   &kp LSHIFT             &kp LALT
		#define HOLD_ALT    M_REL   &kp LSHIFT  &kp LCTRL

		MACRO( mo_l_UTIL,  <M_HOLD &mo _l_UTIL>,  <ALL_MODS>,  <M_WAIT_REL>,  <M_REL &mo _l_UTIL>,  <NO_MODS> )

		MACRO(  utl_BACK,    <NO_MODS>,  <M_KP  C_AC_BACK   >,  <ALL_MODS> )
		MACRO(  utl_FRWD,    <NO_MODS>,  <M_KP  C_AC_FORWARD>,  <ALL_MODS> )
		MACRO( utl_ULIN,     <NO_MODS>,  <M_KP  ULIN_>,         <ALL_MODS> )
		MACRO( utl_UNDO,     <NO_MODS>,  <M_KP  LC(Z_)>,        <ALL_MODS> )
		MACRO( utl_REDO,     <NO_MODS>,  <M_KP  LC(Y_)>,        <ALL_MODS> )
		MACRO( utl_LAF4,     <NO_MODS>,  <M_KP  LA(F4)>,        <ALL_MODS> )

		MACRO(  utl_STAB,    <NO_MODS>,  <M_KP  LS(TAB)>,       <ALL_MODS> )
		MACRO(  utl_GTAB,    <NO_MODS>,  <M_KP  LG(TAB)>,       <ALL_MODS> )

		MACRO(  utl_ATAB,   <HOLD_ALT>,  <M_KP     TAB > ) // these will not hold all mods back,
		MACRO( utl_SATAB,   <HOLD_ALT>,  <M_KP  LS(TAB)> ) //  so that we can do alt-tab etc
		MACRO(  utl_CTAB,  <HOLD_CTRL>,  <M_KP     TAB > ) //  several times in a row without
		MACRO( utl_SCTAB,  <HOLD_CTRL>,  <M_KP  LS(TAB)> ) //  dropping the little window


	};



	combos {
		compatible = "zmk,combos";

		#define DEFINE_COMBO(LAYERS, NAME, POSITIONS, BINDINGS...) \
			combo_##NAME { \
				layers        = <LAYERS>; \
				key-positions = <POSITIONS>; \
				bindings      = <BINDINGS>; \
				timeout-ms    = <_COMBO_TIMEOUT>; \
			};


		// when not defining layers, will default to _ll_NOTGAME
		// TODO: ok to omit line breaks between defs?
		// TODO: all combos define layers?
		#define COMBO(       LAYERS,        BINDINGS,   POSITIONS,   GIBBERISH_NAME) \
			DEFINE_COMBO(    LAYERS,  GIBBERISH_NAME,   POSITIONS,   BINDINGS)

		// suffix must be added if there's more than one combo for the same key or macro
		#define COMBO_KP(    LAYERS,     KEY, SUFFIX,   POSITIONS) \
			DEFINE_COMBO(    LAYERS,     KEY##SUFFIX,   POSITIONS,   &kp KEY)

		#define COMBO_MACRO( LAYERS,   MACRO, SUFFIX,   POSITIONS) \
			DEFINE_COMBO(    LAYERS,   MACRO##SUFFIX,   POSITIONS,   &m_##MACRO)


	/*
	    0    1   2   3     4 |  5     6   7   8   9
	    10  11  12  13    14 | 15    16  17  18  19
	    20  21  22  23    24 | 25    26  27  28  29
							 |
	                30  31   |   32  33
	*/

		// one-shot caps
		COMBO(   _ll_NOTGAME,   &m_oneshotCAPS,     11 12 13 ,    gibberishName_dljauiqsrt)
		COMBO(   _ll_NOTGAME,   &m_oneshotCAPS,     16 17 18 ,    gibberishName_dljoiadiuaisrt)
		COMBO(   _ll_NOTGAME,   &m_SPC_upper,        1  2  3 ,    gibberishName_diaoadiqsrt)
		COMBO(   _ll_NOTGAME,   &m_DOT_SPC_upper,   21 22 23 ,    gibberishName_dljoopoadiqsrt)
												     
		// lh                                        
		COMBO_KP(_ll_NOTGAME,       BSPC,,             11 12 )
		COMBO(   _ll_NOTGAME,   &kp LC(Z_),            20 21 ,    gibberishName_dljoiadiqsrt)
		COMBO_KP(_ll_NOTGAME,       DEL,,              21 22 )
		COMBO_KP(_ll_NOTGAME,       SPACE,,            22 23 )
											  	          
		// rh                                               
		COMBO(   _ll_NOTGAME,   &kp LC(BSPC),          17 18 ,    gibberishName_dljsdiooooisrt)
		COMBO(   _ll_NOTGAME,   &kp LC(DEL),           27 28 ,    gibberishName_dljsdaioaort)

		// one-shot shift on both thumb keys at once
		// TODO remove?
		COMBO(   _ll_NOTGAME,  &lsk _l_FUNC  LSHIFT,   30 31 ,    gibberishName_dljsdiqsrt)
		COMBO(   _ll_NOTGAME,   &sk          RSHIFT,   32 33 ,    gibberishName_sqljqrjqsl)
												  
		// TODO  merge these?                     
		COMBO_MACRO(  _l_BASE,      Q_U_,,             26 27 ) /* qu */
		COMBO_MACRO(  _l_BASE,      TILD_A_E_,,        13 30 ) /* ãe */
		COMBO_MACRO(  _l_BASE,      TILD_A_O_,,        13 11 ) /* ão */
		COMBO_MACRO(  _l_BASE,      TILD_O_E_,,        11 30 ) /* õe */
					 								   	 
		COMBO_MACRO( _ll_CPWD,      cw_Q_U_,,          26 27 ) /* QU */
		COMBO_MACRO( _ll_CAPS,      cw_TILD_A_E_,,     13 30 ) /* ÃE */
		COMBO_MACRO( _ll_CAPS,      cw_TILD_A_O_,,     13 11 ) /* ÃO */
		COMBO_MACRO( _ll_CAPS,      cw_TILD_O_E_,,     11 30 ) /* ÕE */
												      
		// tab, enter, esc                            
		COMBO_KP(    _ll_NOTCAPS,   TAB,,              12 13 )
		COMBO_KP(    _ll_NOTCAPS,   ENTER,,            16 17 )
		COMBO_KP(    _ll_NOTCAPS,   ESC,,              10 11 )									 				  
		COMBO_MACRO( _ll_CAPS,      cw_TAB,,           12 13 )
		COMBO_MACRO( _ll_CAPS,      cw_ENTR,,          16 17 )
		COMBO_MACRO( _ll_CAPS,      cw_ESC,,           10 11 )
									 				 	 
		// function layer
		COMBO( _l_FUNC,   &sys_reset,      0  4 ,   gibberishName_aiouaiouaiou)
		COMBO( _l_FUNC,   &bootloader,    20 24 ,   gibberishName_ayuqaioueaio)
		COMBO( _l_FUNC,   &tog _l_GAME,    4 14 ,   gibberishName_aiouayopaipo)
		COMBO( _l_FUNC,   &tog _l_GAM2,   14 24 ,   gibberishName_aiopoappyaio)
	};



	keymap {
		compatible = "zmk,keymap";

	 // READABILITY ------------------
		#define impossible  &none // physically impossible
		#define _________   &none
		#define _____       &none


	 // HOME-ROW MODS ------------------
		#define HMLS   &htl     LSHIFT // left shift only works for keys on right hand
		#define HMRS   &htr     RSHIFT // rite shift only works for keys on lefft hand
		#define HMLC   &ht      LCTRL
		#define HMRC   &ht      RCTRL
		#define HMLA   &ht      LALT
		#define HMRA   &ht      RALT
		#define HMLG   &htslow  LGUI // i kept holding GUI by accident,
		#define HMRG   &htslow  RGUI // so i made it slower


	 // HOLDTAP SYMBOLS ------------------
	 // □ = space, ■ = nbsp, () = explicited later       // HOLD  TAP
		#define DLLR_EURO    &htslow    EURO_  DLLR_     //  €     $
		#define EQUL_DIFF    &htslow    DIFF_  EQUL_     //  ≠     =
		#define IEXCL_IQMRK  &htslow    IEXC_  IQMR_     //  ¿     ¡
		#define EXCL_QMRK    &htslow    EXCL_  QMRK_     //  ?     !

		#define NBSP_QMRK    &ht_QMRK   0      QMRK_     // ■?    (?)
		#define NBSP_EXCL    &ht_EXCL   0      EXCL_     // ■!    (!)
		#define DOT_COLN     &ht_COLN   0      DOT_      // ■:□   (.)
		#define COMM_SCLN    &ht_SCLN   0      COMM_     // ■;□   (,)

		#define NBSP_LGLM    &ht_LGLM   LGLM_  0         // («)   «■
		#define NBSP_RGLM    &ht_RGLM   RGLM_  0         // (»)    ■»


	 // THUMB KEYS ------------------
		#define lt_NUM_E       &lt    _l_NUM  E_
		#define lt_NUM_E_cw    &lt    _l_NUM  LS(E_)

		#define lsl_SYM        &lsl   _l_SYM  _l_SYM
		#define lsl_SYM_cw     &lsl_cw_l_SYM  _l_SYM 0

		#define lsl_ACNT       &lsl  _l_ACNT  _l_ACNT
		#define lsl_ACCP       &lsl  _l_ACCP  _l_ACCP

		#define lt_NAV_SPC     &lt   _l_NAV SPC
		#define lt_NAV_SPC_cw  &ht_cw_l_NAV_SPC 0 0


	 // -------------------
	 // BASE LAYER
	 // -------------------

	 // UTIL layer on hold
		#define UTLAYR  &ltt_l_UTIL 0

		base_layer {
			bindings = <
				&kp    Q_   &kp  MIN_   &kp  Y_   DOT_COLN       NBSP_QMRK             &kp K_       &kp  C_   &kp  H_   &kp  W_   &kp  J_
				UTLAYR U_   HMLA O_     HMLC I_   HMLS A_        &kp F_                &kp G_       HMRS T_   HMRC R_   HMRA S_   &kp  N_
				HMLG   Z_   HMRA EACT_  &kp  P_   COMM_SCLN      &kp X_                &kp V_       &kp  D_   &kp  M_   HMLA L_   HMRG B_
				//
													   lt_NUM_E    lsl_SYM            lsl_ACNT   lt_NAV_SPC
			>;
		};

		caps_layer { // TODO leave layer when using home row mods
			bindings = <
				&kp  LS(Q_)   &kp  MIN_       &kp  LS(Y_)   &kp  DOT_         EXCL_QMRK           &kp LS(K_)       &kp  LS(C_)   &kp  LS(H_)   &kp  LS(W_)   &kp  LS(J_)
				HMLG LS(U_)   HMLA LS(O_)	  HMLC LS(I_)   HMLS LS(A_)       &kp LS(F_)          &kp LS(G_)       HMRS LS(T_)   HMRC LS(R_)   HMRA LS(S_)   HMRG LS(N_)
				&kp  LS(Z_)   HMRA LS(EACT_)  &kp  LS(P_)   &kp  COMM_        &kp LS(X_)          &kp LS(V_)       &kp  LS(D_)   &kp  LS(M_)   HMLA LS(L_)   &kp  LS(B_)
				//
														        lt_NUM_E_cw   lsl_SYM_cw          lsl_ACCP   lt_NAV_SPC_cw
														     //  --- both leave CAPS ---     doesn't leave   leaves
			>;
		};
		
		// just doesn't do the QU combo
		oneshotcaps {
			bindings = <
				&trans &trans &trans &trans &trans   &trans         &trans   &trans &trans &trans &trans
				&trans &trans &trans &trans &trans   &trans         &trans   &trans &trans &trans &trans
				&trans &trans &trans &trans &trans   &trans         &trans   &trans &trans &trans &trans
								            &trans   &trans         &trans   &trans
			>;
		};


	 // -------------------
	 // LH AUX LAYERS
	 // -------------------

	 // mod on hold, loose accent on tap
		#define HMRS_CFX__   &ht_CFX   LSHIFT  0
		#define HMRC_GRV__   &ht_GRV   LCTRL   0
	 // #define HMRA_xxx__   &ht_xxx   LALT    0
		#define HMRG_TLD__   &ht_TLD   LGUI    0

		num_layer {
			bindings = <
				&kp  PIPE_    &kp N7_      &kp N8_     &kp N9_        EXCL_QMRK         DLLR_EURO        &kp  LBRK_   &kp  RBRK_   &kp  HASH_   &kp  PCNT_
				&kp  N0_      &kp N1_      &kp N2_     &kp N3_        &kp SCLN_         &kp COLN_        HMRS PLUS_   HMRC MIN_    HMLA STAR_   HMRG FSLA_
				HMLC ULIN_    &kp N4_      &kp N5_     &kp N6_        &kp COMM_         &kp DOT_         &kp  LT_     &kp  GT_     EQUL_DIFF    &kp  BSLA_
				//
				                                        impossible   impossible         &kp ULIN_   &kp SPC
			>;
		};


		sym_layer {
			bindings = <
				&kp  PIPE_   &kp  AT_     &kp  AE_    &kp  OE_        NBSP_EXCL           _________       &kp  LBRK_   &kp  RBRK_   &kp  AMPR_  DLLR_EURO
				HMLG LCUR_   HMLA RCUR_   HMLC LPAR_  HMLS RPAR_      &kp  SCLN_          &kp  COLN_      HMRS_CFX__   HMRC_GRV__   &kp  RALT   HMRG_TLD__
				&kp  NDSH_   HMRA MDSH_   NBSP_LGLM   NBSP_RGLM       &kp  COMM_          &kp  DOT_       _________    _________    &kp  LALT   &kp  BSLA_
				//u
								                            _________   &kp ESC           &kp NBSP_   &kp  SPC
													                // double tap //
			>;
		};


		utility_layer {
			bindings = <
				impossible   &trans       &m_utl_BACK   &m_utl_FRWD      &m_utl_LAF4         &trans     &trans  &trans  &trans  &trans
				impossible   &m_utl_GTAB  &m_utl_SATAB  &m_utl_ATAB      &m_utl_REDO         &trans     &trans  &trans  &trans  &trans
				impossible   &trans       &m_utl_SCTAB  &m_utl_CTAB      &m_utl_UNDO         &trans     &trans  &trans  &trans  &trans
				//
			                                               &m_utl_STAB   &m_utl_ULIN         _____   &kp SPC
			>;
		};



	 // -------------------
	 // RH AUX LAYERS
	 // -------------------

		#define HMLS_CPWD    &httog  LSHIFT  _l_CAPS
		
		#define TASKMAN      &kp LC(LS(ESC))    // ctrl shift esc
		#define PASTEPLAIN   &kp LC(LG(LA(V_))) // plaintext paste (power toys)

		nav_layer {
			bindings = <
				_________    _________    _________     &kp  LG(V_)      TASKMAN            _________        HMLS LC(HOME)   HMLC PG_DN   HMLA PG_UP   HMRG LC(END)
				&kp  LC(Y_)  HMLA INSERT  HMLC PSCRN    HMLS_CPWD        &kp CAPS           _________        &kp  LC(LEFT)   &kp  DOWN    &kp  UP	    &kp  LC(RIGHT)
				HMLG LC(Z_)  HMRA LC(X_)  &kp  LC(C_)   &kp  LC(V_)      PASTEPLAIN         _________        &kp  HOME       &kp  LEFT    &kp  RIGHT   &kp  END
				//
												             &kp PSBRK   _________          impossible   impossible
			>;
		};
		
		// doesn't have cpwd toggle since it will be deactivated upon exiting the layer
		navcaps_layer {
			bindings = <
				&trans &trans &trans &trans &trans      &trans         &trans   &trans &trans &trans &trans
				&trans &trans &trans &trans &kp LSHIFT  &trans         &trans   &trans &trans &trans &trans
				&trans &trans &trans &trans &trans      &trans         &trans   &trans &trans &trans &trans
								            &trans      &trans         &trans   &trans
			>;
		};

	 // questionable syntactic sugar to define several parameters beginning with &m_
		#define MACRO_ROW_3(PREFIX, ONE, TWO, THREE)               &m_##PREFIX##ONE &m_##PREFIX##TWO &m_##PREFIX##THREE
		#define MACRO_ROW_4(PREFIX, ONE, TWO, THREE, FOUR)         MACRO_ROW_3(PREFIX, ONE, TWO, THREE) &m_##PREFIX##FOUR
		#define MACRO_ROW_5(PREFIX, ONE, TWO, THREE, FOUR, FIVE)   MACRO_ROW_4(PREFIX, ONE, TWO, THREE, FOUR) &m_##PREFIX##FIVE

		accent_layer {
			bindings = <
 MACRO_ROW_4(,    CFLX_U_,   CFLX_O_,   CFLX_I_,   CFLX_A_ )     IEXCL_IQMRK          _________     &kp  CCED_  &kp  APST_  &kp  QUOT_   &m_B_J_
 MACRO_ROW_5(,    ACUT_U_,   ACUT_O_,   ACUT_I_,   ACUT_A_,      TILD_A_ )            _________     HMRS CFLX_  HMRC GRAV_  HMLA ACUT_   &m_TILD_N_
 MACRO_ROW_3(,    GRAV_U_,   TILD_O_,   TRMA_I_ )  &kp AGRV_     _________            _________     &kp  TRMA_  _________     &m_SZTT   &kp TILD_
				//
												       &m_CFLX_E_   &kp EGRV_         _________   _________
													                               // double tap //
			>;
		};

		accent_caps_layer {
			bindings = <
 MACRO_ROW_4(cw_, CFLX_U_,   CFLX_O_,   CFLX_I_,   CFLX_A_ )      _________         _________     &kp LS(CCED_)  &kp  APST_  &kp   QUOT_  &m_cw_B_J_
 MACRO_ROW_5(cw_, ACUT_U_,   ACUT_O_,   ACUT_I_,   ACUT_A_,       TILD_A_ )         _________     HMRS   ACUT_   HMRC CFLX_  HMLA  GRAV_  &m_cw_TILD_N_
 MACRO_ROW_3(cw_, GRAV_U_,   TILD_O_,   TRMA_I_)   &kp LS(AGRV_)  _________         _________     &kp    TRMA_   _________   &m_cw_SZTT   &kp   TILD_
				//
											      &m_cw_CFLX_E_   &kp LS(EGRV_)     _________   _________
													                             // double tap //
			>;
		};



	 // -------------------
	 // FUNCTION LAYER
	 // -------------------

		func_layer {
			bindings = <
				&bt  BT_SEL 3   &bt  BT_SEL 0   &bt  BT_SEL 1   &bt  BT_SEL 2      &bt BT_CLR         &sys_reset     &kp F7  &kp F8  &kp F9  &kp F12
				HMLG C_BRI_UP   HMLA C_NEXT     HMLC C_VOL_UP   HMLS C_PP  	       &kp LSLCK          &out OUT_BLE   &kp F1  &kp F2  &kp F3  &kp F10
				&kp  C_BRI_DN   &kp  C_PREV     &kp  C_VOL_DN   &kp  C_MUTE        &kp LNLCK          &out OUT_USB   &kp F4  &kp F5  &kp F6  &kp F11
				//
															          impossible   impossible         &kp LSHIFT   &kp LALT
			>;
		};



	 // -------------------
	 // GAMING LAYERS
	 // -------------------

		game_layer {
			bindings = <
				&kp Q_    &kp MIN_   &kp Y_   &kp DOT_       &kp R_            &kp   K_          &kp C_     &kp H_     &kp W_     &kp J_
				&kp U_    &kp O_     &kp I_   &kp A_         &kp F_            &kp   G_          &kp LEFT   &kp UP     &kp RIGHT  &kp N_
				&kp ESC   &kp S_     &kp P_   &kp COMM_      &kp X_            &tog _l_GAME      &kp D_     &kp DOWN   &kp L_     &kp B_
				//
											     &kp ENTER   &kp SPACE         &kp TAB   &kp LALT
			>;
		};

		game_layer_2 {
			bindings = <
				&kp LSHIFT   &kp A_      &kp EACT_   &kp I_      &kp O_                  &kp Y_     &kp U_   &kp I_      &kp O_     &kp P_
				&kp LCTRL    &kp B_      &kp U_      &kp P_      &kp E_                  &kp H_     &kp J_   &kp K_      &kp L_     &kp N_
				&kp ESC      &kp AGRV_   &kp Y_      &kp X_      &kp DOT           &tog _l_GAM2     &kp M_   &kp COMM_   &kp DOT_   &kp BSPC
				//
												     &kp ENTER   &kp SPACE         &kp TAB   &kp LALT
			>;
		};



	 // -------------------
	 // DEBUGGING LAYER
	 // -------------------
	 /*
	 	bindings = <
	 		_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
	 		_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
	 		_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
	 	                   _____   _____         _____   _____
	 	>;
	 */
	};
};