#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/outputs.h>

#include "bepo_bindings.h"

// SETTINGS
#define _MACRO_INTERVAL      3    // tested: 3+. how long to wait between key presses
#define _MACRO_TAP_FOR       3    // tested: 3+. how long to tap for in macros

// combo: maximum interval between keys to form combo
#define _COMBO_TIMEOUT       18   // tested: 16
#define _COMBO_TIMEOUT_SLOW  50   // tested: 16

// holdtap: how long must hold to not be tap
#define _TAP_TERM_SLOWEST    1200 // for dangerous xcv-all
#define _TAP_TERM_SLOW       300
#define _TAP_TERM            250  //tested: 250
#define _TAP_TERM_FAST       200
#define _TAP_TERM_FASTER     120
						    
// holdtap: how fast must press twice for second to start repeating tap
#define _QUICK_TAP           200
						    
#define _STICKY_TIMEOUT      2000 // tested: 1000+

// LAYERS
#define _L_BASE 0 
#define _L_CPWD 1 
#define _L_NUM  2 
#define _L_SYM  3 
#define _L_NAV  4 
#define _L_ACNT 5 
#define _L_ACCW 6 
#define _L_UTIL 7 
#define _L_FUNC 8 
#define _L_GAME 9 
#define _L_GAM2 10

// combos shouldn't work on game layer, to minimize delay
#define _L_ALL_LAYERS   _L_BASE  _L_CPWD  _L_UTIL  _L_SYM  _L_ACNT  _L_ACCW  _L_NUM  _L_NAV  _L_FUNC  _L_GAME  _L_GAM2
#define _L_NOT_GAME     _L_BASE  _L_CPWD  _L_UTIL  _L_SYM  _L_ACNT  _L_ACCW  _L_NUM  _L_NAV  _L_FUNC
#define _L_NOT_CPWD     _L_BASE          _L_UTIL  _L_SYM  _L_ACNT  _L_ACCW  _L_NUM  _L_NAV  _L_FUNC


&lt { // tap for kp, hold for layer
	tapping-term-ms = <_TAP_TERM>;
	flavor = "balanced";
	quick-tap-ms = <_QUICK_TAP>;
};

&mt { // hold-tap
	tapping-term-ms = <_TAP_TERM_FASTER>;
	quick-tap-ms = <_QUICK_TAP>;
};

&sk { // one-shot layer
	release-after-ms = <_STICKY_TIMEOUT>;
	quick-release;
};

/ {
	behaviors {
		#define _POSITIONS_LH   0 1 2 3 4 10 11 12 13 14 20 21 22 23 24 30 31
		#define _POSITIONS_RH   5 6 7 8 9 15 16 17 18 19 25 26 27 28 29 32 33
		#define _ALL_POSITIONS  _POSITIONS_LH  _POSITIONS_RH
		// #define _ALL_POSITIONS 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33
		
		#define DEFINE_HOLDTAP(NAME, FLAVOR, DELAY, POSITIONS, BINDINGS...) \
			NAME: ht_##NAME { \
				label = #NAME; \
				flavor = #FLAVOR; \
				tapping-term-ms = <DELAY>; \
				quick-tap-ms = <_QUICK_TAP>; \
				bindings = BINDINGS; \
				hold-trigger-key-positions = <POSITIONS>; \
				#binding-cells = <2>; \
				compatible = "zmk,behavior-hold-tap"; \
			};

		#define HT(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM, _ALL_POSITIONS, BINDINGS)

		#define HT_FAST(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM_FAST, _ALL_POSITIONS, BINDINGS)

		#define HT_BAL(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, balanced, _TAP_TERM, _ALL_POSITIONS, BINDINGS)

		#define HRMOD_POS(NAME, POSITIONS) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM, POSITIONS, <&kp>, <&kp>)

		#define HT_SLOW(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM_SLOW, _ALL_POSITIONS, BINDINGS)
			
		#define SECURITY_HOLD(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM_SLOWEST, _ALL_POSITIONS, BINDINGS)

		// HOME-ROW MODS              // TAP           HOLD
		HT(     ht,     <&kp>, <&kp>) // &kp             &kp
		HT(     htsk,   <&sk>, <&kp>) // &kp             sticky layer
		HT(     ltt,    <&mo>, <&kp>) // &kp             hold layer    (inherits tap-preferred from HT)
		HT_BAL( lsk,    <&mo>, <&sk>) // one-shot mod    hold layer
		HT_BAL( lsl,    <&mo>, <&sl>) // one-shot layer  hold layer
		
		HT_SLOW(htslow, <&kp>, <&kp>) // !! UNUSED !! (same timeout as default)
		
		// hrm for opposite hand only (used for shift)
		HRMOD_POS(htl, _POSITIONS_RH)
		HRMOD_POS(htr, _POSITIONS_LH)
		
		// OTHER HOLDTAPS ------------------
		// gotta hold these for a long time just to make sure
		SECURITY_HOLD(sechold_cutall,   <&m_cut_all>,   <&kp>)
		SECURITY_HOLD(sechold_copyall,  <&m_copy_all>,  <&kp>)
		SECURITY_HOLD(sechold_pasteall, <&m_paste_all>, <&kp>)
		
		//deactivates capsword, then...                               // PRESS           HOLD
		HT_BAL( ht_cw_L_NAV_spc, <&m_mo_cw_L_NAV>,  <&m_cw_spc>)      // space           hold _L_NAV
		HT_BAL(lsl_cw_L_SYM,     <&m_mo_cw_L_SYM>,  <&m_sk_cw_L_SYM>) // one-shot _L_SYM  hold _L_SYM
		
		HT_SLOW(ltt_L_UTIL, <&m_mo_L_UTIL>, <&kp>) // &kp             hold layer    (inherits tap-preferred from HT)

		// NBSP STUFF (for french) ------------------
		// automatic nbsp on tap
		HT(ht_lglm, <&kp>, <&m_nbsp_lglm>)
		HT(ht_rglm, <&kp>, <&m_nbsp_rglm>)

		// automatic nbsp on hold
		HT_FAST(ht_coln, <&m_nbsp_coln>, <&kp>)
		HT_FAST(ht_scln, <&m_nbsp_scln>, <&kp>)
		HT_FAST(ht_qmrk, <&m_nbsp_qmrk>, <&kp>)
		HT_FAST(ht_excl, <&m_nbsp_excl>, <&kp>)
	};

	macros {
		// convenience	
		#define _ALL_MODS    &kp LSHFT &kp LALT &kp LCTRL // notepad++ bugs if ctrl is not last
		
		#define M_TAP       &macro_tap
		#define M_TAP_KP    &macro_tap &kp
		#define M_HOLD      &macro_press
		#define M_HOLD_KP   &macro_press &kp
		#define M_REL       &macro_release
		#define M_REL_KP    &macro_release &kp
		#define M_WAIT_REL <&macro_pause_for_release>
		
		#define M_HOLD_SHIFT <M_HOLD_KP LSHFT>
		#define M_REL_SHIFT  <M_REL_KP LSHFT>, <M_REL_KP RSHFT>
		
		// BASE MACRO -----------------------------
		// all macro names will be prefixed by m_
		#define MACRO(NAME, BINDINGS...) \
			ZMK_MACRO(m_##NAME, \
				tap-ms   = <_MACRO_TAP_FOR>; \
				wait-ms  = <_MACRO_INTERVAL>; \
				bindings = BINDINGS; \
				)

		// MACRO_TAP -----------------------------
		// tap whatever command sequence is given
		#define MACRO_TAP(NAME, BINDINGS...) \
			MACRO(NAME, <M_TAP BINDINGS>)
			
		
		// MACRO_DIGRAM -----------------------------
		// tap a key, release shift if held, tap another (so can eg hold shift and do &m_Q_U_ to get Qu
		// also defines a capsword version
		#define MACRO_DIGRAM(FIRST, SECOND) \
			MACRO(FIRST##SECOND,                      <M_TAP_KP FIRST>, M_REL_SHIFT, <M_TAP_KP SECOND>) \
			\
			MACRO(cw_##FIRST##SECOND,  M_HOLD_SHIFT,  <M_TAP_KP FIRST>,              <M_TAP_KP SECOND>,  M_REL_SHIFT)
			
					
					
		// TODO -----------------------------
		// this was meant for the eszett, but if it doesn't work i might as well merge it with ACCENT_1.
		#define MACRO_ACCENT_NAMED(NAME, ACCENT, LETTER) \
			MACRO(NAME,      <M_TAP_KP ACCENT>, M_REL_SHIFT,  <M_TAP_KP LETTER>) \
			\
			MACRO(cw_##NAME, <M_TAP_KP ACCENT>, M_HOLD_SHIFT, <M_TAP_KP LETTER>, M_REL_SHIFT)
				
				
		#define MACRO_ACCENT_1(ACCENT, LETTER) \
			MACRO_ACCENT_NAMED(ACCENT##LETTER, ACCENT, LETTER)
			
				
		#define MACRO_ACCENT_2(ACCENT, FIRST, SECOND) \
			MACRO(ACCENT##FIRST##SECOND,      <M_TAP_KP ACCENT>,               <M_TAP_KP FIRST>, M_REL_SHIFT, <M_TAP_KP SECOND>) \
			\
			MACRO(cw_##ACCENT##FIRST##SECOND, <M_TAP_KP ACCENT>, M_HOLD_SHIFT, <M_TAP_KP FIRST>,              <M_TAP_KP SECOND>,  M_REL_SHIFT)
				

		// !! TODO !!
		// MACRO_ACCENT_NAMED(sztt,     SZTTMOD_,   S_)
		/*  ß  */  MACRO_TAP(sztt,       &kp RA(S_)  &kp    S_)
		/*  ẞ  */  MACRO_TAP(cw_sztt,    &kp RA(S_)  &kp LS(S_))
		
		
		// INCONVENIENT DIGRAMS ------------------
		// also defines a caps version (eg &m_cw_Q_U_)
		MACRO_DIGRAM(Q_, U_)
		MACRO_DIGRAM(B_, J_)
		
		
		// ACCENTED LETTERS ------------------
		// also defines a caps version (eg &m_cw_ACUT_A_)
		MACRO_ACCENT_1(ACUT_, A_)
		MACRO_ACCENT_1(ACUT_, I_)
		MACRO_ACCENT_1(ACUT_, O_)
		MACRO_ACCENT_1(ACUT_, U_)
		
		MACRO_ACCENT_1(CFLX_, A_)
		MACRO_ACCENT_1(CFLX_, E_)
		MACRO_ACCENT_1(CFLX_, I_)
		MACRO_ACCENT_1(CFLX_, O_)
		MACRO_ACCENT_1(CFLX_, U_)
		
		MACRO_ACCENT_1(GRAV_, E_)
		MACRO_ACCENT_1(GRAV_, O_)
		MACRO_ACCENT_1(GRAV_, U_)
		
		MACRO_ACCENT_1(TILD_, A_)
		MACRO_ACCENT_1(TILD_, O_)
		MACRO_ACCENT_1(TILD_, N_)				
		MACRO_ACCENT_2(TILD_, A_, E_)
		MACRO_ACCENT_2(TILD_, A_, O_)
		MACRO_ACCENT_2(TILD_, O_, E_)
		
		MACRO_ACCENT_1(TRMA_, I_)


		// NBSP STUFF (for french) ------------------
		/* ■?  */  MACRO_TAP(nbsp_qmrk,  &kp NBSP_  &kp QMRK_)
		/* ■!  */  MACRO_TAP(nbsp_excl,  &kp NBSP_  &kp EXCL_)
		/* ■:□ */  MACRO_TAP(nbsp_coln,  &kp NBSP_  &kp COLN_  &kp SPACE)
		/* ■;□ */  MACRO_TAP(nbsp_scln,  &kp NBSP_  &kp SCLN_  &kp SPACE)
		/* ■»□ */  MACRO_TAP(nbsp_rglm,  &kp NBSP_  &kp RGLM_)
		/* □«■ */  MACRO_TAP(nbsp_lglm,  &kp LGLM_  &kp NBSP_)
			   
			   
		// LOOSE ACCENTS ------------------
		/*  ^  */  MACRO_TAP(cfxloos,    &kp CFLX_  &kp SPACE)
		/*  `  */  MACRO_TAP(grvloos,    &kp GRAV_  &kp SPACE)


		// CAPSWORD ------------------
		// key and turn off capsword
		MACRO_TAP(cw_spc,  &kp SPACE  &tog _L_CPWD)
		MACRO_TAP(cw_tab,  &kp TAB    &tog _L_CPWD)
		MACRO_TAP(cw_entr, &kp ENTER  &tog _L_CPWD)
		MACRO_TAP(cw_esc,  &kp ESC    &tog _L_CPWD)
		
		// hold layer and turn off caps word
		MACRO(mo_cw_L_NAV,   <M_TAP &to _L_NAV>,   M_WAIT_REL,  <M_TAP &to _L_BASE>)
		MACRO(mo_cw_L_SYM,   <M_TAP &to _L_SYM>,   M_WAIT_REL,  <M_TAP &to _L_BASE>)
		MACRO(mo_cw_L_ACNT,  <M_TAP &to _L_ACNT>,  M_WAIT_REL,  <M_TAP &to _L_BASE>)
		
		// one-shot layer and turn off caps word
		MACRO(sk_cw_L_SYM,   <M_TAP &to _L_BASE  &sk _L_SYM>)
		MACRO(sk_cw_L_ACNT,  <M_TAP &to _L_BASE  &sk _L_ACNT>)
		
		
		// SECURITY_HOLD ------------------
		MACRO(cut_all,    <M_TAP_KP  LC(A_)>,  M_WAIT_REL,  <M_TAP_KP  LC(X_)>)
		MACRO(copy_all,   <M_TAP_KP  LC(A_)>,  M_WAIT_REL,  <M_TAP_KP  LC(C_)>)
		MACRO(paste_all,  <M_TAP_KP  LC(A_)>,  M_WAIT_REL,  <M_TAP_KP  LC(V_)>)
		
		
		// UTIL LAYER ------------------
		// TODO doesn't quite work yet
		MACRO(mo_L_UTIL, <M_TAP  &to _L_UTIL>,  <M_HOLD  _ALL_MODS>,  M_WAIT_REL,  <M_TAP  &to _L_BASE>,  <M_REL  _ALL_MODS>)
								  
		MACRO(utl_ctab,  <M_REL  &kp LSHFT             &kp LALT>,   <M_TAP_KP  TAB>,       <M_HOLD  _ALL_MODS>)
		MACRO(utl_cstab, <M_REL                        &kp LALT>,   <M_TAP_KP  TAB>,       <M_HOLD  _ALL_MODS>)
		MACRO(utl_atab,  <M_REL  &kp LSHFT  &kp LCTRL          >,   <M_TAP_KP  TAB>,       <M_HOLD  _ALL_MODS>)
		MACRO(utl_astab, <M_REL             &kp LCTRL          >,   <M_TAP_KP  TAB>,       <M_HOLD  _ALL_MODS>)
		MACRO(utl_gtab,  <M_REL  _ALL_MODS>,                        <M_TAP_KP  LG(TAB)>,   <M_HOLD  _ALL_MODS>)
		
	};

	combos {
		compatible = "zmk,combos";

		#define DEFINE_COMBO(NAME, LAYERS, POSITIONS, TIMEOUT, BINDINGS...) \
			combo_##NAME { \
				layers = <LAYERS>; \
				key-positions = <POSITIONS>; \
				timeout-ms = <TIMEOUT>; \
				bindings = BINDINGS; \
			};
			

		// when not defining layers, will default to _L_NOT_GAME
		// !! TODO !!: ok to omit line breaks between defs?
		// !! TODO !!: all combos define layers?
		#define COMBO(LAYERS, BINDINGS, POSITIONS, RANDOM_NAME) \
			DEFINE_COMBO(RANDOM_NAME,        LAYERS,   POSITIONS,  _COMBO_TIMEOUT,      <BINDINGS>)

		#define COMBO_KP(LAYERS, KEY, SUFFIX, POSITIONS) \
			DEFINE_COMBO(KEY##SUFFIX,        LAYERS,  POSITIONS,  _COMBO_TIMEOUT,       <&kp KEY>)
			
		#define COMBO_KP_CTRL(LAYERS, KEY, SUFFIX, POSITIONS) \
			DEFINE_COMBO(ctrl_##KEY##SUFFIX, LAYERS,  POSITIONS,  _COMBO_TIMEOUT,       <&sk LCTRL>, <&kp KEY>)

		#define COMBO_MACRO(LAYERS, MACRO, SUFFIX, POSITIONS) \
			DEFINE_COMBO(MACRO##SUFFIX,      LAYERS,  POSITIONS,  _COMBO_TIMEOUT,       <&m_##MACRO>)

		// SECURITY HOLD - for dangerous macros (xcv all)
		#define COMBO_MACRO_LAYER_SLOW(LAYERS, MACRO, SUFFIX, POSITIONS) \
			DEFINE_COMBO(MACRO##SUFFIX,      LAYERS,  POSITIONS,  _COMBO_TIMEOUT_SLOW,  <&m_##MACRO>)


	/*
	    0   1   2   3      4 | 5      6   7   8   9
	    10  11  12  13    14 | 15    16  17  18  19
	    20  21  22  23    24 | 25    26  27  28  29
							 |
	                   30 31 | 32 33
	*/

		COMBO_KP(_L_NOT_GAME,  SPACE,l,                   11 12 13)
		COMBO_KP(_L_NOT_GAME,  SPACE,r,                   16 17 18)

		// backspace and del, with and wo ctrl
		COMBO_KP(     _L_NOT_GAME,  BSPC,a,                11 12)
		COMBO_KP_CTRL(_L_NOT_GAME,  BSPC,u,                17 18)
		COMBO_KP(     _L_NOT_GAME,  DEL,aa,                 21 22)
		COMBO_KP_CTRL(_L_NOT_GAME,  DEL,uu,                 27 28)		
		COMBO_KP_CTRL(_L_NOT_GAME,  Z_,aaa,                  20 21)

		// one-shot shift on both thumb keys at once
		COMBO(_L_NOT_GAME,  &lsk _L_FUNC LSHIFT,          30 31, dljsdiqsrt)
		COMBO(_L_NOT_GAME,  &sk          RSHIFT,          32 33, sqljqrjqsl)
										   
		// !! TODO !!  merge these?         
		COMBO_MACRO(_L_BASE,  Q_U_,,            26 27) /* qu */  
		COMBO_MACRO(_L_BASE,  TILD_A_E_,,       13 30) /* ãe */  
		COMBO_MACRO(_L_BASE,  TILD_A_O_,,       13 11) /* ão */  
		COMBO_MACRO(_L_BASE,  TILD_O_E_,,       11 30) /* õe */  
					                              		
		COMBO_MACRO(_L_CPWD,  cw_Q_U_,,         26 27) /* QU */  
		COMBO_MACRO(_L_CPWD,  cw_TILD_A_E_,,    13 30) /* ÃE */  
		COMBO_MACRO(_L_CPWD,  cw_TILD_A_O_,,    13 11) /* ÃO */  
		COMBO_MACRO(_L_CPWD,  cw_TILD_O_E_,,    11 30) /* ÕE */  
								      
		// tab, enter, esc            
		COMBO_KP(_L_NOT_CPWD,  TAB,,                12 13)
		COMBO_KP(_L_NOT_CPWD,  ENTER,,              16 17)
		COMBO_KP(_L_NOT_CPWD,  ESC,,                10 11)
		
		COMBO_MACRO(_L_CPWD,  cw_tab,,          12 13)
		COMBO_MACRO(_L_CPWD,  cw_entr,,         16 17)
		COMBO_MACRO(_L_CPWD,  cw_esc,,          10 11)
		
		COMBO(_L_FUNC, &sys_reset,     0  4, aiouaiouaiou)
		COMBO(_L_FUNC, &bootloader,   20 24, ayuqaioueaio)
		COMBO(_L_FUNC, &tog _L_GAME,   4 14, aiouayopaipo)
		COMBO(_L_FUNC, &tog _L_GAM2,  14 24, aiopoappyaio)
	};

	keymap {
		compatible = "zmk,keymap";

        // READABILITY ------------------
		// #define _____      &trans   // unused
		// #define _________  &trans   //
		#define xxxxx      &none
		#define xxxxxxxxx  &none
		#define __to_do__  &none
		#define _todo_     &none
		#define xINACSBLx  &none
		
		#define C_S_DEL      &kp LC(LS(ESC))    // task manager
		#define PASTEPLAIN   &kp LC(LG(LA(V_))) // power toys plaintext paste
		#define RESET_LEFT   &sys_reset   	    // mnemonic (bc when called on the right it resets both)


		// HOME-ROW MODS ------------------
		#define HMLS    &htl     LSHIFT // left shift only works for keys on right hand
		#define HMRS    &htr     RSHIFT // rite shift only works for keys on lefft hand
		#define HMLC    &ht      LCTRL
		#define HMRC    &ht      RCTRL
		#define HMLA    &ht      LALT
		#define HMRA    &ht      RALT
		#define HMLG    &htslow  LGUI // i kept holding GUI by accident,
		#define HMRG    &htslow  RGUI // so i made it slower
		
		
		 // STICKY MODS IN NAV LAYER ------------------
		#define SKLS    &htsk   LSHIFT
		#define SKLC    &htsk   LCTRL
		#define SKLA    &htsk   LALT
		#define SKLG    &htsk   LGUI


		// HOLDTAP SYMBOLS ------------------                                     
		// □ = space, ■ = nbsp, () = explicited later   // HOLD  TAP    
		#define DLLR_EURO   &htslow    EURO_  DLLR_     //  €     $     
		#define EQUL_DIFF   &htslow    DIFF_  EQUL_     //  ≠     =     
		#define IEXCL_IQMRK &htslow    IEXC_  IQMR_     //  ¿     ¡ 
											 		        
		#define NBSP_QMRK   &ht_qmrk   0      QMRK_     // ■?    (?)   
		#define NBSP_EXCL   &ht_excl   0      EXCL_     // ■!    (!)   
		#define DOT_COLN    &ht_coln   0      DOT_      // ■:□   (.)    
		#define COMM_SCLN   &ht_scln   0      COMM_     // ■;□   (,)    
									  	      	           
		#define NBSP_LGLM   &ht_lglm   LGLM_  0         // («)   «■     
		#define NBSP_RGLM   &ht_rglm   RGLM_  0         // (»)    ■»    


		// DANGEROUS STUFF! must hold for very long time
		#define CUT_ALL     &sechold_cutall   0 &none   // &none   cut all    
		#define COPY_ALL    &sechold_copyall  0 &none   // &none   copy all
		#define PASTE_ALL   &sechold_pasteall 0 &none   // &none   paste all
		
		// UTIL LAYER ------------------
		#define UTLAYR &ltt_L_UTIL 0
										
		// #define HT_CTRV      &ht PASTEPLAIN  LC(V_)  // ^V      plaintext paste (powertoys)



		// THUMB KEYS ------------------
		#define LT_NUM_E      &lt  _L_NUM  E_
		#define LT_NUM_E_CW   &lt  _L_NUM  LS(E_)
		
		#define LSL_SYM      &lsl   _L_SYM  _L_SYM
		#define LSL_SYM_CW   &lsl_cw_L_SYM 0 0
		
		#define LT_NAV_SPC      &lt   _L_NAV SPC
		#define LT_NAV_SPC_CW   &ht_cw_L_NAV_spc 0 0
		
		#define LSL_ACNT     &lsl   _L_ACNT  _L_ACNT
		#define LSL_ACCW     &lsl   _L_ACCW  _L_ACCW


                                      // ---- left hand ---- //      // ---- right hand ---- //
		#define _THUMBS_LEFT_         LT_NUM_E       LSL_SYM
		#define _THUMBS_RIGHT_                                        LSL_ACNT    LT_NAV_SPC		
		#define _THUMBS_CAPSWORD_     LT_NUM_E_CW    LSL_SYM_CW       LSL_ACCW    LT_NAV_SPC_CW
		
		#define _THUMBS_DEFAULT_           _THUMBS_LEFT_                  _THUMBS_RIGHT_
	


		// -------------------
		// BASE LAYER
		// -------------------UTLAYR U_
		
		base_layer {
			bindings = <
				&kp    Q_  HMRA  MIN_   &kp  Y_  DOT_COLN   NBSP_QMRK         &kp K_   &kp  C_   &kp  H_   &kp  W_   &kp  J_
				&kp    U_  HMLA  O_     HMLC I_  HMLS A_    &kp F_            &kp G_   HMRS T_   HMRC R_   HMRA S_   &kp  N_
				HMLG   Z_  HMLC  EACT_  &kp  P_  COMM_SCLN  &kp X_            &kp V_   &kp  D_   &kp  M_   &kp  L_   HMRG B_
				//
															       _THUMBS_DEFAULT_
			>;
		};

		caps_word_layer { // !! TODO !! cancel shift when using caps word mods
			bindings = <
				&kp  LS(Q_)	 HMRA  MIN_       &kp  LS(Y_)  DOT_COLN       NBSP_QMRK          &kp LS(K_)    &kp  LS(C_)  &kp  LS(H_)  &kp  LS(W_)  &kp  LS(J_)
				HMLG LS(U_)	 HMLA  LS(O_)	  HMLC LS(I_)  HMLS LS(A_)    &kp LS(F_)         &kp LS(G_)    HMRS LS(T_)  HMRC LS(R_)  HMRA LS(S_)  HMRG LS(N_)
				&kp  LS(Z_)	 HMLC  LS(EACT_)  &kp  LS(P_)  COMM_SCLN      &kp LS(X_)         &kp LS(V_)    &kp  LS(D_)  &kp  LS(M_)  &kp  LS(L_)  &kp  LS(B_)
				//
														                     _THUMBS_CAPSWORD_
			>;
		};
		
		
		// -------------------
		// LH AUX LAYERS
		// -------------------

		num_layer {
			bindings = <
				&kp PIPE_  &kp N7_  &kp N8_  &kp N9_    __to_do__         DLLR_EURO    &kp  LBRK_  &kp  RBRK_   &kp  HASH_   &kp  PCNT_
				&kp N0_    &kp N1_  &kp N2_  &kp N3_    &kp DOT_          __to_do__    HMRS PLUS_  HMRC MIN_    HMLA STAR_   HMRG FSLA_
				__to_do__  &kp N4_  &kp N5_  &kp N6_    &kp COMM_         __to_do__    &kp  LT_    &kp  GT_	    EQUL_DIFF    &kp  BSLA_
				//
				                             xINACSBLx  xINACSBLx         &kp ULIN_    &kp SPC
			>;
		};

		sym_layer {
			bindings = <
				&kp AE_		 &kp AT_       &kp AMPR_   &kp OE_       NBSP_EXCL         __to_do__    DLLR_EURO    __to_do__    __to_do__    __to_do__
				SKLG LCRL_	 SKLA RCRL_    SKLC LPAR_  SKLS RPAR_    &kp MDSH_         __to_do__    HMRS _todo_  HMRC _todo_  HMRA _todo_  HMRG PIPE_
				&kp NDSH_	 &kp MDSH_     NBSP_LGLM   NBSP_RGLM     __to_do__         __to_do__    __to_do__    &m_grvloos   &m_cfxloos   __to_do__
				//
								                       &kp ESC       &kp SPC           &kp NBSP_    &kp SPC
													              // double tap
			>;
		};
		
		
		// -------------------
		// RH AUX LAYERS
		// -------------------

		nav_layer {
			bindings = <
				__to_do__    CUT_ALL      COPY_ALL     PASTE_ALL       C_S_DEL            &sk  RALT        HMLS LC(HOME)   HMLC PG_DN   HMLA PG_UP   HMRG LC(END)
				HMLG LC(Y_)  HMLA INSERT  HMLC PSCRN   HMLS PSBRK      &kp CAPS           &tog _L_CPWD     &kp  LC(LEFT)   &kp  DOWN	&kp  UP	     &kp  LC(RIGHT)
				&kp  LC(Z_)  &kp  LC(X_)  &kp  LC(C_)  &kp  LC(V_)     PASTEPLAIN         __to_do__        &kp  HOME       &kp  LEFT	&kp  RIGHT   &kp  END
				//                                                                                      
												     &kp  LA(TAB)    &kp LC(TAB)          xINACSBLx        xINACSBLx
			>;
		};

		accent_layer {
			bindings = <
				&m_CFLX_U_  &m_CFLX_O_  &m_CFLX_I_  &m_CFLX_A_    IEXCL_IQMRK        __to_do__    &kp  CCED_  &kp  APST_  &kp  QUOT_  &m_B_J_
				&m_ACUT_U_  &m_ACUT_O_  &m_ACUT_I_  &m_ACUT_A_    &m_TILD_A_         __to_do__    HMRS ACUT_  HMRC GRAV_  HMLA CFLX_  &m_TILD_N_
				&m_GRAV_U_  &m_TILD_O_  &m_TRMA_I_  &kp AGRV_     __to_do__          __to_do__    &kp  TRMA_  __to_do__   &m_sztt     &kp TILD_
				//
												    &m_CFLX_E_    &kp EGRV_          __to_do__    __to_do__
													                              // double tap
			>;
		};

		accent_caps_layer {
			bindings = <
				&m_cw_CFLX_U_  &m_cw_CFLX_O_  &m_cw_CFLX_I_  &m_cw_CFLX_A_    __to_do__             __to_do__    &kp  CCED_  &kp  APST_  &kp  QUOT_  &m_cw_B_J_
				&m_cw_ACUT_U_  &m_cw_ACUT_O_  &m_cw_ACUT_I_  &m_cw_ACUT_A_    &m_cw_TILD_A_         __to_do__    HMRS ACUT_  HMRC GRAV_  HMLA CFLX_  &m_cw_TILD_N_
				&m_cw_GRAV_U_  &m_cw_TILD_O_  &m_cw_TRMA_I_  &kp LS(AGRV_)    __to_do__             __to_do__    &kp  TRMA_  __to_do__   &m_cw_sztt  &kp TILD_
				//
												             &m_cw_CFLX_E_    &kp LS(EGRV_)         __to_do__    __to_do__
													                                             // double tap
			>;
		};
		
		
		// -------------------
		// FUNCTION LAYERS
		// -------------------

		utility_layer {
			bindings = <
				xxxxxxxxx   xxxxxxxxx    xxxxxxxxx     xxxxxxxxx      xxxxx             xxxxx    xxxxxxxxx   xxxxxxxxx   xxxxxxxxx   xxxxxxxxx
				xxxxxxxxx   xxxxxxxxx    &m_utl_astab  &m_utl_atab    xxxxx             xxxxx    xxxxxxxxx   xxxxxxxxx   xxxxxxxxx   xxxxxxxxx
				xxxxxxxxx   xxxxxxxxx    &m_utl_cstab  &m_utl_ctab    xxxxx             xxxxx    xxxxxxxxx   xxxxxxxxx   xxxxxxxxx   xxxxxxxxx
				//
			                                           xxxxxxxxx      &m_utl_gtab       xxxxx    xxxxx
			>;
		};
		
		
		

		func_layer {
			bindings = <
				&bt  BT_CLR     &bt  BT_SEL 0   &bt  BT_SEL 1   &bt  BT_SEL 2  &bt BT_SEL 3         RESET_LEFT    &kp F7  &kp F8  &kp F9  &kp F12
				HMLG C_BRI_UP   HMLA C_NEXT     HMLC C_VOL_UP   HMLS C_PP  	   &kp LSLCK            &out OUT_BLE  &kp F1  &kp F2  &kp F3  &kp F10
				&kp  C_BRI_DN   &kp  C_PREV     &kp  C_VOL_DN   &kp  C_MUTE    &kp LNLCK            &out OUT_USB  &kp F4  &kp F5  &kp F6  &kp F11
				//
															    xINACSBLx      xINACSBLx            __to_do__     __to_do__
			>;
		};
		
		
		// -------------------
		// GAMING LAYERS
		// -------------------		

		game_layer {
			bindings = <
				&kp Q_      &kp MIN_   &kp Y_     &kp DOT_     &kp R_            &kp  K_       &kp C_     &kp H_     &kp W_     &kp J_
				&kp U_      &kp O_     &kp I_     &kp A_       &kp F_            &kp  G_       &kp LEFT   &kp UP     &kp RIGHT  &kp N_
				&kp Z_      &kp S_     &kp P_     &kp COMM_    &kp X_            &tog _L_GAME  &kp D_     &kp DOWN   &kp L_     &kp B_
				//
											      &kp ENTER    &kp SPACE         &kp  TAB      &kp LALT
			>;
		};

		game_layer_2 {
			bindings = <
				&kp LSHIFT  &kp A_     &kp EACT_  &kp I_      &kp O_            &kp  Y_       &kp U_     &kp I_     &kp O_     &kp P_
				&kp LCTRL   &kp B_     &kp U_     &kp P_      &kp E_            &kp  H_       &kp J_     &kp K_     &kp L_     &kp N_
				&kp ESC     &kp AGRV_  &kp Y_     &kp X_      &kp DOT           &tog _L_GAM2  &kp M_     &kp COMM_  &kp DOT_   &kp BSPC
				//
												  &kp ENTER   &kp SPACE         &kp  TAB      &kp LALT
			>;
		};
		
		
		// -------------------
		// DEBUGGING LAYER
		// -------------------	

		/* FOR DEBUGGING:
			bindings = <
				xxxxx xxxxx xxxxx xxxxx   xxxxx         xxxxx   xxxxx xxxxx xxxxx xxxxx
				xxxxx xxxxx xxxxx xxxxx   xxxxx         xxxxx   xxxxx xxxxx xxxxx xxxxx
				xxxxx xxxxx xxxxx xxxxx   xxxxx         xxxxx   xxxxx xxxxx xxxxx xxxxx
			                   xxxxx   xxxxx         xxxxx   xxxxx
			>;
		*/
	};
};