#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/outputs.h>

#include "bepo_bindings.h"

/* SETTINGS */
#define MACRO_WAIT 3 /* good 5 */
#define MACRO_TAP_DELAY 3 /* good 5 */

#define COMBO_TIMEOUT 16 /* max 17, 15 maybe too little */

#define MT_TAPPING_TERM 120
#define LT_TAPPING_TERM 250
#define HT_TAPPING_TERM 250
#define HT_QUICK_TAP 200
#define STICKY_KEY_RELEASE_DELAY 2000 /* min 1000 */

/* LAYERS */
#define BASE 0
#define CAPL 1
#define SYM 2
#define ACNT 3
#define NUM 4
#define NAV 5
#define FUNC 6
#define GAME 7

#define NOT_GAME BASE CAPL SYM ACNT NUM NAV FUNC

&lt {
	tapping-term-ms = <LT_TAPPING_TERM>;
	flavor = "balanced";
};

&mt {
	tapping-term-ms = <MT_TAPPING_TERM>;
};

&sk {
	release-after-ms = <STICKY_KEY_RELEASE_DELAY>;
	quick-release;
};

/ { 
	behaviors {
		#define HOLDTAP_HEADER(NAME) \
			NAME: ht_##NAME { \
				label = #NAME; \
				compatible = "zmk,behavior-hold-tap"; \
				#binding-cells = <2>; \
				tapping-term-ms = <HT_TAPPING_TERM>; \
				quick-tap-ms = <HT_QUICK_TAP>;
				
		#define HOLDTAP(NAME, FLAVOR, BINDINGS...) \
				HOLDTAP_HEADER(NAME) \
				flavor = #FLAVOR; \
				bindings = BINDINGS; \
			};
			
		#define HRMOD_POS(NAME, POSITIONS) \
				HOLDTAP_HEADER(NAME) \
				flavor = "tap-preferred"; \
				bindings = <&kp>, <&kp>; \
				hold-trigger-key-positions = <POSITIONS>; \
			};
			
		
		HOLDTAP(hm,  tap-preferred, <&kp>, <&kp>)
		HOLDTAP(lsk, balanced,      <&mo>, <&sk>)        // lsk: layer if held, one-shot kp if pressed
		HOLDTAP(lsl, balanced,      <&mo>, <&sl>)        // lsl: layer if held, one-shot layer if pressed
		
		// the following are for home-row mods
		HOLDTAP(hm_qu, tap-preferred,   <&kp>, <&m_Q_U_>)
		HOLDTAP(hm_quc, tap-preferred,   <&kp>, <&m_shift_qu>)
		HOLDTAP(hm_aact, tap-preferred,   <&kp>, <&m_ACUT_A_>)
		HOLDTAP(hm_uact, tap-preferred,   <&kp>, <&m_ACUT_U_>)
		HOLDTAP(hm_iact, tap-preferred,   <&kp>, <&m_ACUT_I_>)
		
		// these are for « and » with or without automatic nbsp. use with 0 0 arguments.
		HOLDTAP(ht_lglm, tap-preferred,   <&kp>, <&m_nbsp_lglm>)
		HOLDTAP(ht_rglm, tap-preferred,   <&kp>, <&m_nbsp_rglm>)

		
		HRMOD_POS(hml, 5 6 7 8 9 15 16 17 18 19 25 26 27 28 29 32 33)
		HRMOD_POS(hmr, 0 1 2 3 4 10 11 12 13 14 20 21 22 23 24 30 31)
	};

	macros {
		#define MACRO(NAME, BINDINGS...) \
			ZMK_MACRO(m_##NAME, \
				tap-ms = <MACRO_TAP_DELAY>; \
				wait-ms = <MACRO_WAIT>; \
				bindings = BINDINGS; \
				)
				
		// MACRO_SIMPLE will name the macro "m_FIRST##SECOND", eg "mQ_U_".
		// it cannot therefore contain parentheses (i think?) or complex sequences. 
		#define MACRO_SIMPLE(FIRST, SECOND) \
			MACRO(FIRST##SECOND, <&macro_tap &kp FIRST &kp SECOND>)
				
		#define MACRO_SIMPLE_OLD(FIRST, SECOND) \
			ZMK_MACRO(m_##FIRST##SECOND, \
				tap-ms = <MACRO_TAP_DELAY>; \
				wait-ms = <MACRO_WAIT>; \
				bindings = <&macro_tap &kp FIRST &kp SECOND>; \
				)
	
		// define macros like m_ACUT_A_ for accents layer
		MACRO_SIMPLE(ACUT_, A_)
		MACRO_SIMPLE(ACUT_, E_)
		MACRO_SIMPLE(ACUT_, I_)
		MACRO_SIMPLE(ACUT_, O_)
		MACRO_SIMPLE(ACUT_, U_)
		MACRO_SIMPLE(CFLX_, A_)
		MACRO_SIMPLE(CFLX_, E_)
		MACRO_SIMPLE(CFLX_, I_)
		MACRO_SIMPLE(CFLX_, O_)
		MACRO_SIMPLE(CFLX_, U_)
		MACRO_SIMPLE(GRAV_, E_)
		MACRO_SIMPLE(GRAV_, O_)
		MACRO_SIMPLE(GRAV_, U_)
		MACRO_SIMPLE(TILD_, A_)
		MACRO_SIMPLE(TILD_, O_)
		MACRO_SIMPLE(TILD_, N_)
		MACRO_SIMPLE(TRMA_, I_)
		MACRO_SIMPLE(Q_, U_)
		MACRO_SIMPLE(B_, J_)
		MACRO_SIMPLE(F_, U_)
		MACRO_SIMPLE(U_, F_)
		
		MACRO(nbsp_lglm, <&macro_tap &kp LGLM_ 	   &kp LS(SPACE)>)
		MACRO(nbsp_rglm, <&macro_tap &kp LS(SPACE) &kp RGLM_>)
		
		MACRO(nbsp_coln, <&macro_tap &kp LS(SPACE) &kp LS(DOT_)>)
		MACRO(nbsp_scln, <&macro_tap &kp LS(SPACE) &kp LS(COMM_)>)
		
		MACRO(ae,  <&macro_tap &kp TILD_ &kp A_ &kp E_>)
		MACRO(ao,  <&macro_tap &kp TILD_ &kp A_ &kp O_>)
		MACRO(nao, <&macro_tap &kp N_ &kp TILD_ &kp A_ &kp O_>)
		MACRO(oe,  <&macro_tap &kp TILD_ &kp O_ &kp E_>)
		
		MACRO(shift_qu, <&macro_press &kp LSHFT>, <&macro_tap &kp Q_ &kp U_>, <&macro_release &kp LSHFT>)
		MACRO(shift_ae, <&macro_tap &kp TILD_>, <&macro_press &kp LSHFT>, <&macro_tap &kp A_ &kp E_>, <&macro_release &kp LSHFT>)
		MACRO(shift_ao, <&macro_tap &kp TILD_>, <&macro_press &kp LSHFT>, <&macro_tap &kp A_ &kp O_>, <&macro_release &kp LSHFT>)
		MACRO(shift_oe, <&macro_tap &kp TILD_>, <&macro_press &kp LSHFT>, <&macro_tap &kp O_ &kp E_>, <&macro_release &kp LSHFT>)
		
		// MACRO(spc_capl, <&macro_tap &kp SPACE &tog CAPL>) // space then toggle caps layer
	};
			  
	combos {
		compatible = "zmk,combos";
		
		#define DEFINE_COMBO(LAYERS, BINDINGS, POSITIONS, NAME) \
			combo_##NAME { \
				layers = <LAYERS>; \
				bindings = <BINDINGS>; \
				key-positions = <POSITIONS>; \
				timeout-ms = <COMBO_TIMEOUT>; \
			};
		
		// when not defining layers, will default to NOT_GAME
		#define COMBO(BINDINGS, POSITIONS, NAME) \
			DEFINE_COMBO(NOT_GAME, BINDINGS, POSITIONS, NAME)		
			
		#define COMBO_LAYER(LAYERS, BINDINGS, POSITIONS, NAME) \
			DEFINE_COMBO(LAYERS, BINDINGS, POSITIONS, NAME)

		
		#define COMBO_KP(KEY, SUFFIX, POSITIONS) \
			DEFINE_COMBO(NOT_GAME, &kp KEY, POSITIONS, KEY##SUFFIX)	
			
		#define COMBO_KP_LAYER(KEY, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS, &kp KEY, POSITIONS, KEY##SUFFIX)
			
		
		#define COMBO_MACRO(MACRO, POSITIONS) \
			DEFINE_COMBO(NOT_GAME, &m_##MACRO>, POSITIONS, MACRO)		
			
		#define COMBO_MACRO_LAYER(MACRO, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS, &m_##MACRO>, POSITIONS, MACRO##SUFFIX)
		
			
	/*
	    0   1   2   3      4 | 5      6   7   8   9
	    10  11  12  13    14 | 15    16  17  18  19
	    20  21  22  23    24 | 25    26  27  28  29
							 |
	                   30 31 | 32 33
					   
					   
	     0  11  12  13  |  16  17  18  9
	    10  21  22  23  |  26  27  28  19
					    |
	              30 31 | 32 33
	*/
	
		COMBO_KP(TAB,, 12 13)
		COMBO_KP(ENTER,, 16 17)
		COMBO_KP(SPACE,l, 11 12 13)
		COMBO_KP(SPACE,r, 16 17 18)
		
		COMBO_KP(BSPC,, 11 12)
		COMBO_KP(DEL,, 21 22)
		COMBO(&kp LC(BSPC), 17 18, gslqgrnqsl)
		COMBO(&kp LC(DEL), 27 28, rgsrnqsj)
				
		COMBO(&lsk FUNC LSHIFT, 30 31, dljsdqsrt)
		COMBO(&sk RSHIFT,       32 33, sqljqrjqsl)
		
		COMBO_KP(ESC,, 	  10 11)
		
		COMBO_MACRO_LAYER(Q_U_,, 26 27, BASE)
		COMBO_MACRO_LAYER(ae,, 13 30, BASE)
		COMBO_MACRO_LAYER(ao,, 13 11, BASE)
		COMBO_MACRO_LAYER(oe,, 11 30, BASE)
		
		COMBO_MACRO_LAYER(shift_qu,, 26 27, CAPL)
		COMBO_MACRO_LAYER(shift_ae,, 13 30, CAPL)
		COMBO_MACRO_LAYER(shift_ao,, 13 11, CAPL)
		COMBO_MACRO_LAYER(shift_oe,, 11 30, CAPL)
		
		
		combo_ctrlz {
			bindings = <&kp LC(Z_)>;
			key-positions = <20 21>;
			timeout-ms = <COMBO_TIMEOUT>;
		};
		
		combo_reset_left {
			bindings = <&reset>;
			key-positions = <0 4>;
			layers = <FUNC>;
			timeout-ms = <COMBO_TIMEOUT>;
		};
		
		combo_bootloader {
			bindings = <&bootloader>;
			key-positions = <20 24>;
			layers = <FUNC>;
			timeout-ms = <COMBO_TIMEOUT>;
		};
		
		combo_game_layer {
			bindings = <&tog GAME>;
			key-positions = <0 1 2>;
			layers = <FUNC>;
			timeout-ms = <COMBO_TIMEOUT>;
		};
	};

	keymap {
		compatible = "zmk,keymap";
		
		#define HMLS  &hml LSHIFT
		#define HMRS  &hmr RSHIFT
		#define HMLC  &hm LCTRL
		#define HMRC  &hm RCTRL
		#define HMLA  &hm LALT
		#define HMRA  &hm RALT
		#define HMLG  &hm LGUI
		#define HMRG  &hm RGUI
		
		#define HMLG_QU		&hm_qu LGUI 0
		#define HMLG_QUC	&hm_quc LGUI 0
		#define HMRA_IACT	&hm_iact RALT 0
		#define HMLA_AACT	&hm_aact LALT 0
		#define HMLG_UACT	&hm_uact LGUI 0
		
		#define EXCL_QMRK	&mt EXCL_ QMRK_
		
		/*
		#define MTPAR  &mt RPAR_ LPAR_
		#define MTCRL  &mt RCRL_ LCRL_
		#define MTBRK  &mt RBRK_ LBRK_
		#define MTGLM  &mt RGLM_ LGLM_
		#define MTGLT  &mt GT_   LT_*/
		
		/*#define MTDASH  &mtslow NDSH_ MDSH_*/
		#define MTCASH  &mt EURO_ DLLR_
		
		#define MTLGLM &ht_lglm LGLM_ 0
		#define MTRGLM &ht_rglm RGLM_ 0
		
		// thumb keys
		#define THLH1	&lt NUM E_
		#define THLH1S	&lt NUM LS(E_)
		#define THLH2	&lsl SYM SYM
		#define THRH2	&lsl ACNT ACNT
		#define THRH1	&lt NAV SPACE
		
		#define xxxx &none
		#define ____ &trans
		
		base_layer {
			bindings = <
				&kp  Q_		HMRA MIN_	&kp  Y_		&kp DOT_	EXCL_QMRK			&kp K_		&kp  C_		&kp  H_		&kp  W_		&kp  J_
				HMRG U_		HMLA O_		HMLC I_		HMLS A_		&kp F_				&kp G_		HMRS T_		HMRC R_		HMRA S_		HMRG N_
				&kp  Z_		HMLC EACT_	&kp  P_		&kp COMM_	&kp X_				&kp V_		&kp  D_		&kp  M_		&kp  L_		&kp  B_
													THLH1		THLH2				THRH2		THRH1
			>;
		};
		
		caps_layer {
			bindings = <
				&kp  LS(Q_)		____			&kp  LS(Y_)	 &kp DOT_	   ____				&kp LS(K_)		&kp  LS(C_)		&kp  LS(H_)		&kp  LS(W_)		&kp  LS(J_)
				HMRG LS(U_)		HMLA LS(O_)		HMLC LS(I_)	 HMLS LS(A_)   &kp LS(F_)		&kp LS(G_)		HMRS LS(T_)		HMRC LS(R_)		HMRA LS(S_)		HMRG LS(N_)
				&kp  LS(Z_)		HMLC LS(EACT_)	&kp  LS(P_)	 ____		   &kp LS(X_)		&kp LS(V_)		&kp  LS(D_)		&kp  LS(M_)		&kp  LS(L_)		&kp  LS(B_)
														     THLH1S	  	   THLH2			THRH2			THRH1
			>;
		};
		
		sym_layer {
			bindings = <
				xxxx		&kp AT_		&kp AMPR_	&kp OE_		&kp AE_				xxxx	xxxx		xxxx		xxxx		xxxx
				HMRG LCRL_	HMLA RCRL_	HMLC LPAR_	HMLS RPAR_	&kp MDSH_			xxxx	HMRS LBRK_	HMRC RBRK_	HMLA MDSH_	HMRG NDSH_
				&kp NDSH_	&kp MDSH_	MTLGLM		MTRGLM		xxxx				xxxx	&kp LT_		&kp GT_		&kp EQUL_	xxxx
													THLH1		____				____	____
			>;
		};
		
		accent_layer {
			bindings = <
				&m_CFLX_U_	&m_CFLX_O_	&m_CFLX_I_	&m_CFLX_A_	xxxx				xxxx		&kp CCED_	&kp  APST_	&kp  QUOT_	&m_B_J_
				&m_ACUT_U_	&m_ACUT_O_	&m_ACUT_I_	&m_ACUT_A_	&m_TILD_A_			&kp ACUT_	HMRS MIN_	HMRC CFLX_	HMLA GRAV_	&m_TILD_N_
				&m_GRAV_U_	&m_TILD_O_	&m_TRMA_I_	&kp AGRV_	xxxx				xxxx		&kp TRMA_	&kp  CRAT_	&kp  SZET_	&kp TILD_
													&m_CFLX_E_	&m_GRAV_E_			____		____
			>;
		};
		
		num_layer {
			bindings = <
				xxxx		&kp N7_		&kp N8_		&kp N9_		xxxx				xxxx		MTCASH		&kp HASH_	&kp PCNT_	&kp PIPE_
				&kp N0_		&kp N1_		&kp N2_		&kp	N3_		&kp DOT_			xxxx		HMRS PLUS_	HMRC MIN_	HMLA STAR_	HMRG FSLA_
				xxxx		&kp N4_		&kp N5_		&kp	N6_		&kp COMM_			xxxx		&kp LT_		&kp GT_		&kp EQUL_	&kp BSLA_
													____		____				&kp ULIN_	____
			>;
		};
		
		nav_layer {
			bindings = <
				&kp INSERT	&sk RALT	&kp PSCRN	&kp PSBRK	xxxx				xxxx		&kp LC(HOME)	&kp PG_DN	&kp PG_UP	&kp LC(END)
				&sk LGUI	&sk LALT	&sk LCTRL	&sk LSHIFT	&tog CAPL			&kp CAPS	&kp LC(LEFT)	&kp DOWN	&kp UP		&kp LC(RIGHT)
				&kp LC(Z_)	&kp LC(X_)	&kp LC(C_)	&kp LC(V_)	xxxx				xxxx		&kp HOME		&kp LEFT	&kp RIGHT	&kp END
													&kp ULIN_	____				____		____
			>;
		};
		
		func_layer {
			bindings = <
				&bt  BT_CLR    &bt  BT_SEL 0  &bt  BT_SEL 1  &bt  BT_SEL 2  &bt BT_SEL 3			&reset        &kp F7  &kp F8  &kp F9  &kp F10
				HMLG C_BRI_UP  HMLA C_NEXT	  HMLC C_VOL_UP  HMLS C_PP  	&kp LSLCK				&out OUT_BLE  &kp F1  &kp F2  &kp F3  &kp F11
				&kp  C_BRI_DN  &kp  C_PREV    &kp  C_VOL_DN  &kp  C_MUTE    &kp LNLCK				&out OUT_USB  &kp F4  &kp F5  &kp F6  &kp F12
															 ____			____					____		  ____
			>;
		};
		
		game_layer {
			bindings = <
				&kp ESC		&kp  F_		&kp  W_		&kp  E_		&kp T_				&kp Y_		&kp  U_		&kp  I_		&kp  O_		&kp  P_
				&kp LSHIFT	&kp  A_		&kp  S_		&kp  D_		&kp R_				&kp H_		&kp  J_		&kp  K_		&kp  L_		&kp  N_
				&kp LCTRL	&kp  Z_		&kp  X_		&kp  C_		&kp V_				&kp N_		&kp  M_		&kp  COMM_	&kp  DOT_	&kp  BSPC
													&kp SPACE	&kp TAB				&tog GAME	&kp LALT
			>;
		};
		
		/* FOR DEBUGGING:
			bindings = <
				xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
				xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
				xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
				xxxx xxxx xxxx xxxx
			>;
		*/
	};
};
