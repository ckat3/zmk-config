#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/outputs.h>

#include "bepo_bindings.h"

// SETTINGS
#define _MACRO_INTERVAL   3  // max 5
#define _MACRO_TAP_FOR    3  // max 5 

#define _COMBO_TIMEOUT    16 // min 16

#define _TAP_TERM_SLOW    300
#define _TAP_TERM         300 //default 250
#define _TAP_TERM_QUICK   200
#define _TAP_TERM_BLAZIN  120

#define _QUICK_TAP        200

#define _STICKY_TIMEOUT   2000 // min 1000

// LAYERS
#define BASE 1 
#define CPWD 2 
#define NUM  3 
#define UTIL 4 
#define SYM  5 
#define ACNT 6 
#define ACCP 7 
#define NAV  8 
#define FUNC 9 
#define GAME 10
#define GAM2 11

// combos shouldn't work on game layer, to minimize delay
#define ALL_LAYERS  BASE CPWD UTIL SYM ACNT ACCP NUM NAV FUNC GAME GAM2
#define NOT_GAME    BASE CPWD UTIL SYM ACNT ACCP NUM NAV FUNC
#define NOT_CPWD    BASE      UTIL SYM ACNT ACCP NUM NAV FUNC

&lt {
	tapping-term-ms = <_TAP_TERM>;
	flavor = "balanced";
};

&mt {
	tapping-term-ms = <_TAP_TERM_BLAZIN>;
};

&sk {
	release-after-ms = <_STICKY_TIMEOUT>;
	quick-release;
};

/ { 
	behaviors {
		#define DEFINE_HOLDTAP(NAME, FLAVOR, DELAY, BINDINGS...) \
			NAME: ht_##NAME { \
				label = #NAME; \
				flavor = #FLAVOR; \
				tapping-term-ms = <DELAY>; \
				bindings = BINDINGS; \
				#binding-cells = <2>; \
				compatible = "zmk,behavior-hold-tap"; \
				quick-tap-ms = <_QUICK_TAP>;
				
		#define HOLDTAP(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM, BINDINGS) \
			};
				
		#define HOLDTAP_QUICK(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM_QUICK, BINDINGS) \
			};
				
		#define HOLDTAP_BAL(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, balanced, _TAP_TERM, BINDINGS) \
			};
			
		#define HRMOD_POS(NAME, POSITIONS) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM, <&kp>, <&kp>) \
					hold-trigger-key-positions = <POSITIONS>; \
			};
		
		#define HOLDTAP_SLOW(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM_SLOW, BINDINGS) \
			};
		
		// HOLDTAP(ht_qu,   <&kp>, <&m_Q_U_>)    // qu              &kp
		// HOLDTAP(ht_aact, <&kp>, <&m_ACUT_A_>) // á               &kp
		// HOLDTAP(ht_uact, <&kp>, <&m_ACUT_U_>) // ú               &kp
		// HOLDTAP(ht_iact, <&kp>, <&m_ACUT_I_>) // í               &kp

		
		// home-row mods               // PRESS           HOLD
		HOLDTAP(      ht,     <&kp>, <&kp>) // &kp             &kp
		HOLDTAP_SLOW( htslow, <&kp>, <&kp>)
		HOLDTAP(      htsk,   <&sk>, <&kp>) // &kp             sticky layer
		HOLDTAP_BAL(  lsk,    <&mo>, <&sk>) // one-shot mod    hold layer
		HOLDTAP_BAL(  lsl,    <&mo>, <&sl>) // one-shot layer  hold layer
		HOLDTAP_BAL(  htcpwd, <&mo>, <&m_spc_togcpwd>) // space then desactivate capsword    hold layer

		// hrm for opposite hand only (used for shift)
		HRMOD_POS(htl, 5 6 7 8 9 15 16 17 18 19 25 26 27 28 29 32 33)
		HRMOD_POS(htr, 0 1 2 3 4 10 11 12 13 14 20 21 22 23 24 30 31)
		
		// automatic nbsp on tap
		HOLDTAP(ht_lglm, <&kp>, <&m_nbsp_lglm>)
		HOLDTAP(ht_rglm, <&kp>, <&m_nbsp_rglm>)
		
		// automatic nbsp on hold
		HOLDTAP_QUICK(ht_coln, <&m_nbsp_coln>, <&kp>)
		HOLDTAP_QUICK(ht_scln, <&m_nbsp_scln>, <&kp>)
		HOLDTAP_QUICK(ht_qmrk, <&m_nbsp_qmrk>, <&kp>)
		HOLDTAP_QUICK(ht_excl, <&m_nbsp_excl>, <&kp>)
	};

	macros {
		#define RELEASE_SHIFT <&macro_release &kp LSHFT &kp RSHFT>
		
		#define MACRO(NAME, BINDINGS...) \
			ZMK_MACRO(m_##NAME, \
				tap-ms   = <_MACRO_TAP_FOR>; \
				wait-ms  = <_MACRO_INTERVAL>; \
				bindings = BINDINGS; \
				)
				
		// MACRO_SIMPLE names the macro "m_FIRST##SECOND", eg "m_Q_U_"
		#define MACRO_SIMPLE(FIRST, SECOND) \
			MACRO(FIRST##SECOND, <&macro_tap &kp FIRST &kp SECOND>)
			// MACRO(FIRST##SECOND, <&macro_tap &kp FIRST>, RELEASE_SHIFT, <&macro_tap &kp SECOND>)		

			
		#define MACRO_SIMPLE_SHIFT(FIRST, SECOND) \
			MACRO(cp_##FIRST##SECOND, <&macro_tap &kp FIRST &kp SECOND>)
			
		#define MACRO_ACCENT(FIRST, SECOND) \
			MACRO_SIMPLE( FIRST, SECOND ) \
			MACRO_SIMPLE_SHIFT(FIRST, SECOND)
		// #define MACRO_ACCENT(FIRST, SECOND) \
			// MACRO(FIRST##SECOND, <&macro_tap &kp FIRST &kp SECOND>)
			
	
		// accented letters
		// MACRO_ACCENT(ACUT_, A_)
		// MACRO_ACCENT(ACUT_, I_)
		// MACRO_ACCENT(ACUT_, O_)
		// MACRO_ACCENT(ACUT_, U_)
		
		// MACRO_ACCENT(CFLX_, A_)
		// MACRO_ACCENT(CFLX_, E_)
		// MACRO_ACCENT(CFLX_, I_)
		// MACRO_ACCENT(CFLX_, O_)
		// MACRO_ACCENT(CFLX_, U_)
		
		// MACRO_ACCENT(GRAV_, E_)
		// MACRO_ACCENT(GRAV_, O_)
		// MACRO_ACCENT(GRAV_, U_)
		
		// MACRO_ACCENT(TILD_, A_)
		// MACRO_ACCENT(TILD_, O_)
		// MACRO_ACCENT(TILD_, N_)
		
		// MACRO_ACCENT(TRMA_, I_)
		
		MACRO_SIMPLE(ACUT_, A_)
		MACRO_SIMPLE(ACUT_, I_)
		MACRO_SIMPLE(ACUT_, O_)
		MACRO_SIMPLE(ACUT_, U_)
		
		MACRO_SIMPLE(CFLX_, A_)
		MACRO_SIMPLE(CFLX_, E_)
		MACRO_SIMPLE(CFLX_, I_)
		MACRO_SIMPLE(CFLX_, O_)
		MACRO_SIMPLE(CFLX_, U_)
		
		MACRO_SIMPLE(GRAV_, O_)
		MACRO_SIMPLE(GRAV_, U_)
		
		MACRO_SIMPLE(TILD_, A_)
		MACRO_SIMPLE(TILD_, O_)
		MACRO_SIMPLE(TILD_, N_)
		
		MACRO_SIMPLE(TRMA_, I_)
		
		// // caps accented letters		
		MACRO(CP_ACUT_A_,      <&macro_tap  &kp ACUT_  &kp LS(A_)>)
		MACRO(CP_ACUT_I_,      <&macro_tap  &kp ACUT_  &kp LS(I_)>)
		MACRO(CP_ACUT_O_,      <&macro_tap  &kp ACUT_  &kp LS(O_)>)
		MACRO(CP_ACUT_U_,      <&macro_tap  &kp ACUT_  &kp LS(U_)>)
					   
		MACRO(CP_CFLX_A_,      <&macro_tap  &kp CFLX_  &kp LS(A_)>)
		MACRO(CP_CFLX_E_,      <&macro_tap  &kp CFLX_  &kp LS(E_)>)
		MACRO(CP_CFLX_I_,      <&macro_tap  &kp CFLX_  &kp LS(I_)>)
		MACRO(CP_CFLX_O_,      <&macro_tap  &kp CFLX_  &kp LS(O_)>)
		MACRO(CP_CFLX_U_,      <&macro_tap  &kp CFLX_  &kp LS(U_)>)
					   
		MACRO(CP_GRAV_E_,      <&macro_tap  &kp GRAV_  &kp LS(E_)>)
		MACRO(CP_GRAV_O_,      <&macro_tap  &kp GRAV_  &kp LS(O_)>)
		MACRO(CP_GRAV_U_,      <&macro_tap  &kp GRAV_  &kp LS(U_)>)
					   _
		MACRO(CP_TILD_A_,      <&macro_tap  &kp TILD_  &kp LS(A_)>)
		MACRO(CP_TILD_O_,      <&macro_tap  &kp TILD_  &kp LS(O_)>)
		MACRO(CP_TILD_N_,      <&macro_tap  &kp TILD_  &kp LS(N_)>)
					   
		MACRO(CP_TRMA_I_,      <&macro_tap  &kp TRMA_  &kp LS(I_)>)
		
		// qu bj (shortcuts for inconvenient sequences)
		MACRO_SIMPLE(Q_, U_)
		MACRO_SIMPLE(B_, J_)
		
		// caps bj (shortcuts for inconvenient sequences)
		MACRO(cp_qu,        <&macro_tap  &kp LS(Q_) &kp LS(U_)>)
		MACRO(cp_bj,        <&macro_tap  &kp LS(B_) &kp LS(J_)>)
		
		// ãe ão õe
		MACRO(ae,           <&macro_tap  &kp TILD_  &kp A_  &kp E_>)
		MACRO(ao,           <&macro_tap  &kp TILD_  &kp A_  &kp O_>)
		MACRO(oe,           <&macro_tap  &kp TILD_  &kp O_  &kp E_>)
		MACRO(cp_ae,        <&macro_tap  &kp TILD_  &kp LS(A_)  &kp LS(E_)>)
		MACRO(cp_ao,        <&macro_tap  &kp TILD_  &kp LS(A_)  &kp LS(O_)>)
		MACRO(cp_oe,        <&macro_tap  &kp TILD_  &kp LS(O_)  &kp LS(E_)>)
		
		// ß
		MACRO(eszett,       <&macro_tap  &kp RA(S_)  &kp S_>)
		MACRO(cp_sztt,      <&macro_tap  &kp RA(S_)  &kp LS(S_)>)
		
		// :;?!«» with nbsp	
		MACRO(nbsp_qmrk,    <&macro_tap  &kp LS(SPACE)  &kp LS(QMRK_)>,  RELEASE_SHIFT,  <&macro_tap &kp SPACE>)
		MACRO(nbsp_excl,    <&macro_tap  &kp LS(SPACE)  &kp LS(EXCL_)>,  RELEASE_SHIFT,  <&macro_tap &kp SPACE>)
		MACRO(nbsp_coln,    <&macro_tap  &kp LS(SPACE)  &kp LS(DOT_)>,   RELEASE_SHIFT,  <&macro_tap &kp SPACE>)
		MACRO(nbsp_scln,    <&macro_tap  &kp LS(SPACE)  &kp LS(COMM_)>,  RELEASE_SHIFT,  <&macro_tap &kp SPACE>)
		MACRO(nbsp_rglm,    <&macro_tap  &kp LS(SPACE)  &kp RGLM_>)
		MACRO(nbsp_lglm,    <&macro_tap  &kp LGLM_      &kp LS(SPACE)>)
		
		// loose ^ and `
		MACRO(cfxloos,      <&macro_tap  &kp CFLX_  &kp SPACE>)
		MACRO(grvloos,      <&macro_tap  &kp GRAV_  &kp SPACE>)
		
		// key and turn off capsword
		MACRO(spc_togcpwd,  <&macro_tap  &kp SPACE  &tog CPWD>)
		MACRO(tab_togcpwd,  <&macro_tap  &kp TAB    &tog CPWD>)
		MACRO(entr_togcpwd, <&macro_tap  &kp ENTER  &tog CPWD>)
		
		MACRO(cut_all,   <&macro_tap  &kp LC(A_) &kp LS(X_)>)
		MACRO(copy_all,  <&macro_tap  &kp LC(A_) &kp LS(C_)>)
		MACRO(paste_all, <&macro_tap  &kp LC(A_) &kp LS(V_)>)
	};
			  
	combos {
		compatible = "zmk,combos";
		
		#define DEFINE_COMBO(LAYERS, BINDINGS, POSITIONS, NAME) \
			combo_##NAME { \
				layers = <LAYERS>; \
				bindings = <BINDINGS>; \
				key-positions = <POSITIONS>; \
				timeout-ms = <_COMBO_TIMEOUT>; \
			};
		
		// when not defining layers, will default to NOT_GAME
		// TODO: ok to omit line breaks between defs?
		// TODO: all combos define layers
		#define COMBO(BINDINGS, POSITIONS, NAME) \
			DEFINE_COMBO(NOT_GAME, BINDINGS, POSITIONS, NAME)
			
		#define COMBO_LAYER(LAYERS, BINDINGS, POSITIONS, NAME) \
			DEFINE_COMBO(LAYERS, BINDINGS, POSITIONS, NAME)

		// single key press
		#define COMBO_KP(KEY, SUFFIX, POSITIONS) \
			DEFINE_COMBO(NOT_GAME, &kp KEY, POSITIONS, KEY##SUFFIX)	
			
		#define COMBO_KP_LAYER(KEY, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS, &kp KEY, POSITIONS, KEY##SUFFIX)
		
		// macrco
		#define COMBO_MACRO(MACRO, POSITIONS) \
			DEFINE_COMBO(NOT_GAME, &m_##MACRO, POSITIONS, MACRO)
			
		#define COMBO_MACRO_LAYER(MACRO, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS, &m_##MACRO, POSITIONS, MACRO##SUFFIX)
		
	/*
	    0   1   2   3      4 | 5      6   7   8   9
	    10  11  12  13    14 | 15    16  17  18  19
	    20  21  22  23    24 | 25    26  27  28  29
							 |
	                   30 31 | 32 33
					   
					   
	     0  11  12  13  |  16  17  18  9
	    10  21  22  23  |  26  27  28  19
					    |
	              30 31 | 32 33
	*/
	
		COMBO_KP_LAYER(TAB,,      12 13, NOT_CPWD)
		COMBO_KP_LAYER(ENTER,,    16 17, NOT_CPWD)
				
		COMBO_KP(SPACE,l,         11 12 13)
		COMBO_KP(SPACE,r,         16 17 18)
		
		// fake tab
		COMBO(&kp SPACE &kp SPACE &kp SPACE &kp SPACE, 10 11 12 13,       gslqaiogrnqsl) // whatever name)
		COMBO(&kp SPACE &kp SPACE &kp SPACE &kp SPACE, 15 16 17 18,       rgsaiornqsj)
		
		COMBO_KP(ESC,,            10 11)
		
		COMBO_KP(BSPC,,           11 12)
		COMBO_KP(DEL,,            21 22)
		COMBO(&kp LC(BSPC),       17 18,       gslqgrnqsl) // whatever name
		COMBO(&kp LC(DEL),        27 28,       rgsrnqsj)
				
		COMBO(&lsk FUNC LSHIFT,   30 31,       dljsdqsrt)
		COMBO(&sk  RSHIFT,        32 33,       sqljqrjqsl)
		
		COMBO_MACRO_LAYER(Q_U_,,  26 27, BASE)
		COMBO_MACRO_LAYER(ae,,    13 30, BASE)
		COMBO_MACRO_LAYER(ao,,    13 11, BASE)
		COMBO_MACRO_LAYER(oe,,    11 30, BASE)
		
		COMBO_MACRO_LAYER(cp_qu,, 26 27, CPWD)
		COMBO_MACRO_LAYER(cp_ae,, 13 30, CPWD)
		COMBO_MACRO_LAYER(cp_ao,, 13 11, CPWD)
		COMBO_MACRO_LAYER(cp_oe,, 11 30, CPWD)
		COMBO_MACRO_LAYER(tab_togcpwd,,  12 13, CPWD)
		COMBO_MACRO_LAYER(entr_togcpwd,, 16 17, CPWD)
		
		combo_ctrlz {
			bindings = <&kp LC(Z_)>;
			key-positions = <20 21>;
			timeout-ms = <_COMBO_TIMEOUT>;
		};
		
		combo_reset_left {
			bindings = <&sys_reset>;
			key-positions = <0 4>;
			layers = <FUNC>;
			timeout-ms = <_COMBO_TIMEOUT>;
		};
		
		combo_bootloader {
			bindings = <&bootloader>;
			key-positions = <20 24>;
			layers = <FUNC>;
			timeout-ms = <_COMBO_TIMEOUT>;
		};
		
		combo_game_layer {
			bindings = <&tog GAME>;
			key-positions = <4 14>;
			layers = <FUNC>;
			timeout-ms = <_COMBO_TIMEOUT>;
		};
		
		combo_game_2_layer {
			bindings = <&tog GAME>;
			key-positions = <14 24>;
			layers = <FUNC>;
			timeout-ms = <_COMBO_TIMEOUT>;
		};
	};

	keymap {
		compatible = "zmk,keymap";
		
		#define trans        &trans
		#define _____        &none
		#define _________   &none
		
		#define PASTEPLAIN       LC(LG(LA(V_))) // power toys plaintext paste (no &kp bc used in &ht)
		#define C_S_DEL     &kp  LC(LS(DEL))    // task manager
		#define RESET_LEFT  &sys_reset
		
		// home-row mods
		#define HMLS    &htl    LSHIFT
		#define HMRS    &htr    RSHIFT
		#define HMLC    &ht     LCTRL
		#define HMRC    &ht     RCTRL
		#define HMLA    &ht     LALT
		#define HMRA    &ht     RALT
		#define HMLG    &htslow LGUI
		#define HMRG    &htslow RGUI
		 // for sticky mods in nav layer:
		#define SKLS    &htsk   LSHIFT
		#define SKLC    &htsk   LCTRL
		#define SKLA    &htsk   LALT
		#define SKLG    &htsk   LGUI
		
		// □ = space, ■ = nbsp
		// tap/hold                                // TAP      HOLD
		#define DLLR_EURO    &mt  	   EURO_ DLLR_ // $        €
		#define EQUL_DIFF    &mt  	   DIFF_ EQUL_ // =        ≠
		#define NBSP_QMRK    &ht_qmrk  0 QMRK_     // ?        ■?
		#define NBSP_EXCL    &ht_excl  0 EXCL_     // !        ■!
		#define DOT_COLN     &ht_coln  0 DOT_      // .        ■:□
		#define COMM_SCLN    &ht_scln  0 COMM_     // ,        ■;□
		
		#define NBSP_LGLM    &ht_lglm  LGLM_ 0     // «■    «
		#define NBSP_RGLM    &ht_rglm  RGLM_ 0     // ■»    »
		
		#define HT_CTRZ    &ht  LC(Y_)      LC(Z_) // undo     redo
		#define HT_CTRV    &ht  PASTEPLAIN  LC(V_) // paste    plaintext paste
		
		
		// thumb keys
		#define TH_L_MAIN      &lt   NUM E_
		#define TH_L_MAIN_CW   &lt   NUM LS(E_) // capsword
		
		#define TH_L_AUX       &lsl  SYM SYM
		
		#define TH_R_MAIN      &lt      NAV SPACE
		#define TH_R_MAIN_CW   &htcpwd  NAV 0  // capsword
		
		#define TH_R_AUX       &lsl  ACNT ACNT
		
		
		#define _DEFAULT_THUMBS_  TH_L_MAIN     TH_L_AUX          TH_R_AUX TH_R_MAIN
		#define _CAPSWORD_THUMBS_ TH_L_MAIN_CW      _trans_          _trans_     TH_R_MAIN_CW
		
		
		// todo reorder layers according to thumbs
		base_layer {
			bindings = <
				&kp  Q_   HMRA MIN_   &kp  Y_   DOT_COLN   NBSP_QMRK           &kp K_    &kp  C_    &kp  H_    &kp  W_    &kp  J_
				HMLG U_   HMLA O_     HMLC I_   HMLS A_    &kp F_            &kp G_    HMRS T_    HMRC R_    HMRA S_    HMRG N_
				&lt UTIL Z_ HMLC EACT_  &kp  P_   COMM_SCLN  &kp X_            &kp V_    &kp  D_    &kp  M_    &kp  L_  &lt UTIL B_
															     _DEFAULT_THUMBS_
			>;
		};
		
		caps_word_layer {
			bindings = <
				&kp  LS(Q_)	 HMRA MIN_       &kp  LS(Y_)  DOT_COLN     _trans_          &kp LS(K_)   &kp  LS(C_)  &kp  LS(H_)  &kp  LS(W_)  &kp  LS(J_)
				HMLG LS(U_)	 HMLA LS(O_)	 HMLC LS(I_)  HMLS LS(A_)  &kp LS(F_)         &kp LS(G_)   HMRS LS(T_)  HMRC LS(R_)  HMRA LS(S_)  HMRG LS(N_)
				&kp  LS(Z_)	 HMLC LS(EACT_)	 &kp  LS(P_)  COMM_SCLN    &kp LS(X_)         &kp LS(V_)   &kp  LS(D_)  &kp  LS(M_)  &kp  LS(L_)  &kp  LS(B_)
														                     _CAPSWORD_THUMBS_
			>;
		};
				
		num_layer {
			bindings = <
				_____    &kp N7_  &kp N8_  &kp N9_  _________          _________  DLLR_EURO   &kp  HASH_   &kp  PCNT_   &kp  PIPE_
				&kp N0_  &kp N1_  &kp N2_  &kp N3_  &kp DOT_		   _________  HMRS PLUS_  HMRC MIN_    HMLA STAR_   HMRG FSLA_
				_____    &kp N4_  &kp N5_  &kp N6_  &kp COMM_		   _________  &kp LT_     &kp  GT_	   EQUL_DIFF   &kp  BSLA_
										   _trans_ 	_trans_             &kp ULIN_  _trans_
			>;
		};
		
		utility_layer {
			bindings = <
				_____ _________    _________        _________     _____         _____   _____ _____ _____ _____
				_____ _________    &kp LS(LC(TAB))  &kp LC(TAB)   _____         _____   _____ _____ _____ _____
				_____ &kp LG(TAB)  &kp LS(LA(TAB))  &kp LA(TAB)   _____         _____   _____ _____ _____ _____
			                   _____   _____         _____   _____
			>;
		};
		
		sym_layer {
			bindings = <
				&kp AE_		 &kp AT_       &kp AMPR_   &kp OE_     NBSP_EXCL           _________  _________   _________   _________   _________
				SKLG LBRK_	 SKLA RBRK_    SKLC LPAR_  SKLS RPAR_  &kp MDSH_         _________  HMRS LCRL_  HMRC RCRL_  HMLA _____   HMRG _____
				&kp NDSH_	 &kp MDSH_     NBSP_LGLM     NBSP_RGLM	   _________         _________  _________   &m_grvloos  &m_cfxloos  _________
									_trans_ 	&kp ULIN_  _trans_             _trans_
			>;
		};
		
		accent_layer {
			bindings = <
				&m_CFLX_U_  &m_CFLX_O_  &m_CFLX_I_  &m_CFLX_A_  _________			_________  &kp  CCED_  &kp  APST_  &kp  QUOT_  &m_B_J_
				&m_ACUT_U_  &m_ACUT_O_  &m_ACUT_I_  &m_ACUT_A_  &m_TILD_A_			_________  HMRS ACUT_  HMRC GRAV_  HMLA CFLX_  &m_TILD_N_
				&m_GRAV_U_  &m_TILD_O_  &m_TRMA_I_  &kp AGRV_   _________			_________  &kp  TRMA_  _________   &m_eszett   &kp TILD_
												    &m_CFLX_E_  &kp EGRV_			_trans_       _trans_
			>;
		};
		
		accent_caps_layer {
			bindings = <
				&m_cp_CFLX_U_  &m_cp_CFLX_O_  &m_cp_CFLX_I_  &m_cp_CFLX_A_  _________            _________  &kp  CCED_  &kp  APST_  &kp  QUOT_  &m_cp_bj
				&m_cp_ACUT_U_  &m_cp_ACUT_O_  &m_cp_ACUT_I_  &m_cp_ACUT_A_  &m_cp_TILD_A_        _________  HMRS ACUT_  HMRC GRAV_  HMLA CFLX_  &m_cp_tl_n
				&m_cp_GRAV_U_  &m_cp_TILD_O_  &m_cp_TRMA_I_  &kp LS(AGRV_)  _________            _________  &kp  TRMA_  _________   &m_cp_sztt  &kp TILD_
												             &m_cp_CFLX_E_  &kp LS(EGRV_)        _trans_       _trans_
			>;
		};
		
		nav_layer { // HMRG LGUI	HMLA LALT	HMLC LCTRL	HMLS LSHIFT	 
			bindings = <
				&kp INSERT	&sk RALT	&kp PSCRN	 &kp PSBRK     C_S_DEL			_________	&kp LC(HOME)  &kp PG_DN	 &kp PG_UP	&kp LC(END)
				&kp CAPS	&m_cut_all	&m_copy_all  &m_paste_all  &tog CPWD			&kp LC(LEFT)  &kp DOWN	 &kp UP		&kp LC(RIGHT)
				HT_CTRZ		&kp LC(X_)	&kp LC(C_)	 HT_CTRV       _____    			_________	&kp HOME      &kp LEFT	 &kp RIGHT	&kp END
													 _trans_        &kp ULIN_			_trans_        _trans_
			>;
		};
		
		func_layer {
			bindings = <
				&bt  BT_CLR     &bt  BT_SEL 0   &bt  BT_SEL 1   &bt  BT_SEL 2  &bt BT_SEL 3			RESET_LEFT    &kp F7  &kp F8  &kp F9  &kp F10
				HMLG C_BRI_UP   HMLA C_NEXT     HMLC C_VOL_UP   HMLS C_PP  	   &kp LSLCK			&out OUT_BLE  &kp F1  &kp F2  &kp F3  &kp F11
				&kp  C_BRI_DN   &kp  C_PREV     &kp  C_VOL_DN   &kp  C_MUTE    &kp LNLCK			&out OUT_USB  &kp F4  &kp F5  &kp F6  &kp F12
															                           _DEFAULT_THUMBS_
			>;
		};
		
		game_layer {
			bindings = <
				&kp Q_      &kp MIN_   &kp Y_     &kp DOT_    &kp R_            &kp K_     &kp C_     &kp H_     &kp W_     &kp J_
				&kp U_      &kp O_     &kp I_     &kp A_      &kp F_            &kp G_     &kp LEFT   &kp UP     &kp RIGHT  &kp N_
				&kp Z_      &kp S_     &kp P_     &kp COMM_	  &kp X_            &tog GAME  &kp D_     &kp DOWN   &kp L_     &kp B_
											      &kp ENTER   &kp SPACE         &kp TAB    &kp LALT
			>;
		};
		
		game_layer_2 {
			bindings = <
				&kp LSHIFT  &kp A_     &kp EACT_  &kp I_      &kp O_            &kp Y_     &kp U_     &kp I_     &kp O_     &kp P_
				&kp LCTRL   &kp B_     &kp U_     &kp P_      &kp E_            &kp H_     &kp J_     &kp K_     &kp L_     &kp N_
				&kp ESC     &kp AGRV_  &kp Y_     &kp X_      &kp DOT           &tog GAM2  &kp M_     &kp COMM_	 &kp DOT_   &kp BSPC
												  &kp ENTER   &kp SPACE         &kp TAB    &kp LALT
			>;
		};
		
		/* FOR DEBUGGING:
			bindings = <
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
			                   _____   _____         _____   _____
			>;
		*/
	};
};
