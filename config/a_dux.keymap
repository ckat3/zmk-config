#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/outputs.h>

#include "bepo_bindings.h"

// SETTINGS
#define _MACRO_INTERVAL      3    // tested: 3. how long to wait between key presses
#define _MACRO_TAP_FOR       3    // tested: 3. how long to tap for in macros

// combo: maximum interval between keys to form combo
#define _COMBO_TIMEOUT       18   // tested: 16, 18
#define _COMBO_TIMEOUT_SLOW  50   // tested: 50

// holdtap: how long must hold to not be tap
#define _TAP_TERM_SLOW       300
#define _TAP_TERM            280  //tested: 250, 280
#define _TAP_TERM_FAST       200
#define _TAP_TERM_FASTER     120

// holdtap: how fast must press twice for second to start repeating tap
#define _QUICK_TAP           200

#define _STICKY_TIMEOUT      2000 // tested: 1000+

// LAYERS
#define _L_BASE 0
#define _L_CPWD 1
#define _L_NUM  2
#define _L_SYM  3
#define _L_UTIL 4
#define _L_NAV  5
#define _L_ACNT 6
#define _L_ACCW 7
#define _L_FUNC 8
#define _L_GAME 9
#define _L_GAM2 10

// combos shouldn't work on game layer, to minimize delay
#define _L_ALL_LAYERS   _L_BASE  _L_CPWD  _L_UTIL  _L_SYM  _L_ACNT  _L_ACCW  _L_NUM  _L_NAV  _L_FUNC  _L_GAME  _L_GAM2
#define _L_NOT_GAME     _L_BASE  _L_CPWD  _L_UTIL  _L_SYM  _L_ACNT  _L_ACCW  _L_NUM  _L_NAV  _L_FUNC
#define _L_NOT_CPWD     _L_BASE           _L_UTIL  _L_SYM  _L_ACNT  _L_ACCW  _L_NUM  _L_NAV  _L_FUNC


&lt { // tap for kp, hold for layer
	flavor          = "balanced";
	tapping-term-ms = <_TAP_TERM>;
	quick-tap-ms    = <_QUICK_TAP>;
};

&mt { // hold-tap
	tapping-term-ms = <_TAP_TERM_FASTER>;
	quick-tap-ms    = <_QUICK_TAP>;
};

&sk { // one-shot layer
	release-after-ms = <_STICKY_TIMEOUT>;
	quick-release;
};

/ {
	behaviors {
		#define _POSITIONS_LH   0 1 2 3 4 10 11 12 13 14 20 21 22 23 24 30 31
		#define _POSITIONS_RH   5 6 7 8 9 15 16 17 18 19 25 26 27 28 29 32 33
		#define _ALL_POSITIONS  _POSITIONS_LH  _POSITIONS_RH
		// #define _ALL_POSITIONS 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33

		#define DEFINE_HOLDTAP(NAME, FLAVOR, DELAY, POSITIONS, BINDINGS...) \
			NAME: ht_##NAME { \
				label           = #NAME; \
				flavor          = #FLAVOR; \
				tapping-term-ms = <DELAY>; \
				quick-tap-ms    = <_QUICK_TAP>; \
				bindings        = BINDINGS; \
				 \
				#binding-cells  = <2>; \
				compatible      = "zmk,behavior-hold-tap"; \
				 \
				hold-trigger-key-positions = <POSITIONS>; \
			};

		#define HT(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM, _ALL_POSITIONS, BINDINGS)

		#define HT_FAST(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM_FAST, _ALL_POSITIONS, BINDINGS)

		#define HT_BAL(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, balanced, _TAP_TERM, _ALL_POSITIONS, BINDINGS)

		#define HRMOD_POS(NAME, POSITIONS) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM, POSITIONS, <&kp>, <&kp>)

		#define HT_SLOW(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM_SLOW, _ALL_POSITIONS, BINDINGS)

		// HOME-ROW MODS              // TAP             HOLD
		HT(     ht,     <&kp>, <&kp>) // &kp             &kp
		HT(     htsk,   <&sk>, <&kp>)
		HT(     ltt,    <&mo>, <&kp>) // &kp             hold layer    (inherits tap-preferred from HT)
		HT_BAL( lsk,    <&mo>, <&sk>) // one-shot mod    hold layer
		HT_BAL( lsl,    <&mo>, <&sl>) // one-shot layer  hold layer

		HT_SLOW(htslow, <&kp>, <&kp>)

		// hrm for opposite hand only (used for shift)
		HRMOD_POS(htl, _POSITIONS_RH)
		HRMOD_POS(htr, _POSITIONS_LH)

		// OTHER HOLDTAPS ------------------
		//deactivates capsword, then...                               // PRESS            HOLD
		HT_BAL( ht_cw_L_NAV_SPC,  <&m_mo_cw_L_NAV>,  <&m_cw_SPC>)      // space            hold _L_NAV
		HT_BAL(lsl_cw_L_SYM,     <&m_mo_cw_L_SYM>,  <&m_sk_cw_L_SYM>) // one-shot _L_SYM  hold _L_SYM

		HT_SLOW(ltt_L_UTIL,      <&m_mo_L_UTIL>,    <&kp>)            // &kp              hold _L_UTIL    (inherits tap-preferred from HT)

		// NBSP STUFF (for french) ------------------
		// automatic nbsp on tap
		HT(ht_LGLM, <&kp>, <&m_nbsp_LGLM>)
		HT(ht_RGLM, <&kp>, <&m_nbsp_RGLM>)

		// automatic nbsp on hold
		HT_FAST(ht_COLN, <&m_nbsp_COLN>, <&kp>)
		HT_FAST(ht_SCLN, <&m_nbsp_SCLN>, <&kp>)
		HT_FAST(ht_QMRK, <&m_nbsp_QMRK>, <&kp>)
		HT_FAST(ht_EXCL, <&m_nbsp_EXCL>, <&kp>)
	};

	macros {
		// convenience
		#define M_TAP         &macro_tap
		#define M_TAP_KP      &macro_tap &kp
		#define M_HOLD        &macro_press
		#define M_HOLD_KP     &macro_press &kp
		#define M_REL         &macro_release
		#define M_REL_KP      &macro_release &kp
		#define M_WAIT_REL   <&macro_pause_for_release>

		#define M_HOLD_SHIFT <M_HOLD_KP LSHFT>
		#define M_REL_SHIFT  <M_REL_KP  LSHFT>, <M_REL_KP RSHFT>

		// BASE MACRO -----------------------------
		// all macro names will be prefixed by m_
		#define MACRO(NAME, BINDINGS...) \
			ZMK_MACRO(m_##NAME, \
				tap-ms   = <_MACRO_TAP_FOR>; \
				wait-ms  = <_MACRO_INTERVAL>; \
				bindings = BINDINGS; \
				)

		#define MACRO_TWO_KP(NAME, ONE, TWO) \
			NAME: NAME { \
				compatible = "zmk,behavior-macro-two-param"; \
				label = "M2_##NAME"; \
				#binding-cells = <2>; \
				tap-ms   = <_MACRO_TAP_FOR>; \
				wait-ms  = <_MACRO_INTERVAL>; \
				bindings = <&macro_param_1to1>, <&kp MACRO_PLACEHOLDER>, <&macro_param_2to1>, <&kp MACRO_PLACEHOLDER>; \
			};


		// MACRO_TAP -----------------------------
		// tap whatever command sequence is given
		#define MACRO_TAP(NAME, BINDINGS...) \
			MACRO(NAME, <M_TAP BINDINGS>)


		// MACRO_DIGRAM -----------------------------
		// tap a key, release shift if held, tap another (so can eg hold shift and do &m_Q_U_ to get Qu
		// also defines a capsword version
		#define MACRO_DIGRAM(FIRST, SECOND) \
			MACRO(FIRST##SECOND,                      <M_TAP_KP FIRST>, M_REL_SHIFT, <M_TAP_KP SECOND>) \
			\
			MACRO(cw_##FIRST##SECOND,  M_HOLD_SHIFT,  <M_TAP_KP FIRST>,              <M_TAP_KP SECOND>,  M_REL_SHIFT)



		// TODO -----------------------------
		// this was meant for the eszett, but if it doesn't work i might as well merge it with ACCENT_1.
		#define MACRO_ACCENT_NAMED(NAME, ACCENT, LETTER) \
			MACRO(NAME,      <M_TAP_KP ACCENT>, M_REL_SHIFT,  <M_TAP_KP LETTER>) \
			\
			MACRO(cw_##NAME, <M_TAP_KP ACCENT>, M_HOLD_SHIFT, <M_TAP_KP LETTER>, M_REL_SHIFT)


		#define MACRO_ACCENT_1(ACCENT, LETTER) \
			MACRO_ACCENT_NAMED(ACCENT##LETTER, ACCENT, LETTER)


		#define MACRO_ACCENT_2(ACCENT, FIRST, SECOND) \
			MACRO(     ACCENT##FIRST##SECOND, <M_TAP_KP ACCENT>,               <M_TAP_KP FIRST>, M_REL_SHIFT, <M_TAP_KP SECOND>) \
			\
			MACRO(cw_##ACCENT##FIRST##SECOND, <M_TAP_KP ACCENT>, M_HOLD_SHIFT, <M_TAP_KP FIRST>,              <M_TAP_KP SECOND>,  M_REL_SHIFT)



		// TODO
		// MACRO_ACCENT_NAMED(SZTT,     SZTTMOD_,   S_)
		MACRO_TAP(   SZTT,    &kp RA(S_)  &kp    S_)
		MACRO_TAP(cw_SZTT,    &kp RA(S_)  &kp LS(S_))


		// INCONVENIENT DIGRAMS ------------------
		// also defines a caps version (eg &m_cw_Q_U_)
		MACRO_DIGRAM(Q_, U_)
		MACRO_DIGRAM(B_, J_)


		// ACCENTED LETTERS ------------------
		// also defines a caps version (eg &m_cw_ACUT_A_)
		MACRO_ACCENT_1(ACUT_, A_)
		MACRO_ACCENT_1(ACUT_, I_)
		MACRO_ACCENT_1(ACUT_, O_)
		MACRO_ACCENT_1(ACUT_, U_)

		MACRO_ACCENT_1(CFLX_, A_)
		MACRO_ACCENT_1(CFLX_, E_)
		MACRO_ACCENT_1(CFLX_, I_)
		MACRO_ACCENT_1(CFLX_, O_)
		MACRO_ACCENT_1(CFLX_, U_)

		MACRO_ACCENT_1(GRAV_, E_)
		MACRO_ACCENT_1(GRAV_, O_)
		MACRO_ACCENT_1(GRAV_, U_)

		MACRO_ACCENT_1(TILD_, A_)
		MACRO_ACCENT_1(TILD_, O_)
		MACRO_ACCENT_1(TILD_, N_)
		MACRO_ACCENT_2(TILD_, A_, E_)
		MACRO_ACCENT_2(TILD_, A_, O_)
		MACRO_ACCENT_2(TILD_, O_, E_)

		MACRO_ACCENT_1(TRMA_, I_)


		// NBSP STUFF (for french) ------------------
		MACRO_TAP(nbsp_QMRK,  &kp NBSP_  &kp QMRK_)
		MACRO_TAP(nbsp_EXCL,  &kp NBSP_  &kp EXCL_)
		MACRO_TAP(nbsp_COLN,  &kp NBSP_  &kp COLN_  &kp SPACE)
		MACRO_TAP(nbsp_SCLN,  &kp NBSP_  &kp SCLN_  &kp SPACE)
		MACRO_TAP(nbsp_RGLM,  &kp NBSP_  &kp RGLM_)
		MACRO_TAP(nbsp_LGLM,  &kp LGLM_  &kp NBSP_)


		// LOOSE ACCENTS ------------------
		MACRO_TAP(CFXloos,    &kp CFLX_  &kp SPACE)
		MACRO_TAP(GRVloos,    &kp GRAV_  &kp SPACE)
		MACRO_TAP(TLDloos,    &kp TILD_  &kp SPACE)


		// CAPSWORD ------------------
		// key and turn off capsword
		MACRO_TAP(cw_SPC,  &kp SPACE  &tog _L_CPWD)
		MACRO_TAP(cw_TAB,  &kp TAB    &tog _L_CPWD)
		MACRO_TAP(cw_ENTR, &kp ENTER  &tog _L_CPWD)
		MACRO_TAP(cw_ESC,  &kp ESC    &tog _L_CPWD)

		// hold layer and turn off caps word
		MACRO(mo_cw_L_NAV,   <M_TAP &to _L_NAV>,   M_WAIT_REL,  <M_TAP &to _L_BASE>)
		MACRO(mo_cw_L_SYM,   <M_TAP &to _L_SYM>,   M_WAIT_REL,  <M_TAP &to _L_BASE>)
		MACRO(mo_cw_L_ACNT,  <M_TAP &to _L_ACNT>,  M_WAIT_REL,  <M_TAP &to _L_BASE>)

		// one-shot layer and turn off caps word
		MACRO(sk_cw_L_SYM,   <M_TAP &to _L_BASE  &sk _L_SYM>)
		MACRO(sk_cw_L_ACNT,  <M_TAP &to _L_BASE  &sk _L_ACNT>)


		// UTIL LAYER ------------------
		#define SUPER       &kp LSHIFT  &kp LCTRL  &kp LALT 
		#define SHIFT_CTRL  &kp LSHIFT  &kp LCTRL 
		#define SHIFT_ALT   &kp LSHIFT             &kp LALT 

		MACRO(mo_L_UTIL, <M_TAP  &tog _L_UTIL>,  <M_HOLD  SUPER>,  M_WAIT_REL,  <M_TAP  &tog _L_UTIL  &to _L_BASE>,  <M_REL  SUPER>)

		MACRO( utl_BACK,  <M_REL SUPER>,       <M_TAP_KP  C_AC_BACK   >,  <M_HOLD SUPER>)
		MACRO( utl_FRWD,  <M_REL SUPER>,       <M_TAP_KP  C_AC_FORWARD>,  <M_HOLD SUPER>)
																				  
		MACRO(  utl_TAB,  <M_REL SUPER>,       <M_TAP_KP     TAB >,       <M_HOLD SUPER>)
		MACRO( utl_STAB,  <M_REL SUPER>,       <M_TAP_KP  LS(TAB)>,       <M_HOLD SUPER>)
		MACRO( utl_GTAB,  <M_REL SUPER>,       <M_TAP_KP  LG(TAB)>,       <M_HOLD SUPER>)	
		
		MACRO( utl_ATAB,  <M_REL SHIFT_CTRL>,  <M_TAP_KP     TAB >)
		MACRO(utl_SATAB,  <M_REL SHIFT_CTRL>,  <M_TAP_KP  LS(TAB)>)
		MACRO( utl_CTAB,  <M_REL SHIFT_ALT >,  <M_TAP_KP     TAB >)
		MACRO(utl_SCTAB,  <M_REL SHIFT_ALT >,  <M_TAP_KP  LS(TAB)>)
		
		MACRO( utl_SPC,  <M_REL SUPER>,        <M_TAP_KP  SPACE>,         <M_HOLD SUPER>)	
		
	};
	
	

	combos {
		compatible = "zmk,combos";

		#define DEFINE_COMBO(NAME, LAYERS, POSITIONS, TIMEOUT, BINDINGS...) \
			combo_##NAME { \
				layers        = <LAYERS>; \
				key-positions = <POSITIONS>; \
				timeout-ms    = <TIMEOUT>; \
				bindings      =  BINDINGS; \
			};


		// when not defining layers, will default to _L_NOT_GAME
		// TODO: ok to omit line breaks between defs?
		// TODO: all combos define layers?
		#define COMBO(LAYERS, BINDINGS, POSITIONS, RANDOM_NAME) \
			DEFINE_COMBO(RANDOM_NAME,    LAYERS,  POSITIONS,  _COMBO_TIMEOUT,  <BINDINGS>)

		#define COMBO_KP(LAYERS, KEY, SUFFIX, POSITIONS) \
			DEFINE_COMBO(  KEY##SUFFIX,  LAYERS,  POSITIONS,  _COMBO_TIMEOUT,  <&kp KEY>)
			
		#define COMBO_MACRO(LAYERS, MACRO, SUFFIX, POSITIONS) \
			DEFINE_COMBO(MACRO##SUFFIX,  LAYERS,  POSITIONS,  _COMBO_TIMEOUT,  <&m_##MACRO>)

		// #define COMBO_KP_CTRL(LAYERS, KEY, SUFFIX, POSITIONS) \
			// DEFINE_COMBO(ctrl_##KEY##SUFFIX, LAYERS,  POSITIONS,  _COMBO_TIMEOUT,       <&sk LCTRL>, <&kp KEY>)




	/*
	    0   1   2   3      4 | 5      6   7   8   9
	    10  11  12  13    14 | 15    16  17  18  19
	    20  21  22  23    24 | 25    26  27  28  29
							 |
	                   30 31 | 32 33
	*/

		COMBO_KP(_L_NOT_GAME,  SPACE,l,           11 12 13)
		COMBO_KP(_L_NOT_GAME,  SPACE,r,           16 17 18)

		// backspace and del, with and wo ctrl
		COMBO_KP(_L_NOT_GAME,         BSPC,,      11 12)
		COMBO(   _L_NOT_GAME,  &kp LC(BSPC),      17 18, rnd_name_dljsdiooooisrt)
		COMBO_KP(_L_NOT_GAME,         DEL,,       21 22)
		COMBO(   _L_NOT_GAME,  &kp LC(DEL),       27 28, rnd_name_dljsdaioaort)
		COMBO(   _L_NOT_GAME,  &kp LC(Z_),        20 21, rnd_name_dljoiadiqsrt)

		// one-shot shift on both thumb keys at once
		COMBO(_L_NOT_GAME,  &lsk _L_FUNC LSHIFT,  30 31, rnd_name_dljsdiqsrt)
		COMBO(_L_NOT_GAME,  &sk          RSHIFT,  32 33, rnd_name_sqljqrjqsl)

		// TODO  merge these?
		COMBO_MACRO(_L_BASE,  Q_U_,,              26 27) /* qu */
		COMBO_MACRO(_L_BASE,  TILD_A_E_,,         13 30) /* ãe */
		COMBO_MACRO(_L_BASE,  TILD_A_O_,,         13 11) /* ão */
		COMBO_MACRO(_L_BASE,  TILD_O_E_,,         11 30) /* õe */
												  
		COMBO_MACRO(_L_CPWD,  cw_Q_U_,,           26 27) /* QU */
		COMBO_MACRO(_L_CPWD,  cw_TILD_A_E_,,      13 30) /* ÃE */
		COMBO_MACRO(_L_CPWD,  cw_TILD_A_O_,,      13 11) /* ÃO */
		COMBO_MACRO(_L_CPWD,  cw_TILD_O_E_,,      11 30) /* ÕE */
												  
		// tab, enter, esc                        
		COMBO_KP(_L_NOT_CPWD,  TAB,,              12 13)
		COMBO_KP(_L_NOT_CPWD,  ENTER,,            16 17)
		COMBO_KP(_L_NOT_CPWD,  ESC,,              10 11)
												  
		COMBO_MACRO(_L_CPWD,  cw_TAB,,            12 13)
		COMBO_MACRO(_L_CPWD,  cw_ENTR,,           16 17)
		COMBO_MACRO(_L_CPWD,  cw_ESC,,            10 11)

		COMBO(_L_FUNC, &sys_reset,                 0  4, rnd_name_aiouaiouaiou)
		COMBO(_L_FUNC, &bootloader,               20 24, rnd_name_ayuqaioueaio)
		COMBO(_L_FUNC, &tog _L_GAME,               4 14, rnd_name_aiouayopaipo)
		COMBO(_L_FUNC, &tog _L_GAM2,              14 24, rnd_name_aiopoappyaio)
	};

	keymap {
		compatible = "zmk,keymap";

        // READABILITY ------------------
		#define _________     &none // could still be filled
		#define _____         &none //
		
		#define impossible    &none // physically impossible

		#define C_S_ESC          LC(LS(ESC))    // task manager
		#define PASTEPLAIN   &kp LC(LG(LA(V_))) // power toys plaintext paste
		#define RESET_RIGHT  &sys_reset   	    // mnemonic (bc when called on the left it resets both)


		// HOME-ROW MODS ------------------
		#define HMLS    &htl     LSHIFT // left shift only works for keys on right hand
		#define HMRS    &htr     RSHIFT // rite shift only works for keys on lefft hand
		#define HMLC    &ht      LCTRL
		#define HMRC    &ht      RCTRL
		#define HMLA    &ht      LALT
		#define HMRA    &ht      RALT
		#define HMLG    &htslow  LGUI // i kept holding GUI by accident,
		#define HMRG    &htslow  RGUI // so i made it slower


		 // STICKY MODS IN NAV LAYER ------------------
		#define SKLS    &htsk   LSHIFT
		#define SKLC    &htsk   LCTRL
		#define SKLA    &htsk   LALT
		#define SKLG    &htsk   LGUI


		// HOLDTAP SYMBOLS ------------------
		// □ = space, ■ = nbsp, () = explicited later   // HOLD  TAP
		#define DLLR_EURO   &htslow    EURO_  DLLR_     //  €     $
		#define EQUL_DIFF   &htslow    DIFF_  EQUL_     //  ≠     =
		#define IEXCL_IQMRK &htslow    IEXC_  IQMR_     //  ¿     ¡
		#define EXCL_QMRK   &htslow    EXCL_  QMRK_     //  ?     !

		#define NBSP_QMRK   &ht_QMRK   0      QMRK_     // ■?    (?)
		#define NBSP_EXCL   &ht_EXCL   0      EXCL_     // ■!    (!)
		#define DOT_COLN    &ht_COLN   0      DOT_      // ■:□   (.)
		#define COMM_SCLN   &ht_SCLN   0      COMM_     // ■;□   (,)

		#define NBSP_LGLM   &ht_LGLM   LGLM_  0         // («)   «■
		#define NBSP_RGLM   &ht_RGLM   RGLM_  0         // (»)    ■»


		// UTIL LAYER ------------------
		#define UTLAYR  &ltt_L_UTIL 0


		// THUMB KEYS ------------------
		#define LT_NUM_E       &lt    _L_NUM  E_
		#define LT_NUM_E_CW    &lt    _L_NUM  LS(E_)

		#define LSL_SYM        &lsl   _L_SYM  _L_SYM
		#define LSL_SYM_CW     &lsl_cw_L_SYM  0 0

		#define LSL_ACNT       &lsl  _L_ACNT  _L_ACNT
		#define LSL_ACCW       &lsl  _L_ACCW  _L_ACCW

		#define LT_NAV_SPC     &lt   _L_NAV SPC
		#define LT_NAV_SPC_CW  &ht_cw_L_NAV_SPC 0 0


		// -------------------
		// BASE LAYER
		// -------------------

		base_layer {
			bindings = <
				&kp    Q_    HMLC  MIN_       &kp  Y_      DOT_COLN       NBSP_QMRK         &kp K_         &kp  C_      &kp  H_      &kp  W_      &kp  J_
				UTLAYR U_    HMLA  O_         HMLC I_      HMLS A_        &kp F_            &kp G_         HMRS T_      HMRC R_      HMRA S_      &kp  N_
				HMLG   Z_    HMRA  EACT_      &kp  P_      COMM_SCLN      &kp X_            &kp V_         &kp  D_      &kp  M_      &kp  L_      HMRG B_
				//
													       LT_NUM_E      LSL_SYM            LSL_ACNT       LT_NAV_SPC
			>;
		};

		caps_word_layer { // TODO leave layer when using home row mods
			bindings = <
				&kp  LS(Q_)	 HMRA  MIN_       &kp  LS(Y_)  &kp  DOT_      EXCL_QMRK          &kp LS(K_)    &kp  LS(C_)  &kp  LS(H_)  &kp  LS(W_)  &kp  LS(J_)
				HMLG LS(U_)	 HMLA  LS(O_)	  HMLC LS(I_)  HMLS LS(A_)    &kp LS(F_)         &kp LS(G_)    HMRS LS(T_)  HMRC LS(R_)  HMRA LS(S_)  HMRG LS(N_)
				&kp  LS(Z_)	 HMLC  LS(EACT_)  &kp  LS(P_)  &kp  COMM_     &kp LS(X_)         &kp LS(V_)    &kp  LS(D_)  &kp  LS(M_)  &kp  LS(L_)  &kp  LS(B_)
				//
														   LT_NUM_E_CW    LSL_SYM_CW         LSL_ACCW      LT_NAV_SPC_CW
			>;
		};



		// -------------------
		// LH AUX LAYERS
		// -------------------

		num_layer {
			bindings = <
				&kp MIN_     &kp N7_      &kp N8_     &kp N9_       EXCL_QMRK         DLLR_EURO       &kp  LBRK_   &kp  RBRK_   &kp  HASH_   &kp  PCNT_
				&kp N0_      &kp N1_      &kp N2_     &kp N3_       &kp DOT_          &kp COLN_       HMRS PLUS_   HMRC MIN_    HMLA STAR_   HMRG FSLA_
				&kp SPC      &kp N4_      &kp N5_     &kp N6_       &kp COMM_         &kp SCLN_       &kp  LT_     &kp  GT_     EQUL_DIFF    &kp  BSLA_
				//
				                                    impossible     impossible         &kp ULIN_       &kp SPC
			>;
		};

		sym_layer {
			bindings = <
				&kp  PIPE_   &kp  AMPR_   &kp  AT_    &kp  OE_      NBSP_EXCL         _________       &kp  LBRK_   &kp  RBRK_   _________    DLLR_EURO
				SKLG LCUR_   SKLA RCUR_   SKLC LPAR_  SKLS RPAR_    &kp MDSH_         _________       _________    &m_CFXloos   &m_GRVloos   &m_TLDloos
				&kp  NDSH_   &kp  MDSH_   NBSP_LGLM   NBSP_RGLM     _________         &kp AE_         HMRS _____   HMRC _____   HMRA _____   HMRG _____
				//
								                      _________     &kp ESC           &kp NBSP_       &kp  SPC
													            // double tap //
			>;
		};

		utility_layer {
			bindings = <
				_________   _________    &m_utl_BACK   &m_utl_FRWD     _____           _____    _________   _________  _________  _________
				_________   &m_utl_GTAB  &m_utl_SATAB  &m_utl_ATAB     _____           _____    _________   _________  _________  _________
				_________   &kp LA(F4)   &m_utl_SCTAB  &m_utl_CTAB     _____           _____    _________   _________  _________  _________
				//
			                                           &m_utl_STAB     &m_utl_SPC      _____    _____
			>;
		};
		


		// -------------------
		// RH AUX LAYERS
		// -------------------

		nav_layer {
			bindings = <
				_________     _________     _________     &kp  LG(V_)     &kp C_S_ESC         _________       HMLS LC(HOME)   HMLC PG_DN   HMLA PG_UP   HMRG LC(END)
				&kp  LC(Y_)  HMLA INSERT   HMLC PSCRN     HMLS PSBRK      &kp CAPS           &tog _L_CPWD     &kp  LC(LEFT)   &kp  DOWN    &kp  UP	    &kp  LC(RIGHT)
				HMLG LC(Z_)  HMRA LC(X_)   &kp  LC(C_)    &kp  LC(V_)     PASTEPLAIN           _________      &kp  HOME       &kp  LEFT    &kp  RIGHT   &kp  END
				//
												          _________       _________           impossible      impossible
			>;
		};

		#define MACRO_ROW_3(PREFIX, ONE, TWO, THREE)               &m_##PREFIX##ONE &m_##PREFIX##TWO &m_##PREFIX##THREE
		#define MACRO_ROW_4(PREFIX, ONE, TWO, THREE, FOUR)         MACRO_ROW_3(PREFIX, ONE, TWO, THREE) &m_##PREFIX##FOUR
		#define MACRO_ROW_5(PREFIX, ONE, TWO, THREE, FOUR, FIVE)   MACRO_ROW_4(PREFIX, ONE, TWO, THREE, FOUR) &m_##PREFIX##FIVE
		
		accent_layer {
			bindings = <
 MACRO_ROW_4(,  CFLX_U_,  CFLX_O_,  CFLX_I_,  CFLX_A_)  IEXCL_IQMRK        _________    &kp  CCED_  &kp  APST_  &kp  QUOT_   &m_B_J_
 MACRO_ROW_5(,  ACUT_U_,  ACUT_O_,  ACUT_I_,  ACUT_A_,  TILD_A_)           _________    HMRS ACUT_  HMRC CFLX_  HMLA GRAV_   &m_TILD_N_
 MACRO_ROW_3(,  GRAV_U_,  TILD_O_,  TRMA_I_) &kp AGRV_  _________          _________    &kp  TRMA_  _________     &m_SZTT   &kp TILD_
				//
												    &m_CFLX_E_    &kp EGRV_          _________    _________
													                             // double tap //
			>;
		};

		accent_caps_layer {
			bindings = <
 MACRO_ROW_4(cw_, CFLX_U_,   CFLX_O_,    CFLX_I_,      CFLX_A_)  _________       _________    &kp  LS(CCED_)  &kp  APST_  &kp   QUOT_  &m_cw_B_J_
 MACRO_ROW_5(cw_, ACUT_U_,   ACUT_O_,    ACUT_I_,      ACUT_A_,   TILD_A_)       _________    HMRS    ACUT_   HMRC CFLX_  HMLA  GRAV_  &m_cw_TILD_N_
 MACRO_ROW_3(cw_, GRAV_U_,   TILD_O_,    TRMA_I_)  &kp LS(AGRV_)  _________      _________    &kp     TRMA_   _________   &m_cw_SZTT   &kp   TILD_
				//
											    &m_cw_CFLX_E_  &kp LS(EGRV_)     _________    _________
													                         // double tap //
			>;
		};



		// -------------------
		// FUNCTION LAYER
		// -------------------

		func_layer {
			bindings = <
				&bt  BT_SEL 3   &bt  BT_SEL 0   &bt  BT_SEL 1   &bt  BT_SEL 2  &bt BT_CLR           RESET_RIGHT   &kp F7  &kp F8  &kp F9  &kp F12
				HMLG C_BRI_UP   HMLA C_NEXT     HMLC C_VOL_UP   HMLS C_PP  	   &kp LSLCK            &out OUT_BLE  &kp F1  &kp F2  &kp F3  &kp F10
				&kp  C_BRI_DN   &kp  C_PREV     &kp  C_VOL_DN   &kp  C_MUTE    &kp LNLCK            &out OUT_USB  &kp F4  &kp F5  &kp F6  &kp F11
				//
															    impossible     impossible           &kp LSHIFT    &kp LALT
			>;
		};



		// -------------------
		// GAMING LAYERS
		// -------------------

		game_layer {
			bindings = <
				&kp Q_      &kp MIN_   &kp Y_     &kp DOT_     &kp R_            &kp   K_      &kp C_     &kp H_     &kp W_     &kp J_
				&kp U_      &kp O_     &kp I_     &kp A_       &kp F_            &kp   G_      &kp LEFT   &kp UP     &kp RIGHT  &kp N_
				&kp ESC     &kp S_     &kp P_     &kp COMM_    &kp X_            &tog _L_GAME  &kp D_     &kp DOWN   &kp L_     &kp B_
				//
											      &kp ENTER    &kp SPACE         &kp  TAB      &kp LALT
			>;
		};

		game_layer_2 {
			bindings = <
				&kp LSHIFT  &kp A_     &kp EACT_  &kp I_      &kp O_            &kp   Y_      &kp U_     &kp I_     &kp O_     &kp P_
				&kp LCTRL   &kp B_     &kp U_     &kp P_      &kp E_            &kp   H_      &kp J_     &kp K_     &kp L_     &kp N_
				&kp ESC     &kp AGRV_  &kp Y_     &kp X_      &kp DOT           &tog _L_GAM2  &kp M_     &kp COMM_  &kp DOT_   &kp BSPC
				//
												  &kp ENTER   &kp SPACE         &kp  TAB      &kp LALT
			>;
		};



		// -------------------
		// DEBUGGING LAYER
		// -------------------

		/* FOR DEBUGGING:
			bindings = <
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
			                   _____   _____         _____   _____
			>;
		*/
	};
};