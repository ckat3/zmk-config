#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/outputs.h>

#include "bepo_bindings.h"

// SETTINGS
#define _MACRO_INTERVAL   3  // max 5
#define _MACRO_TAP_FOR    3  // max 5 

#define _COMBO_TIMEOUT    16 // min 16

#define _TAP_TERM_SLOW    300
#define _TAP_TERM         300 //default 250
#define _TAP_TERM_QUICK   200
#define _TAP_TERM_BLAZIN  120

#define _QUICK_TAP        200

#define _STICKY_TIMEOUT   2000 // min 1000

// LAYERS
#define BASE 1 
#define CPWD 2 
#define NUM  3 
#define UTIL 4 
#define SYM  5 
#define ACNT 6 
#define ACCP 7 
#define NAV  8 
#define FUNC 9 
#define GAME 10
#define GAM2 11

// combos shouldn't work on game layer, to minimize delay
#define ALL_LAYERS  BASE CPWD UTIL SYM ACNT ACCP NUM NAV FUNC GAME GAM2
#define NOT_GAME    BASE CPWD UTIL SYM ACNT ACCP NUM NAV FUNC
#define NOT_CPWD    BASE      UTIL SYM ACNT ACCP NUM NAV FUNC

&lt {
	tapping-term-ms = <_TAP_TERM>;
	flavor = "balanced";
};

&mt {
	tapping-term-ms = <_TAP_TERM_BLAZIN>;
};

&sk {
	release-after-ms = <_STICKY_TIMEOUT>;
	quick-release;
};

/ { 
	behaviors {
		#define DEFINE_HOLDTAP(NAME, FLAVOR, DELAY, BINDINGS...) \
			NAME: ht_##NAME { \
				label = #NAME; \
				flavor = #FLAVOR; \
				tapping-term-ms = <DELAY>; \
				bindings = BINDINGS; \
				#binding-cells = <2>; \
				compatible = "zmk,behavior-hold-tap"; \
				quick-tap-ms = <_QUICK_TAP>;
				
		#define HOLDTAP(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM, BINDINGS) \
			};
				
		#define HOLDTAP_QUICK(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM_QUICK, BINDINGS) \
			};
				
		#define HOLDTAP_BAL(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, balanced, _TAP_TERM, BINDINGS) \
			};
			
		#define HRMOD_POS(NAME, POSITIONS) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM, <&kp>, <&kp>) \
					hold-trigger-key-positions = <POSITIONS>; \
			};
		
		#define HOLDTAP_SLOW(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM_SLOW, BINDINGS) \
			};
		
		// HOLDTAP(ht_qu,   <&kp>, <&m_Q_U_>)    // qu              &kp
		// HOLDTAP(ht_aact, <&kp>, <&m_ACUT_A_>) // á               &kp
		// HOLDTAP(ht_uact, <&kp>, <&m_ACUT_U_>) // ú               &kp
		// HOLDTAP(ht_iact, <&kp>, <&m_ACUT_I_>) // í               &kp

		
		// home-row mods               // PRESS           HOLD
		HOLDTAP(      ht,     <&kp>, <&kp>) // &kp             &kp
		HOLDTAP_SLOW( htslow, <&kp>, <&kp>)
		HOLDTAP(      htsk,   <&sk>, <&kp>) // &kp             sticky layer
		HOLDTAP_BAL(  lsk,    <&mo>, <&sk>) // one-shot mod    hold layer
		HOLDTAP_BAL(  lsl,    <&mo>, <&sl>) // one-shot layer  hold layer
		HOLDTAP_BAL(  htcpwd, <&mo>, <&m_spc_togcpwd>) // space then desactivate capsword    hold layer

		// hrm for opposite hand only (used for shift)
		HRMOD_POS(htl, 5 6 7 8 9 15 16 17 18 19 25 26 27 28 29 32 33)
		HRMOD_POS(htr, 0 1 2 3 4 10 11 12 13 14 20 21 22 23 24 30 31)
		
		// automatic nbsp on tap
		HOLDTAP(ht_lglm, <&kp>, <&m_nbsp_lglm>)
		HOLDTAP(ht_rglm, <&kp>, <&m_nbsp_rglm>)
		
		// automatic nbsp on hold
		HOLDTAP_QUICK(ht_coln, <&m_nbsp_coln>, <&kp>)
		HOLDTAP_QUICK(ht_scln, <&m_nbsp_scln>, <&kp>)
		HOLDTAP_QUICK(ht_qmrk, <&m_nbsp_qmrk>, <&kp>)
		HOLDTAP_QUICK(ht_excl, <&m_nbsp_excl>, <&kp>)
	};

	macros {
		// #define RELEASE_SHIFT <&macro_release &kp LSHFT &kp RSHFT>
		
		#define MACRO(NAME, BINDINGS...) \
			ZMK_MACRO(m_##NAME, \
				tap-ms   = <_MACRO_TAP_FOR>; \
				wait-ms  = <_MACRO_INTERVAL>; \
				bindings = BINDINGS; \
				)
				
		// MACRO_SIMPLE names the macro "m_FIRST##SECOND", eg "m_Q_U_"
		#define MACRO_SIMPLE(FIRST, SECOND) \
			MACRO(FIRST##SECOND, <&macro_tap &kp FIRST &kp SECOND>)
			// MACRO(FIRST##SECOND, <&macro_tap &kp FIRST>, RELEASE_SHIFT, <&macro_tap &kp SECOND>)		

			
		// #define MACRO_SIMPLE_SHIFT(FIRST, SECOND) \
		// 	MACRO(cp_##FIRST##SECOND, <&macro_tap &kp FIRST &kp SECOND>)
			
		// #define MACRO_ACCENT(FIRST, SECOND) \
		// 	MACRO_SIMPLE( FIRST, SECOND ) \
		// 	MACRO_SIMPLE_SHIFT(FIRST, SECOND)
		// #define MACRO_ACCENT(FIRST, SECOND) \
			// MACRO(FIRST##SECOND, <&macro_tap &kp FIRST &kp SECOND>)
			
	
		// accented letters
		// MACRO_ACCENT(ACUT_, A_)
		// MACRO_ACCENT(ACUT_, I_)
		// MACRO_ACCENT(ACUT_, O_)
		// MACRO_ACCENT(ACUT_, U_)
		
		// MACRO_ACCENT(CFLX_, A_)
		// MACRO_ACCENT(CFLX_, E_)
		// MACRO_ACCENT(CFLX_, I_)
		// MACRO_ACCENT(CFLX_, O_)
		// MACRO_ACCENT(CFLX_, U_)
		
		// MACRO_ACCENT(GRAV_, E_)
		// MACRO_ACCENT(GRAV_, O_)
		// MACRO_ACCENT(GRAV_, U_)
		
		// MACRO_ACCENT(TILD_, A_)
		// MACRO_ACCENT(TILD_, O_)
		// MACRO_ACCENT(TILD_, N_)
		
		// MACRO_ACCENT(TRMA_, I_)
		
		MACRO_SIMPLE(ACUT_, A_)
		MACRO_SIMPLE(ACUT_, I_)
		MACRO_SIMPLE(ACUT_, O_)
		MACRO_SIMPLE(ACUT_, U_)
		
		MACRO_SIMPLE(CFLX_, A_)
		MACRO_SIMPLE(CFLX_, E_)
		MACRO_SIMPLE(CFLX_, I_)
		MACRO_SIMPLE(CFLX_, O_)
		MACRO_SIMPLE(CFLX_, U_)
		
		MACRO_SIMPLE(GRAV_, O_)
		MACRO_SIMPLE(GRAV_, U_)
		
		MACRO_SIMPLE(TILD_, A_)
		MACRO_SIMPLE(TILD_, O_)
		MACRO_SIMPLE(TILD_, N_)
		
		MACRO_SIMPLE(TRMA_, I_)
		
		// // caps accented letters		
		MACRO(cp_ACUT_A_,      <&macro_tap  &kp ACUT_  &kp LS(A_)>)
		MACRO(cp_ACUT_I_,      <&macro_tap  &kp ACUT_  &kp LS(I_)>)
		MACRO(cp_ACUT_O_,      <&macro_tap  &kp ACUT_  &kp LS(O_)>)
		MACRO(cp_ACUT_U_,      <&macro_tap  &kp ACUT_  &kp LS(U_)>)
					   
		MACRO(cp_CFLX_A_,      <&macro_tap  &kp CFLX_  &kp LS(A_)>)
		MACRO(cp_CFLX_E_,      <&macro_tap  &kp CFLX_  &kp LS(E_)>)
		MACRO(cp_CFLX_I_,      <&macro_tap  &kp CFLX_  &kp LS(I_)>)
		MACRO(cp_CFLX_O_,      <&macro_tap  &kp CFLX_  &kp LS(O_)>)
		MACRO(cp_CFLX_U_,      <&macro_tap  &kp CFLX_  &kp LS(U_)>)
					   
		MACRO(cp_GRAV_E_,      <&macro_tap  &kp GRAV_  &kp LS(E_)>)
		MACRO(cp_GRAV_O_,      <&macro_tap  &kp GRAV_  &kp LS(O_)>)
		MACRO(cp_GRAV_U_,      <&macro_tap  &kp GRAV_  &kp LS(U_)>)
					   
		MACRO(cp_TILD_A_,      <&macro_tap  &kp TILD_  &kp LS(A_)>)
		MACRO(cp_TILD_O_,      <&macro_tap  &kp TILD_  &kp LS(O_)>)
		MACRO(cp_TILD_N_,      <&macro_tap  &kp TILD_  &kp LS(N_)>)
					   
		MACRO(cp_TRMA_I_,      <&macro_tap  &kp TRMA_  &kp LS(I_)>)
		
		// qu bj (shortcuts for inconvenient sequences)
		MACRO_SIMPLE(Q_, U_)
		MACRO_SIMPLE(B_, J_)
		
		// caps bj (shortcuts for inconvenient sequences)
		MACRO(cp_qu,        <&macro_tap  &kp LS(Q_) &kp LS(U_)>)
		MACRO(cp_bj,        <&macro_tap  &kp LS(B_) &kp LS(J_)>)
		MACRO(cp_tl_n,      <&macro_tap  &kp TILD_ &kp LS(N_)>) 
		
		// ãe ão õe		
		MACRO(ae,           <&macro_tap  &kp TILD_  &kp A_  &kp E_>)
		MACRO(ao,           <&macro_tap  &kp TILD_  &kp A_  &kp O_>)
		MACRO(oe,           <&macro_tap  &kp TILD_  &kp O_  &kp E_>)
		MACRO(cp_ae,        <&macro_tap  &kp TILD_  &kp LS(A_)  &kp LS(E_)>)
		MACRO(cp_ao,        <&macro_tap  &kp TILD_  &kp LS(A_)  &kp LS(O_)>)
		MACRO(cp_oe,        <&macro_tap  &kp TILD_  &kp LS(O_)  &kp LS(E_)>)
		
		// ß
		MACRO(eszett,       <&macro_tap  &kp RA(S_)  &kp S_>)		
		MACRO(cp_sztt,      <&macro_tap  &kp RA(S_)  &kp LS(S_)>)

		// :;?!«» with nbsp	
		MACRO(nbsp_qmrk,    <&macro_tap  &kp LS(SPACE)  &kp LS(QMRK_)  &kp SPACE>)
		MACRO(nbsp_excl,    <&macro_tap  &kp LS(SPACE)  &kp LS(EXCL_)  &kp SPACE>)
		MACRO(nbsp_coln,    <&macro_tap  &kp LS(SPACE)  &kp LS(DOT_)   &kp SPACE>)
		MACRO(nbsp_scln,    <&macro_tap  &kp LS(SPACE)  &kp LS(COMM_)  &kp SPACE>)
		MACRO(nbsp_rglm,    <&macro_tap  &kp LS(SPACE)  &kp RGLM_>)
		MACRO(nbsp_lglm,    <&macro_tap  &kp LGLM_      &kp LS(SPACE)>)
		
		// loose ^ and `
		MACRO(cfxloos,      <&macro_tap  &kp CFLX_  &kp SPACE>)
		MACRO(grvloos,      <&macro_tap  &kp GRAV_  &kp SPACE>)
		
		// key and turn off capsword
		MACRO(spc_togcpwd,  <&macro_tap  &kp SPACE  &tog CPWD>)
		MACRO(tab_togcpwd,  <&macro_tap  &kp TAB    &tog CPWD>)
		MACRO(entr_togcpwd, <&macro_tap  &kp ENTER  &tog CPWD>)
		MACRO(esc_togcpwd,  <&macro_tap  &kp ESC  &tog CPWD>)
		
		MACRO(cut_all,   <&macro_tap  &kp LC(A_) &kp LS(X_)>)
		MACRO(copy_all,  <&macro_tap  &kp LC(A_) &kp LS(C_)>)
		MACRO(paste_all, <&macro_tap  &kp LC(A_) &kp LS(V_)>)
	};
			  
	combos {
		compatible = "zmk,combos";
		
		#define DEFINE_COMBO(LAYERS, BINDINGS, POSITIONS, NAME) \
			combo_##NAME { \
				layers = <LAYERS>; \
				bindings = <BINDINGS>; \
				key-positions = <POSITIONS>; \
				timeout-ms = <_COMBO_TIMEOUT>; \
			};
		
		// when not defining layers, will default to NOT_GAME
		// TODO: ok to omit line breaks between defs?
		// TODO: all combos define layers
		#define COMBO(BINDINGS, POSITIONS, NAME) \
			DEFINE_COMBO(NOT_GAME, BINDINGS, POSITIONS, NAME)
			
		#define COMBO_LAYER(LAYERS, BINDINGS, POSITIONS, NAME) \
			DEFINE_COMBO(LAYERS, BINDINGS, POSITIONS, NAME)

		// single key press
		#define COMBO_KP(KEY, SUFFIX, POSITIONS) \
			DEFINE_COMBO(NOT_GAME, &kp KEY, POSITIONS, KEY##SUFFIX)	
			
		#define COMBO_KP_LAYER(KEY, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS, &kp KEY, POSITIONS, KEY##SUFFIX)
		
		// macrco
		#define COMBO_MACRO(MACRO, POSITIONS) \
			DEFINE_COMBO(NOT_GAME, &m_##MACRO, POSITIONS, MACRO)
			
		#define COMBO_MACRO_LAYER(MACRO, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS, &m_##MACRO, POSITIONS, MACRO##SUFFIX)
		
	/*
	    0   1   2   3      4 | 5      6   7   8   9
	    10  11  12  13    14 | 15    16  17  18  19
	    20  21  22  23    24 | 25    26  27  28  29
							 |
	                   30 31 | 32 33
					   
					   
	     0  11  12  13  |  16  17  18  9
	    10  21  22  23  |  26  27  28  19
					    |
	              30 31 | 32 33
	*/
	
		
				
		COMBO_KP(SPACE,l,         11 12 13)
		COMBO_KP(SPACE,r,         16 17 18)
		
		// fake tab
		COMBO(&kp SPACE &kp SPACE &kp SPACE &kp SPACE, 10 11 12 13,       gslqaiogrnqsl) // whatever name)
		COMBO(&kp SPACE &kp SPACE &kp SPACE &kp SPACE, 15 16 17 18,       rgsaiornqsj)
		
		
		COMBO_KP(BSPC,,           11 12)
		COMBO_KP(DEL,,            21 22)
		COMBO(&kp LC(BSPC),       17 18,       gslqgrnqsl) // whatever name
		COMBO(&kp LC(DEL),        27 28,       rgsrnqsj)
				
		COMBO(&lsk FUNC LSHIFT,   30 31,       dljsdqsrt)
		COMBO(&sk  RSHIFT,        32 33,       sqljqrjqsl)
		
		COMBO_MACRO_LAYER(Q_U_,,  26 27, BASE)
		COMBO_MACRO_LAYER(ae,,    13 30, BASE)
		COMBO_MACRO_LAYER(ao,,    13 11, BASE)
		COMBO_MACRO_LAYER(oe,,    11 30, BASE)
		
		COMBO_MACRO_LAYER(cp_qu,, 26 27, CPWD)
		COMBO_MACRO_LAYER(cp_ae,, 13 30, CPWD)
		COMBO_MACRO_LAYER(cp_ao,, 13 11, CPWD)
		COMBO_MACRO_LAYER(cp_oe,, 11 30, CPWD)
		
		COMBO_KP_LAYER(TAB,,      12 13, NOT_CPWD)
		COMBO_KP_LAYER(ENTER,,    16 17, NOT_CPWD)
		COMBO_KP_LAYER(ESC,,      10 11, NOT_CPWD)
		COMBO_MACRO_LAYER(tab_togcpwd,,  12 13, CPWD)
		COMBO_MACRO_LAYER(entr_togcpwd,, 16 17, CPWD)
		COMBO_MACRO_LAYER(esc_togcpwd,,  10 11, CPWD)
		
		
		combo_ctrlz {
			bindings = <&kp LC(Z_)>;
			key-positions = <20 21>;
			timeout-ms = <_COMBO_TIMEOUT>;
		};
		
		combo_reset_left {
			bindings = <&sys_reset>;
			key-positions = <0 4>;
			layers = <FUNC>;
			timeout-ms = <_COMBO_TIMEOUT>;
		};
		
		combo_bootloader {
			bindings = <&bootloader>;
			key-positions = <20 24>;
			layers = <FUNC>;
			timeout-ms = <_COMBO_TIMEOUT>;
		};
		
		combo_game_layer {
			bindings = <&tog GAME>;
			key-positions = <4 14>;
			layers = <FUNC>;
			timeout-ms = <_COMBO_TIMEOUT>;
		};
		
		combo_game_2_layer {
			bindings = <&tog GAME>;
			key-positions = <14 24>;
			layers = <FUNC>;
			timeout-ms = <_COMBO_TIMEOUT>;
		};
	};

	keymap {
		compatible = "zmk,keymap";
		
		#define _trans_        &trans
		#define _____        &none
		#define _________   &none
		
		#define PASTEPLAIN       LC(LG(LA(V_))) // power toys plaintext paste (no &kp bc used in &ht)
		// #define C_S_DEL     &kp  LC(LS(DEL))    // task manager
		#define RESET_LEFT  &sys_reset
		
		// home-row mods
		#define HMLS    &htl    LSHIFT
		#define HMRS    &htr    RSHIFT
		#define HMLC    &ht     LCTRL
		#define HMRC    &ht     RCTRL
		#define HMLA    &ht     LALT
		#define HMRA    &ht     RALT
		#define HMLG    &htslow LGUI
		#define HMRG    &htslow RGUI
		 // for sticky mods in nav layer:
		#define SKLS    &htsk   LSHIFT
		#define SKLC    &htsk   LCTRL
		#define SKLA    &htsk   LALT
		#define SKLG    &htsk   LGUI
		
		// □ = space, ■ = nbsp
		// tap/hold                                // TAP      HOLD
		#define DLLR_EURO    &mt  	   EURO_ DLLR_ // $        €
		#define EQUL_DIFF    &mt  	   DIFF_ EQUL_ // =        ≠
		#define NBSP_QMRK    &ht_qmrk  0 QMRK_     
		#define NBSP_EXCL    &ht_excl  0 EXCL_    
		#define DOT_COLN     &ht_coln  0 DOT_      // .        ■:□
		#define COMM_SCLN    &ht_scln  0 COMM_     // ,        ■;□
		
		#define NBSP_LGLM    &ht_lglm  LGLM_ 0     // «■    «
		#define NBSP_RGLM    &ht_rglm  RGLM_ 0     // ■»    »
		
		#define HT_CTRZ    &ht  LC(Y_)      LC(Z_) // undo     redo
		//#define HT_CTRV    &ht  &kp PASTEPLAIN  LC(V_) // paste    plaintext paste
		
		
		// thumb keys
		#define TH_L_MAIN      &lt   NUM E_
		#define TH_L_MAIN_CW   &lt   NUM LS(E_) // capsword
		
		#define TH_L_AUX       &lsl  SYM SYM
		
		#define TH_R_MAIN      &lt      NAV SPACE
		#define TH_R_MAIN_CW   &htcpwd  NAV 0  // capsword
		
		#define TH_R_AUX       &lsl  ACNT ACNT
		
		
		#define _DEFAULT_THUMBS_  TH_L_MAIN     TH_L_AUX          TH_R_AUX TH_R_MAIN
		#define _CAPSWORD_THUMBS_ TH_L_MAIN_CW      _trans_          _trans_     TH_R_MAIN_CW
		
		
		// todo reorder layers according to thumbs
		base_layer {
			bindings = <
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
			                   _____   _____         _____   _____
			>;
		};
		
		caps_word_layer {
			bindings = <
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
			                   _____   _____         _____   _____
			>;
		};
				
		num_layer { // colocar aqui [], na mão direita eu acho
			bindings = <
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
			                   _____   _____         _____   _____
			>;
		};
		
		utility_layer {
			bindings = <
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
			                   _____   _____         _____   _____
			>;
		};
		
		sym_layer {
			bindings = <
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
			                   _____   _____         _____   _____
			>;
		};
		
		accent_layer {
			bindings = <
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
			                   _____   _____         _____   _____
			>;
		};
		
		accent_caps_layer {
			bindings = <
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
			                   _____   _____         _____   _____
			>;                                                                                                 
		};
		
		nav_layer { // HMRG LGUI	HMLA LALT	HMLC LCTRL	HMLS LSHIFT	 
			bindings = <
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
			                   _____   _____         _____   _____
			>;
		};
		
		func_layer {
			bindings = <
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
			                   _____   _____         _____   _____
			>;
		};
		
		game_layer {
			bindings = <
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
			                   _____   _____         _____   _____
			>;
		};
		
		game_layer_2 {
			bindings = <
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
			                   _____   _____         _____   _____
			>;
		};
		
		/* FOR DEBUGGING:
			bindings = <
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
				_____ _____ _____ _____   _____         _____   _____ _____ _____ _____
			                   _____   _____         _____   _____
			>;
		*/
	};
};