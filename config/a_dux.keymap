#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/outputs.h>

#include "bepo_bindings.h"

// SETTINGS
#define _STICKY_TIMEOUT      2000

#define _MACRO_INTERVAL      1    // delay between key presses (3 is good)
#define _MACRO_TAP_FOR       1    // how long to hold tapped key (3 is good)

#define _COMBO_TIMEOUT       18   // maximum interval between keys to form combo
#define _COMBO_TIMEOUT_SLOW  50

// holdtap settings
#define _HT_TAPLIMIT_SLOW       300  // how long must hold to not be tap
#define _HT_TAPLIMIT            260  // (280 is good) // TODO
#define _HT_TAPLIMIT_FAST       200  // 
#define _HT_TAPLIMIT_FASTER     120  // 

#define _HT_QUICK_TAP           200  // how fast must press twice for second to start repeating tap


// LAYERS
#define l_BASE 0
#define l_CAPS 1
#define l_OSCP 2
#define l_NUM  3
#define l_SYM  4
#define l_NAV  5
#define l_ACNT 6
#define l_ACCP 7 
#define l_UTIL 8
#define l_FUNC 9
#define l_GAME 10
#define l_GAM2 11

// combos shouldn't work on game layer, to minimize delay
#define ll_DEFAULT     l_BASE  l_CAPS  l_OSCP  l_NUM  l_SYM  l_NAV  l_ACNT  l_ACCP  l_UTIL  l_FUNC
#define ll_NOTCAPS     l_BASE                  l_NUM  l_SYM  l_NAV  l_ACNT  l_ACCP  l_UTIL  l_FUNC
#define ll_CAPS                l_CAPS  l_OSCP

// special mods
#define SUPR(x)  &kp    LS(LC(LA(x)))
#define HYPR(x)  &kp LG(LS(LC(LA(x))))

// (autohotkey)
#define TOG_DISPLAY  SUPR(O_) // toggles extend/external display
#define TOG_THEME    SUPR(É_) // toggles dark/light theme
// (ahk + controlmymonitor)
#define M2_BRI_U     SUPR(U_) // + brightness external display
#define M2_BRI_D     SUPR(Z_) // - brightness external display
#define TOG_DCR      SUPR(Q_) // toggles DCR on/off on external display


&lt { // tap for kp, hold for layer
	flavor          = "tap-preferred"; //"balanced";
	tapping-term-ms = <_HT_TAPLIMIT>;
	quick-tap-ms    = <_HT_QUICK_TAP>;
};

&mt { // hold-tap
	tapping-term-ms = <_HT_TAPLIMIT_FASTER>;
	quick-tap-ms    = <_HT_QUICK_TAP>;
};

&sk { // one-shot layer
	release-after-ms = <_STICKY_TIMEOUT>;
	quick-release;
};


// mo  = layer while held
// lt  = hold-tap layer/kp
// to  = enables only this layer
// tog = toggle layer

/ {
	behaviors {
		#define _POSITIONS_LH   0 1 2 3 4 10 11 12 13 14 20 21 22 23 24 30 31
		#define _POSITIONS_RH   5 6 7 8 9 15 16 17 18 19 25 26 27 28 29 32 33
		#define _ALL_POSITIONS  _POSITIONS_LH  _POSITIONS_RH

		#define DEFINE_HOLDTAP(NAME, FLAVOR, DELAY, POSITIONS, BINDINGS...) \
			NAME: ht_##NAME { \
				label           = #NAME; \
				flavor          = #FLAVOR; \
				tapping-term-ms = <DELAY>; \
				quick-tap-ms    = <_HT_QUICK_TAP>; \
				bindings        = BINDINGS; \
				 \
				#binding-cells  = <2>; \
				compatible      = "zmk,behavior-hold-tap"; \
				 \
				hold-trigger-key-positions = <POSITIONS>; \
			};

		#define HT(             NAME,                                                       BINDINGS... ) \
				DEFINE_HOLDTAP (NAME,  tap-preferred,  _HT_TAPLIMIT,       _ALL_POSITIONS,  BINDINGS)

		#define HT_FAST(        NAME,                                                       BINDINGS... ) \
				DEFINE_HOLDTAP( NAME,  tap-preferred,  _HT_TAPLIMIT_FAST,  _ALL_POSITIONS,  BINDINGS)
				
		#define HT_SLOW(        NAME,                                                       BINDINGS... ) \
				DEFINE_HOLDTAP( NAME,  tap-preferred,  _HT_TAPLIMIT_SLOW,  _ALL_POSITIONS,  BINDINGS)

		#define HT_BAL(         NAME,                                                       BINDINGS... ) \
				DEFINE_HOLDTAP( NAME,       balanced,  _HT_TAPLIMIT,       _ALL_POSITIONS,  BINDINGS)

		#define HRMOD_POS(      NAME,                                      POSITIONS,       BINDINGS... ) \
				DEFINE_HOLDTAP( NAME,  tap-preferred,  _HT_TAPLIMIT,       POSITIONS,       BINDINGS)


	 // HOME-ROW MODS                       // HOLD           TAP             
		HT(      ht,     <&kp>,  <&kp> )    // kp             kp                (tap-preferred)
		HT_SLOW( htslow, <&kp>,  <&kp> )    // kp (slow)      kp (slow)         (tap-preferred)
		HT(      htsl,   <&kp>,  <&sl> )    // kp             one-shot layer    (tap-preferred)
		HT_BAL(  mosl,   <&mo>,  <&sl> )    // layer          one-shot layer    (balanced)
		HT(      mokp,   <&mo>,  <&kp> )    // layer          kp                (tap-preferred)


	 // hrm for opposite hand only (used for shift)
		HRMOD_POS( htl,  _POSITIONS_RH,  <&kp>, <&kp> )
		HRMOD_POS( htr,  _POSITIONS_LH,  <&kp>, <&kp> )
		
		                                                               // HOLD           TAP
		HRMOD_POS( htls_cw,  _POSITIONS_RH,  <&m_cp_hmls>,  <&kp> )    // lshift         kp 
		HRMOD_POS( htrs_cw,  _POSITIONS_LH,  <&m_cp_hmrs>,  <&kp> )    // rshift         kp 
		HT(        htlc_cw,                  <&m_cp_hmlc>,  <&kp> )    // lctrl          kp 
		HT(        htrc_cw,                  <&m_cp_hmrc>,  <&kp> )    // rctrl          kp 
		HT(        htla_cw,                  <&m_cp_hmla>,  <&kp> )    // lalt           kp 
		HT(        htra_cw,                  <&m_cp_hmra>,  <&kp> )    // ralt           kp 
		HT(        htlg_cw,                  <&m_cp_hmlg>,  <&kp> )    // lgui           kp 
		HT(        htrg_cw,                  <&m_cp_hmrg>,  <&kp> )    // rgui           kp 


	 // OTHER HOLDTAPS                                           // HOLD               TAP
		HT_SLOW(   mokp_l_UTIL,    <&m_mo_l_UTIL>,    <&kp> )     // mo UTIL            kp                (slow, tap-preferred)
	 // capsword thumbs - TODO should be BAL like the base layer thumbs?
		HT(  cw_mokp_l_NAV_SPC, <&m_cw_mo_NAV>,  <&m_cw_SPC> )     // mo NAV -> BASE     SPC    -> BASE    (was balanced)
		HT(  mo_slcw_l_SYM,          <&mo>,      <&m_cw_sl_SYM> )  // mo                 sl SYM -> BASE    (was balanced)


	 // loose accents on tap
		HT( ht_CFX, <&kp>, <&m_loose_CFX> )
		HT( ht_GRV, <&kp>, <&m_loose_GRV> )
		HT( ht_TLD, <&kp>, <&m_loose_TLD> )
		
		
	 // NBSP STUFF (for french) ------------------
	 // automatic nbsp on tap
		HT( ht_LGLM, <&kp>, <&m_nbsp_LGLM> )
		HT( ht_RGLM, <&kp>, <&m_nbsp_RGLM> )

	 // automatic nbsp on hold
		HT_FAST( ht_COLN, <&m_nbsp_COLN>, <&kp> )
		HT_FAST( ht_SCLN, <&m_nbsp_SCLN>, <&kp> )
		HT_FAST( ht_QMRK, <&m_nbsp_QMRK>, <&kp> )
		HT_FAST( ht_EXCL, <&m_nbsp_EXCL>, <&kp> )
	};



	macros {
		// syntactic sugar
		#define M_TAP         &macro_tap
		#define M_HOLD        &macro_press
		#define M_REL         &macro_release

		#define M_KP          &macro_tap &kp
		#define M_KP_HOLD     &macro_press &kp
		#define M_KP_REL      &macro_release &kp

		#define M_WAIT_REL    &macro_pause_for_release

		#define M_HOLD_SHIFT  <M_KP_HOLD LSHFT>
		#define M_REL_SHIFT   <M_KP_REL  LSHFT>, <M_KP_REL RSHFT>

		// BASE MACRO
		// (all macro names will be prefixed by m_)
		#define MACRO(NAME, BINDINGS...) \
			ZMK_MACRO(m_##NAME, \
				tap-ms   = <_MACRO_TAP_FOR>; \
				wait-ms  = <_MACRO_INTERVAL>; \
				bindings = BINDINGS; \
				)

		// #define MACRO_TWO_KP(NAME, ONE, TWO) \
			// NAME: NAME { \
				// compatible = "zmk,behavior-macro-two-param"; \
				// label = "M2_##NAME"; \
				// #binding-cells = <2>; \
				// tap-ms   = <_MACRO_TAP_FOR>; \
				// wait-ms  = <_MACRO_INTERVAL>; \
				// bindings = <&macro_param_1to1>, <&kp MACRO_PLACEHOLDER>, <&macro_param_2to1>, <&kp MACRO_PLACEHOLDER>; \
			// };

		// MACRO_DIGRAM : tap a key, release shift if held, tap another
		//                (so can eg hold shift and do &m_Q_U_ to get Qu)
		//                also defines a capsword version which holds shift during both
		#define MACRO_DIGRAM(FIRST, SECOND) \
			MACRO(FIRST##SECOND,                     <M_KP FIRST>, M_REL_SHIFT, <M_KP SECOND>) \
			\
			MACRO(up_##FIRST##SECOND,  M_HOLD_SHIFT, <M_KP FIRST>, M_REL_SHIFT, <M_KP SECOND>) \
			\
			MACRO(cp_##FIRST##SECOND,  M_HOLD_SHIFT, <M_KP FIRST>,              <M_KP SECOND>,  M_REL_SHIFT)


		#define MACRO_ACCENT_SINGLE(ACCENT, LETTER) \
			MACRO(ACCENT##LETTER,      <M_KP ACCENT>, M_REL_SHIFT,  <M_KP LETTER>) \
			\
			MACRO(cp_##ACCENT##LETTER, <M_KP ACCENT>, M_HOLD_SHIFT, <M_KP LETTER>, M_REL_SHIFT)


		#define MACRO_ACCENT_DIGRAM(ACCENT, FIRST, SECOND) \
			MACRO(     ACCENT##FIRST##SECOND, <M_KP ACCENT>,               <M_KP FIRST>, M_REL_SHIFT, <M_KP SECOND>) \
			\
			MACRO(up_##ACCENT##FIRST##SECOND, <M_KP ACCENT>, M_HOLD_SHIFT, <M_KP FIRST>, M_REL_SHIFT, <M_KP SECOND>) \
			\
			MACRO(cp_##ACCENT##FIRST##SECOND, <M_KP ACCENT>, M_HOLD_SHIFT, <M_KP FIRST>,              <M_KP SECOND>,  M_REL_SHIFT)


	 // INCONVENIENT DIGRAMS ------------------
	 // also defines a caps version (eg &m_cp_Q_U_)
	 //    and an uppercase version (eg &m_up_Q_U_)
		MACRO_DIGRAM( Q_, U_ )
		MACRO_DIGRAM( B_, J_ )


	 // ACCENTED LETTERS ------------------
	 // also defines a caps version (eg &m_cp_ACUT_A_)
	 //    and an uppercase version (eg &m_up_ACUT_A_)
		MACRO_ACCENT_SINGLE( ACUT_, A_ )
		MACRO_ACCENT_SINGLE( ACUT_, I_ )
		MACRO_ACCENT_SINGLE( ACUT_, O_ )
		MACRO_ACCENT_SINGLE( ACUT_, U_ )

		MACRO_ACCENT_SINGLE( CFLX_, A_ )
		MACRO_ACCENT_SINGLE( CFLX_, E_ )
		MACRO_ACCENT_SINGLE( CFLX_, I_ )
		MACRO_ACCENT_SINGLE( CFLX_, O_ )
		MACRO_ACCENT_SINGLE( CFLX_, U_ )

		MACRO_ACCENT_SINGLE( GRAV_, E_ )
		MACRO_ACCENT_SINGLE( GRAV_, O_ )
		MACRO_ACCENT_SINGLE( GRAV_, U_ )

		MACRO_ACCENT_SINGLE( TILD_, A_ )
		MACRO_ACCENT_SINGLE( TILD_, O_ )
		MACRO_ACCENT_SINGLE( TILD_, N_ )
		MACRO_ACCENT_DIGRAM( TILD_, A_, E_ )
		MACRO_ACCENT_DIGRAM( TILD_, A_, O_ )
		MACRO_ACCENT_DIGRAM( TILD_, O_, E_ )

		MACRO_ACCENT_SINGLE( TRMA_, I_ )


	 // NBSP STUFF (for french) ----
		MACRO(       nbsp_QMRK ,  <M_TAP  &kp NBSP_  &kp QMRK_  &to l_BASE >) // goes back to l_BASE if l_CAPS was on
		MACRO(       nbsp_EXCL ,  <M_TAP  &kp NBSP_  &kp EXCL_             >)
		MACRO(       nbsp_COLN ,  <M_TAP  &kp NBSP_  &kp COLN_  &kp SPACE  >)
		MACRO(       nbsp_SCLN ,  <M_TAP  &kp NBSP_  &kp SCLN_  &kp SPACE  >)
		MACRO(       nbsp_RGLM ,  <M_TAP  &kp NBSP_  &kp RGLM_             >)
		MACRO(       nbsp_LGLM ,  <M_TAP  &kp LGLM_  &kp NBSP_             >)

	 // LOOSE ACCENTS --------------
		MACRO(      loose_CFX  ,  <M_TAP  &kp CFLX_  &kp SPACE >)
		MACRO(      loose_GRV  ,  <M_TAP  &kp GRAV_  &kp SPACE >)
		MACRO(      loose_TLD  ,  <M_TAP  &kp TILD_  &kp SPACE >)

	 // ESZETT ---------------------
		MACRO(            SZTT ,  <M_TAP  &kp RA(S_)  &kp    S_  >)
		MACRO(         cp_SZTT ,  <M_TAP  &kp RA(S_)  &kp LS(S_) >)

	 // CAPSWORD -------------------
	    MACRO(         sl_CAPS ,  <M_TAP                          &sl l_OSCP >)
		MACRO(     SPC_sl_CAPS ,  <M_TAP              &kp SPACE   &sl l_OSCP >)
		MACRO( DOT_SPC_sl_CAPS ,  <M_TAP  &kp DOT_    &kp SPACE   &sl l_OSCP >)
	 // key -> capsword off                           
		MACRO(         cw_SPC  ,  <M_TAP  &kp SPACE   &to l_BASE >)
		MACRO(         cw_TAB  ,  <M_TAP  &kp TAB     &to l_BASE >)
		MACRO(         cw_ENTER,  <M_TAP  &kp ENTER   &to l_BASE >)
		MACRO(         cw_ESC  ,  <M_TAP  &kp ESC     &to l_BASE >)
	 // capsword off + one-shot SYM
		MACRO(      cw_sl_SYM  ,  <M_TAP  &sl l_SYM  &tog l_CAPS >)
	 // capsword off + hold NAV
		MACRO(      cw_mo_NAV  ,  <M_TAP  &to l_NAV >,  <M_WAIT_REL>,  <M_TAP  &to l_BASE >)
		
	 // homerow mods pass through to l_BASE
		MACRO(      cp_hmls    ,  <M_TAP  &to l_BASE >,  <M_KP_HOLD LSHIFT >,  <M_WAIT_REL>,  <M_KP_REL LSHIFT >)
		MACRO(      cp_hmlc    ,  <M_TAP  &to l_BASE >,  <M_KP_HOLD LCTRL  >,  <M_WAIT_REL>,  <M_KP_REL LCTRL  >)
		MACRO(      cp_hmla    ,  <M_TAP  &to l_BASE >,  <M_KP_HOLD LALT   >,  <M_WAIT_REL>,  <M_KP_REL LALT   >)
		MACRO(      cp_hmlg    ,  <M_TAP  &to l_BASE >,  <M_KP_HOLD LGUI   >,  <M_WAIT_REL>,  <M_KP_REL LGUI   >)
		MACRO(      cp_hmrs    ,  <M_TAP  &to l_BASE >,  <M_KP_HOLD RSHIFT >,  <M_WAIT_REL>,  <M_KP_REL RSHIFT >)
		MACRO(      cp_hmrc    ,  <M_TAP  &to l_BASE >,  <M_KP_HOLD RCTRL  >,  <M_WAIT_REL>,  <M_KP_REL RCTRL  >)
		MACRO(      cp_hmra    ,  <M_TAP  &to l_BASE >,  <M_KP_HOLD RALT   >,  <M_WAIT_REL>,  <M_KP_REL RALT   >)
		MACRO(      cp_hmrg    ,  <M_TAP  &to l_BASE >,  <M_KP_HOLD RGUI   >,  <M_WAIT_REL>,  <M_KP_REL RGUI   >)
		


	 // UTIL LAYER ------------------
	 // upon entering this layer, shift + control + alt are held.
	 // each key releases some mods, then holds them all again.
	 // this allows us e.g. to alt-tab without letting go of alt.
		#define  ALL_MODS   M_HOLD  &kp LSHIFT  &kp LCTRL  &kp LALT
		#define   NO_MODS   M_REL   &kp LSHIFT  &kp LCTRL  &kp LALT  &kp RSHIFT  &kp RCTRL  &kp RALT // release rh mods just in case
		#define HOLD_CTRL   M_REL   &kp LSHIFT             &kp LALT  &kp RSHIFT  &kp RCTRL  &kp RALT
		#define HOLD_ALT    M_REL   &kp LSHIFT  &kp LCTRL            &kp RSHIFT  &kp RCTRL  &kp RALT

		MACRO( mo_l_UTIL,  <M_TAP  &to l_UTIL >,  <ALL_MODS>,  <M_WAIT_REL>,  <NO_MODS>,  <M_TAP  &to l_BASE > )
		
		MACRO(  utl_BACK,  <NO_MODS>  ,  <M_KP  C_AC_BACK >    , <ALL_MODS> )
		MACRO(  utl_FRWD,  <NO_MODS>  ,  <M_KP  C_AC_FORWARD > , <ALL_MODS> )
		MACRO(  utl_ULIN,  <NO_MODS>  ,  <M_KP  ULIN_  > ,       <ALL_MODS> )
		MACRO(  utl_DESK,  <NO_MODS>  ,  <M_KP  LG(D_) > ,       <ALL_MODS> )
		MACRO(  utl_REDO,  <NO_MODS>  ,  <M_KP  LC(Y_) > ,       <ALL_MODS> )
		MACRO(  utl_LAF4,  <NO_MODS>  ,  <M_KP  LA(F4) > ,       <ALL_MODS> )
									  
		MACRO(  utl_STAB,  <NO_MODS>  ,  <M_KP  LS(TAB) > ,      <ALL_MODS> )
		MACRO(  utl_GTAB,  <NO_MODS>  ,  <M_KP  LG(TAB) > ,      <ALL_MODS> )

		MACRO(  utl_ATAB,  <HOLD_ALT> ,  <M_KP     TAB  > ) // these will not hold all mods back,
		MACRO( utl_SATAB,  <HOLD_ALT> ,  <M_KP  LS(TAB) > ) //  so that we can do alt-tab etc
		MACRO(  utl_CTAB,  <HOLD_CTRL>,  <M_KP     TAB  > ) //  several times in a row without
		MACRO( utl_SCTAB,  <HOLD_CTRL>,  <M_KP  LS(TAB) > ) //  dropping the little window

	};



	combos {
		compatible = "zmk,combos";

		#define DEFINE_COMBO(LAYERS, NAME, POSITIONS, BINDINGS...) \
			combo_##NAME { \
				layers        = <LAYERS>; \
				key-positions = <POSITIONS>; \
				bindings      = <BINDINGS>; \
				timeout-ms    = <_COMBO_TIMEOUT>; \
			};

		// TODO: ok to omit line breaks between defs?
		#define COMBO(       LAYERS,        BINDINGS,   POSITIONS,   GIBBERISH_NAME) \
			DEFINE_COMBO(    LAYERS,  GIBBERISH_NAME,   POSITIONS,   BINDINGS)

		// suffix must be added if there's more than one combo for the same key or macro
		#define COMBO_KP(    LAYERS,     KEY, SUFFIX,   POSITIONS) \
			DEFINE_COMBO(    LAYERS,     KEY##SUFFIX,   POSITIONS,   &kp KEY)

		#define COMBO_M( LAYERS,   MACRO, SUFFIX,   POSITIONS) \
			DEFINE_COMBO(    LAYERS,   MACRO##SUFFIX,   POSITIONS,   &m_##MACRO)


	/*
	    0    1   2   3     4 |  5     6   7   8   9
	    10  11  12  13    14 | 15    16  17  18  19
	    20  21  22  23    24 | 25    26  27  28  29
							 |
	                30  31   |   32  33
	*/

												     
		// left hand                                       
		COMBO(    ll_DEFAULT,      &kp LG(V_)      ,      2  3 ,  gibrish) // clipboard history
		
		COMBO_KP( ll_NOTCAPS,          ESC        ,,     10 11 )
		COMBO_M(  ll_CAPS,          cw_ESC        ,,     10 11 )
		
		COMBO_KP( ll_DEFAULT,          BSPC       ,,     11 12 )
		COMBO_KP( ll_DEFAULT,          DEL        ,,     21 22 )
		
		COMBO_KP( ll_NOTCAPS,          TAB        ,,     12 13 )									 				  
		COMBO_M(  ll_CAPS,          cw_TAB        ,,     12 13 )
		COMBO_KP( ll_DEFAULT,          SPACE      ,,     22 23 )	
		
		COMBO(    ll_DEFAULT,       &m_sl_CAPS     ,  11 12 13 ,  gibberishai)	
		COMBO_KP( ll_DEFAULT,          ENTER,l     ,     13 14 )
		
		COMBO(    ll_DEFAULT,       &m_SPC_sl_CAPS ,   1  2  3 ,  gibberisha)
		COMBO(    ll_DEFAULT,   &m_DOT_SPC_sl_CAPS ,  21 22 23 ,  gibberishapo)
		
		COMBO(    ll_DEFAULT,      &kp LC(Z_)      ,     20 21 ,  gibberish)
		
		COMBO(    ll_DEFAULT,    &mosl l_FUNC l_FUNC,    30 31 ,  gibberishaioy)
											
											
		// right hand                                        
		COMBO_KP( ll_NOTCAPS,          ENTER,r     ,     16 17 )
		COMBO_M(  ll_CAPS,          cw_ENTER      ,,     16 17 )	
		
		COMBO(    ll_DEFAULT,      &kp LC(BSPC)    ,     17 18 ,  gibberishapoip)		
		COMBO(    ll_DEFAULT,      &kp LC(DEL)     ,     27 28 ,  gibberishaioipp)
		
		COMBO(    ll_DEFAULT,       &m_sl_CAPS     ,  16 17 18 ,  gibberishaioaipo)										
		COMBO(    ll_DEFAULT,   &m_SPC_sl_CAPS     ,     32 33 ,  gibberishapopiaio) // TODO: which m_SPC_sl_CAPS is better?  
		
		
		// TODO  merge these?                     
		COMBO_M(  l_BASE,              Q_U_       ,,     26 27 )  /* qu */
		COMBO_M(  l_BASE,         TILD_A_E_       ,,     13 30 )  /* ãe */
		COMBO_M(  l_BASE,         TILD_A_O_       ,,     13 11 )  /* ão */
		COMBO_M(  l_BASE,         TILD_O_E_       ,,     11 30 )  /* õe */
					  		     	  			 	     
		COMBO_M(  l_OSCP,           up_Q_U_       ,,     26 27 )  /* Qu */
		COMBO_M(  l_OSCP,      up_TILD_A_E_       ,,     13 30 )  /* Ãe */
		COMBO_M(  l_OSCP,      up_TILD_A_O_       ,,     13 11 )  /* Ão */
		COMBO_M(  l_OSCP,      up_TILD_O_E_       ,,     11 30 )  /* Õe */
					  		     	  				 	      
		COMBO_M(  l_CAPS,           cp_Q_U_,,            26 27 )  /* QU */
		COMBO_M(  l_CAPS,      cp_TILD_A_E_       ,,     13 30 )  /* ÃE */
		COMBO_M(  l_CAPS,      cp_TILD_A_O_       ,,     13 11 )  /* ÃO */
		COMBO_M(  l_CAPS,      cp_TILD_O_E_       ,,     11 30 )  /* ÕE */
											     	    
									 				 	 
		// function layer
		COMBO(    l_FUNC,         &sys_reset       ,      0  4 ,  gibberishaiouaioua)	
		COMBO(    l_FUNC,         &kp  TOG_DCR     ,     10 11 ,  gibberishinha)	
		COMBO(    l_FUNC,         &kp  TOG_DISPLAY ,     20 21 ,  gibberishinho)
		COMBO(    l_FUNC,         &bootloader      ,     20 24 ,  gibberishayuqaiouea)
		COMBO(    l_FUNC,         &kp  C_NEXT      ,     12 13 ,  gibberishon)
		COMBO(    l_FUNC,         &kp  C_PREV      ,     22 23 ,  gibberishaille)
		COMBO(    l_FUNC,         &kp  TOG_THEME   ,  21 22 23 ,  gibberishaco)
		
		COMBO(    l_FUNC,         &tog l_GAME      ,      4 14 ,  gibberishaiouayopaip)
		COMBO(    l_FUNC,         &tog l_GAM2      ,     14 24 ,  gibberishaiopoappyaio)		
	};



	keymap {
		compatible = "zmk,keymap";

	 // READABILITY ------------------
		#define impossible  &none // physically impossible
		#define _________   &none
		#define ______      &none


	 // HOME-ROW MODS ------------------
		#define HMLS   &htl  LSHIFT // left shift prefers keys on right hand
		#define HMRS   &htr  RSHIFT // rite shift prefers keys on lefft hand
		#define HMLC   &ht   LCTRL
		#define HMRC   &ht   RCTRL
		#define HMLA   &ht   LALT
		#define HMRA   &ht   RALT
		#define HMLG   &ht   LGUI
		#define HMRG   &ht   RGUI

	 // HOME-ROW MODS with shift on key
		#define HMLS_cw(X)   &htls_cw 0 LS(X)
		#define HMRS_cw(X)   &htrs_cw 0 LS(X)
		#define HMLC_cw(X)   &htlc_cw 0 LS(X)
		#define HMRC_cw(X)   &htrc_cw 0 LS(X)
		#define HMLA_cw(X)   &htla_cw 0 LS(X)
		#define HMRA_cw(X)   &htra_cw 0 LS(X)
		#define HMLG_cw(X)   &htlg_cw 0 LS(X)
		#define HMRG_cw(X)   &htrg_cw 0 LS(X)
	 // -------------------		

	 // HOLDTAP SYMBOLS ------------------
	 // □ = space, ■ = nbsp, () = explicited later       // HOLD  TAP
		#define DLLR_EURO    &htslow    EURO_  DLLR_     //  €     $
		#define EQUL_DIFF    &htslow    DIFF_  EQUL_     //  ≠     =
		#define IEXCL_IQMRK  &htslow    IEXC_  IQMR_     //  ¿     ¡
		#define EXCL_QMRK    &htslow    EXCL_  QMRK_     //  ?     !

		#define NBSP_QMRK    &ht_QMRK   0      QMRK_     // ■?     ?
		#define NBSP_EXCL    &ht_EXCL   0      EXCL_     // ■!     !
		#define DOT_COLN     &ht_COLN   0      DOT_      // ■:□    .
		#define COMM_SCLN    &ht_SCLN   0      COMM_     // ■;□    ,

		#define NBSP_LGLM    &ht_LGLM   LGLM_  0         //  «     «■
		#define NBSP_RGLM    &ht_RGLM   RGLM_  0         //  »      ■»


	 // THUMB KEYS ------------------
		#define lt_NUM_E           &lt   l_NUM      E_
		#define lt_NUM_E_cw        &lt   l_NUM   LS(E_)

		#define mosl_SYM          &mosl  l_SYM   l_SYM
		#define mosl_SYM_cw     &mo_slcw_l_SYM   l_SYM 0

		#define mosl_ACNT         &mosl  l_ACNT  l_ACNT
		#define mosl_ACCP         &mosl  l_ACCP  l_ACCP

		#define lt_NAV_SPC        &lt    l_NAV SPC
		#define lt_NAV_SPC_cw   &cw_mokp_l_NAV_SPC 0 0


	 // -------------------
	 // BASE LAYER
	 // -------------------
		#define UTLAYR  &mokp_l_UTIL 0  // UTIL layer on hold
	 // -------------------		

		base_layer {
			bindings = <
				&kp    Q_   &kp  MIN_   &kp  Y_   DOT_COLN       NBSP_QMRK           &kp K_      &kp  C_   &kp  H_   &kp  W_   &kp  J_
				UTLAYR U_   HMLA O_     HMLC I_   HMLS A_           &kp F_           &kp G_      HMRS T_   HMRC R_   HMRA S_   &kp  N_
				HMLG   Z_   HMRA EACT_  &kp  P_   COMM_SCLN         &kp X_           &kp V_      &kp  D_   &kp  M_   HMLA L_   HMRG B_
			//  
												        lt_NUM_E   mosl_SYM          mosl_ACNT   lt_NAV_SPC
			>;
		};
		
		
	 // -------------------
	 // CAPS LAYER
	 // -------------------
#define CAPSDEF &kp    LS(Q_)   &kp  MIN_       &kp  LS(Y_)   DOT_COLN           NBSP_QMRK          &kp LS(K_)       &kp  LS(C_)   &kp  LS(H_)   &kp  LS(W_)   &kp  LS(J_)\
				UTLAYR LS(U_)   HMLA_cw(O_)	    HMLC_cw(I_)   HMLS_cw(A_)       &kp LS(F_)          &kp LS(G_)       HMRS_cw(T_)   HMRC_cw(R_)   HMRA_cw(S_)   &kp  LS(N_)\
				  HMLG_cw(Z_)   HMRA_cw(EACT_)  &kp  LS(P_)   COMM_SCLN         &kp LS(X_)          &kp LS(V_)       &kp  LS(D_)   &kp  LS(M_)   HMLA_cw(L_)   HMRG_cw(B_)
									 
		caps_layer {
			bindings = <
				CAPSDEF	//							                 both leave capsword          doesn't leave    leaves		
										  				          lt_NUM_E_cw   mosl_SYM_cw          mosl_ACCP   lt_NAV_SPC_cw
			>;
		};	
		oneshotcaps_layer { // two differences:  * qu combo does Qu, not QU
			bindings = <    //                   * default mosl_SYM behavior, since SLCP will be toggled off automatically. 
				CAPSDEF     //                     otherwise in a quick roll the second key will arrive after going to BASE and before sl'ing SYM
												                  lt_NUM_E_cw   mosl_SYM             mosl_ACCP   lt_NAV_SPC_cw
			>;
		};


	 // -------------------
	 // LH AUX LAYERS
	 // -------------------
	 // mod on hold, loose accent on tap
		#define HMRS_CFX__   &ht_CFX   LSHIFT  0
		#define HMRC_GRV__   &ht_GRV   LCTRL   0
		#define HMRG_TLD__   &ht_TLD   LGUI    0
	 // -------------------		

		num_layer {
			bindings = <
				&kp  PIPE_   &kp  N7_   &kp  N8_   &kp  N9_      EXCL_QMRK             DLLR_EURO       &kp  LBRK_   &kp  RBRK_   &kp  HASH_   &kp  PCNT_
				&kp  N0_     &kp  N1_   &kp  N2_   &kp  N3_      &kp SCLN_             &kp COLN_       HMRS PLUS_   HMRC MIN_    HMLA STAR_   HMRG FSLA_
				HMLC ULIN_   &kp  N4_   &kp  N5_   &kp  N6_      &kp COMM_             &kp DOT_        &kp  LT_     &kp  GT_     EQUL_DIFF    &kp  BSLA_
			//  								  if locked:
				                                  &to l_BASE    impossible             &kp ULIN_   &trans
			>;
		};

		sym_layer {
			bindings = <
				&kp  PIPE_   &kp  AT_     &kp  AE_     &kp  OE_        NBSP_EXCL            _________       &kp  LBRK_   &kp RBRK_    &kp AMPR_   DLLR_EURO
				HMLG LCUR_   HMLA RCUR_   HMLC LPAR_   HMLS RPAR_      &kp SCLN_            &kp COLN_       HMRS_CFX__   HMRC_GRV__   &kp RALT    HMRG_TLD__
			    &kp  NDSH_   HMRA MDSH_   NBSP_LGLM    NBSP_RGLM       &kp COMM_            &kp DOT_        _________    _________    &kp LALT    &kp BSLA_
			//  									                    double tap:
								                                 ______   ______            &kp ULIN_   &trans
			>;
		};



	 // -------------------
	 // RH AUX LAYERS
	 // -------------------
		#define TASKMAN      &kp LC(LS(ESC))    // ctrl shift esc
		#define PASTEPLAIN   &kp LC(LG(LA(V_))) // plaintext paste (power toys)
	 // -------------------		

		nav_layer {
			bindings = <
				&kp  LSLCK    &kp  LNLCK    &to  l_NUM    &kp  LG(V_)         TASKMAN            _________      HMLS LC(HOME)   HMLC PG_DN    HMLA PG_UP    HMRG LC(END)
				&kp  LC(Y_)   HMLA INSERT   HMLC PSCRN    HMLS PSBRK        _________            _________      &kp  LC(LEFT)   &kp  DOWN     &kp  UP       &kp  LC(RIGHT)
				HMLG LC(Z_)   HMRA LC(X_)   &kp  LC(C_)   &kp  LC(V_)      PASTEPLAIN            _________      &kp  HOME       &kp  LEFT     &kp  RIGHT    &kp  END
			//  					                                        				                  double tap:
												               &tog l_CAPS   &kp CAPS            impossible   impossible
			>;
		};

	 // questionable syntactic sugar to define several parameters beginning with &m_
		#define MACRO_ROW_3(PREFIX, ONE, TWO, THREE)               &m_##PREFIX##ONE &m_##PREFIX##TWO &m_##PREFIX##THREE
		#define MACRO_ROW_4(PREFIX, ONE, TWO, THREE, FOUR)         &m_##PREFIX##ONE &m_##PREFIX##TWO &m_##PREFIX##THREE &m_##PREFIX##FOUR
		#define MACRO_ROW_5(PREFIX, ONE, TWO, THREE, FOUR, FIVE)   &m_##PREFIX##ONE &m_##PREFIX##TWO &m_##PREFIX##THREE &m_##PREFIX##FOUR &m_##PREFIX##FIVE

		accent_layer {
			bindings = <
 MACRO_ROW_4(,    CFLX_U_,   CFLX_O_,   CFLX_I_,   CFLX_A_ )     IEXCL_IQMRK         _________     &kp  CCED_  &kp  APST_  &kp  QUOT_   &m_B_J_
 MACRO_ROW_5(,    ACUT_U_,   ACUT_O_,   ACUT_I_,   ACUT_A_,          TILD_A_ )       _________     HMRS CFLX_  HMRC GRAV_  HMLA ACUT_   &m_TILD_N_
 MACRO_ROW_3(,    GRAV_U_,   TILD_O_,   TRMA_I_ )  &kp AGRV_       _________         _________     &kp  TRMA_  _________     &m_SZTT   &kp TILD_
			//  									                               double tap:
												       &m_CFLX_E_   &kp EGRV_        ______   &trans
			>;
		};

		accent_caps_layer {
			bindings = <
 MACRO_ROW_4(cp_, CFLX_U_,   CFLX_O_,   CFLX_I_,   CFLX_A_ )         _________            _________       &kp  LS(CCED_)  &kp  APST_  &kp  QUOT_  &m_cp_B_J_
 MACRO_ROW_5(cp_, ACUT_U_,   ACUT_O_,   ACUT_I_,   ACUT_A_,           TILD_A_ )           _________       HMRS ACUT_      HMRC CFLX_  HMLA GRAV_  &m_cp_TILD_N_
 MACRO_ROW_3(cp_, GRAV_U_,   TILD_O_,   TRMA_I_)   &kp LS(AGRV_)     _________            _________       &kp  TRMA_      _________  &m_cp_SZTT   &kp   TILD_
			//  									                                    double tap:
											      &m_cp_CFLX_E_   &kp LS(EGRV_)           ______   &trans
			>;
		};



	 // -------------------
	 // FUNCTION LAYER
	 // -------------------

		utility_layer {
			bindings = <
				impossible  &trans       &m_utl_BACK   &m_utl_FRWD      &m_utl_LAF4         &kp K_      &kp C_   &kp H_   &kp W_  &kp  J_
				impossible  &m_utl_GTAB  &m_utl_SATAB  &m_utl_ATAB      &m_utl_REDO         &kp G_      &kp T_   &kp R_   &kp S_  &kp  N_
				impossible  &trans       &m_utl_SCTAB  &m_utl_CTAB      &m_utl_DESK         &kp V_      &kp D_   &kp M_   &kp L_  &kp  B_
			//
			                                              &m_utl_STAB   &m_utl_ULIN         ______   &kp SPC
			>;
		};

		func_layer {                                                                            
			bindings = <
				&bt  BT_SEL 3   &bt  BT_SEL 0   &bt  BT_SEL 1   &bt  BT_SEL 2        &bt BT_CLR         &sys_reset         &kp F7  &kp F8  &kp F9  &kp F12
				HMLG C_BRI_UP   HMLA M2_BRI_U   HMLC C_VOL_UP   HMLS C_PP  	         &kp  LSLCK         &out OUT_BLE       &kp F1  &kp F2  &kp F3  &kp F10
				&kp  C_BRI_DN   &kp  M2_BRI_D   &kp  C_VOL_DN   &kp  C_MUTE          &kp  LNLCK         &out OUT_USB       &kp F4  &kp F5  &kp F6  &kp F11
			//
															          impossible     impossible         &kp LSHIFT   &kp LALT
			>;
		};



	 // -------------------
	 // GAMING LAYERS
	 // -------------------

		game_layer {
			bindings = <
				&kp Q_     &kp MIN_    &kp Y_     &kp DOT_         &kp R_              &kp  K_          &kp C_    &kp H_    &kp W_     &kp J_
				&kp U_     &kp O_      &kp I_     &kp A_           &kp F_              &kp  G_          &kp LEFT  &kp UP    &kp RIGHT  &kp N_
				&kp ESC    &kp S_      &kp P_     &kp COMM_        &kp X_              &tog l_GAME      &kp D_    &kp DOWN  &kp L_     &kp B_
			//
										            &kp ENTER   &kp SPACE              &kp TAB   &kp LALT
			>;
		};

		game_layer_2 {
			bindings = <
				&kp LSHIFT  &kp A_     &kp EACT_  &kp I_        &kp O_             &kp  Y_            &kp U_   &kp I_     &kp O_    &kp P_
				&kp LCTRL   &kp B_     &kp U_     &kp P_        &kp E_             &kp  H_            &kp J_   &kp K_     &kp L_    &kp N_
				&kp ESC     &kp AGRV_  &kp Y_     &kp X_        &kp DOT            &tog l_GAM2        &kp M_   &kp COMM_  &kp DOT_  &kp BSPC
			//
											      &kp ENTER   &kp SPACE            &kp TAB   &kp LALT
			>;
		};



	 // -------------------
	 // DEBUGGING
	 // -------------------
	 /*
	 	bindings = <
	 		______ ______ ______ ______    ______         ______    ______ ______ ______ _____
	 		______ ______ ______ ______    ______         ______    ______ ______ ______ _____
	 		______ ______ ______ ______    ______         ______    ______ ______ ______ _____
	 	                          ______   ______         ______   ______
	 	>;
		
	 	bindings = <
			______ &trans &trans &trans    &trans         &trans    &trans &trans &trans &trans
			&trans &trans &trans &trans    &trans         &trans    &trans &trans &trans &trans
			&trans &trans &trans &trans    &trans         &trans    &trans &trans &trans &trans
			                     &trans  &trans             &trans  &trans
		>;
	 */
	};
};