#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/outputs.h>

#include "bepo_bindings.h"

// SETTINGS
#define _MACRO_INTERVAL   3  // max 3
#define _MACRO_TAP_FOR    3  // max 3

#define _COMBO_TIMEOUT      17 // min 16
#define _COMBO_TIMEOUT_SLOW 50 // min 16

#define _TAP_TERM_SLOTH   1200 // for dangerous xcv-all
#define _TAP_TERM_SLOW    300
#define _TAP_TERM         300  //default 250
#define _TAP_TERM_QUICK   200
#define _TAP_TERM_BLAZIN  120

#define _QUICK_TAP        200

#define _STICKY_TIMEOUT   2000 // min 1000

// LAYERS
#define BASE 0 
#define CPWD 1 
#define NUM  2 
#define UTIL 3 
#define SYM  4 
#define ACNT 5 
#define ACCW 6 
#define NAV  7
#define FUNC 8 
#define GAME 9 
#define GAM2 10

// combos shouldn't work on game layer, to minimize delay
#define ALL_LAYERS   BASE CPWD UTIL SYM ACNT ACCP NUM NAV FUNC GAME GAM2
#define NOT_GAME     BASE CPWD UTIL SYM ACNT ACCP NUM NAV FUNC
#define NOT_CPWD     BASE      UTIL SYM ACNT ACCP NUM NAV FUNC

&lt { // tap for kp, hold for layer
	tapping-term-ms = <_TAP_TERM>;
	flavor = "balanced";
	quick-tap-ms = <_QUICK_TAP>;
};

&mt { // hold-tap
	tapping-term-ms = <_TAP_TERM_BLAZIN>;
	quick-tap-ms = <_QUICK_TAP>;
};

&sk { // one-shot layer
	release-after-ms = <_STICKY_TIMEOUT>;
	quick-release;
};

/ {
	behaviors {
		#define DEFINE_HOLDTAP(FLAVOR, NAME, DELAY, BINDINGS...) \
			NAME: ht_##NAME { \
				label = #NAME; \
				flavor = #FLAVOR; \
				tapping-term-ms = <DELAY>; \
				bindings = BINDINGS; \
				#binding-cells = <2>; \
				compatible = "zmk,behavior-hold-tap"; \
				quick-tap-ms = <_QUICK_TAP>;

		#define HT(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(tap-preferred, NAME, _TAP_TERM, BINDINGS) \
			};

		#define HT_QUICK(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(tap-preferred, NAME, _TAP_TERM_QUICK, BINDINGS) \
			};

		#define HT_BAL(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(balanced, NAME, _TAP_TERM, BINDINGS) \
			};

		#define HRMOD_POS(NAME, POSITIONS) \
				DEFINE_HOLDTAP(tap-preferred, NAME, _TAP_TERM, <&kp>, <&kp>) \
					hold-trigger-key-positions = <POSITIONS>; \
			};

		#define HT_SLOW(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(tap-preferred, NAME, _TAP_TERM_SLOW, BINDINGS) \
			};
			
		#define SECURITY_HOLD(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(tap-preferred, NAME, _TAP_TERM_SLOTH, BINDINGS) \
			};

		// home-row mods                     // PRESS           HOLD
		HT(     ht,     <&kp>, <&kp>)        // &kp             &kp
		HT_SLOW(htslow, <&kp>, <&kp>)       
		HT(     htsk,   <&sk>, <&kp>)        // &kp             sticky layer
		HT(     ltt,    <&mo>, <&kp>)        // &kp             hold layer      (inherits tap-preferred from HT)
		HT_BAL( lsk,    <&mo>, <&sk>)        // one-shot mod    hold layer
		HT_BAL( lsl,    <&mo>, <&sl>)        // one-shot layer  hold layer
		HT(util_alt,  <&m_util_alt>,  <&kp>) // &kp             hold UTIL    (inherits tap-preferred from HT)
		HT(util_ctrl, <&m_util_ctrl>, <&kp>) // &kp             hold UTIL    (inherits tap-preferred from HT)
		
		
		//deactivates capsword, then...                       // PRESS           HOLD
		HT_BAL(ht_cw_nav_spc, <&m_mo_cw_nav>,  <&m_cw_spc>)    // space           hold NAV
		HT_BAL(lsl_cw_sym,    <&m_mo_cw_sym>,  <&m_sk_cw_sym>) // one-shot SYM    hold SYM
		
		
		// gotta hold these for a long time just to make sure
		SECURITY_HOLD(sechold_cutall,   <&m_cut_all>,   <&kp>)
		SECURITY_HOLD(sechold_copyall,  <&m_copy_all>,  <&kp>)
		SECURITY_HOLD(sechold_pasteall, <&m_paste_all>, <&kp>)

		// hrm for opposite hand only (used for shift)
		HRMOD_POS(htl, 5 6 7 8 9 15 16 17 18 19 25 26 27 28 29 32 33)
		HRMOD_POS(htr, 0 1 2 3 4 10 11 12 13 14 20 21 22 23 24 30 31)

		// automatic nbsp on tap
		HT(ht_lglm, <&kp>, <&m_nbsp_lglm>)
		HT(ht_rglm, <&kp>, <&m_nbsp_rglm>)

		// automatic nbsp on hold
		HT_QUICK(ht_coln, <&m_nbsp_coln>, <&kp>)
		HT_QUICK(ht_scln, <&m_nbsp_scln>, <&kp>)
		HT_QUICK(ht_qmrk, <&m_nbsp_qmrk>, <&kp>)
		HT_QUICK(ht_excl, <&m_nbsp_excl>, <&kp>)
	};

	macros {
		#define RELEASE_SHIFT <&macro_release &kp LSHFT &kp RSHFT>

		#define MACRO(NAME, BINDINGS...) \
			ZMK_MACRO(m_##NAME, \
				tap-ms   = <_MACRO_TAP_FOR>; \
				wait-ms  = <_MACRO_INTERVAL>; \
				bindings = BINDINGS; \
				)

		// names the macro "m_FIRST##SECOND", eg "m_Q_U_"
		#define MACRO_SIMPLE(FIRST, SECOND) \
			MACRO(FIRST##SECOND, <&macro_tap &kp A>)
			
		#define MACRO_TAP(NAME, BINDINGS...) \
			MACRO(NAME, <&macro_tap &kp A>)
					
		// #define MACRO_LAST_UPPER(FIRST, UPPERCASE...) \
			// MACRO(cp_##FIRST##SECOND, <&macro_tap &kp FIRST>, <&macro_press &kp LSHFT>, <&macro_tap UPPERCASE>, <&macro_release &kp LSHFT>)
						
						
		// #define MACRO_ACCENT_COMPLEX(NAME, FIRST, UPPERCASE...) \
			// MACRO(NAME, <&macro_tap &kp FIRST UPPERCASE>) \
			// \
			// MACRO(cp_##NAME, <&macro_tap &kp FIRST>, <&macro_press &kp LSHFT>, <&macro_tap UPPERCASE>, <&macro_release &kp LSHFT>)
			
		// why does this bug out if i use RELEASE_SHIFT but MACRO_SIMLE doesn't?
		#define MACRO_ACCENT(FIRST, SECOND) \
			MACRO(FIRST##SECOND, <&macro_tap &kp A>) \
			\
			MACRO(cp_##FIRST##SECOND, <&macro_tap &kp A>)


		// accented letters. also defines a caps version (eg &m_cp_ACUT_A_)
		MACRO_ACCENT(ACUT_, A_)
		MACRO_ACCENT(ACUT_, I_)
		MACRO_ACCENT(ACUT_, O_)
		MACRO_ACCENT(ACUT_, U_)
		
		MACRO_ACCENT(CFLX_, A_)
		MACRO_ACCENT(CFLX_, E_)
		MACRO_ACCENT(CFLX_, I_)
		MACRO_ACCENT(CFLX_, O_)
		MACRO_ACCENT(CFLX_, U_)
		
		MACRO_ACCENT(GRAV_, E_)
		MACRO_ACCENT(GRAV_, O_)
		MACRO_ACCENT(GRAV_, U_)
		
		MACRO_ACCENT(TILD_, A_)
		MACRO_ACCENT(TILD_, O_)
		MACRO_ACCENT(TILD_, N_)
		
		MACRO_ACCENT(TRMA_, I_)


		// TODO use MACRO_ACCENT here
		/* qu  */  MACRO_SIMPLE(Q_, U_)
		/* bj  */  MACRO_SIMPLE(B_, J_)
		
		/* QU  */  MACRO_TAP(cp_qu,      &kp LS(Q_) &kp LS(U_))
		/* BJ  */  MACRO_TAP(cp_bj,      &kp LS(B_) &kp LS(J_))
		
		/*  Ñ  */  MACRO_TAP(cp_tl_n,    &kp TILD_  &kp LS(N_))
		
		/* ãe  */  MACRO_TAP(ae,         &kp TILD_  &kp A_  &kp E_)
		/* ão  */  MACRO_TAP(ao,         &kp TILD_  &kp A_  &kp O_)
		/* õe  */  MACRO_TAP(oe,         &kp TILD_  &kp O_  &kp E_)
		
		/* ÃE  */  MACRO_TAP(cp_ae,      &kp TILD_  &kp LS(A_)  &kp LS(E_))
		/* ÃO  */  MACRO_TAP(cp_ao,      &kp TILD_  &kp LS(A_)  &kp LS(O_))
		/* ÕE  */  MACRO_TAP(cp_oe,      &kp TILD_  &kp LS(O_)  &kp LS(E_))
		
		/*  ß  */  MACRO_TAP(eszett,     &kp RA(S_)  &kp    S_)
		/*  ẞ  */  MACRO_TAP(cp_sztt,    &kp RA(S_)  &kp LS(S_))

		/* ■?  */  MACRO_TAP(nbsp_qmrk,  &kp LS(SPACE)  &kp LS(QMRK_))
		/* ■!  */  MACRO_TAP(nbsp_excl,  &kp LS(SPACE)  &kp LS(EXCL_))
		/* ■:□ */  MACRO_TAP(nbsp_coln,  &kp LS(SPACE)  &kp LS(DOT_)   &kp SPACE)
		/* ■;□ */  MACRO_TAP(nbsp_scln,  &kp LS(SPACE)  &kp LS(COMM_)  &kp SPACE)
		/* ■»□ */  MACRO_TAP(nbsp_rglm,  &kp LS(SPACE)  &kp RGLM_)
		/* □«■ */  MACRO_TAP(nbsp_lglm,  &kp LGLM_      &kp LS(SPACE))
			   
		/*  ^  */  MACRO_TAP(cfxloos,    &kp CFLX_  &kp SPACE)
		/*  `  */  MACRO_TAP(grvloos,    &kp GRAV_  &kp SPACE)


		// key and turn off capsword
		MACRO_TAP(cw_spc,  &kp SPACE  &tog CPWD)
		MACRO_TAP(cw_tab,  &kp TAB    &tog CPWD)
		MACRO_TAP(cw_entr, &kp ENTER  &tog CPWD)
		MACRO_TAP(cw_esc,  &kp ESC    &tog CPWD)
		
		MACRO(mo_cw_nav,   <&macro_tap  &tog CPWD>,  <&macro_press  &mo NAV>,   <&macro_pause_for_release>,  <&macro_release &mo NAV>)
		MACRO(mo_cw_sym,   <&macro_tap  &tog CPWD>,  <&macro_press  &mo SYM>,   <&macro_pause_for_release>,  <&macro_release &mo SYM>)
		MACRO(mo_cw_acnt,  <&macro_tap  &tog CPWD>,  <&macro_press  &mo ACNT>,  <&macro_pause_for_release>,  <&macro_release &mo ACNT>)
		MACRO(sk_cw_sym,   <&macro_tap  &tog CPWD  &sk SYM>)
		MACRO(sk_cw_acnt,  <&macro_tap  &tog CPWD  &sk ACNT>)


		// used with security_hold
		MACRO(cut_all,    <&macro_tap  &kp LC(A_)>,  <&macro_pause_for_release>,  <&macro_tap  &kp LC(X_)>)
		MACRO(copy_all,   <&macro_tap  &kp LC(A_)>,  <&macro_pause_for_release>,  <&macro_tap  &kp LC(C_)>)
		MACRO(paste_all,  <&macro_tap  &kp LC(A_)>,  <&macro_pause_for_release>,  <&macro_tap  &kp LC(V_)>)
		
		
		// utility layer, for tabbing through things
		MACRO(util_alt,    <&macro_tap      &tog UTIL>,            <&macro_press  &kp LALT>,   <&macro_pause_for_release>,  <&macro_release  &kp LALT>,   <&macro_tap  &tog UTIL>)
		MACRO(util_ctrl,   <&macro_tap      &tog UTIL>,            <&macro_press  &kp LCTRL>,  <&macro_pause_for_release>,  <&macro_release  &kp LCTRL>,  <&macro_tap  &tog UTIL>)
		
		MACRO(util_guitab, <&macro_release  &kp LALT  &kp LCTRL>,  <&macro_tap    &kp TAB>)
		
	};

	combos {
		compatible = "zmk,combos";

		#define DEFINE_COMBO(LAYERS, BINDINGS, POSITIONS, NAME, TIMEOUT) \
			combo_##NAME { \
				layers = <LAYERS>; \
				bindings = <BINDINGS>; \
				key-positions = <POSITIONS>; \
				timeout-ms = <TIMEOUT>; \
			};
			

		// when not defining layers, will default to NOT_GAME
		// TODO: ok to omit line breaks between defs?
		// TODO: all combos define layers
		#define COMBO(BINDINGS, POSITIONS, RANDOM_NAME) \
			DEFINE_COMBO(NOT_GAME, BINDINGS, POSITIONS, RANDOM_NAME, _COMBO_TIMEOUT)

		#define COMBO_LAYER(LAYERS, BINDINGS, POSITIONS, RANDOM_NAME) \
			DEFINE_COMBO(LAYERS,   BINDINGS, POSITIONS, RANDOM_NAME, _COMBO_TIMEOUT)


		// single key press
		#define COMBO_KP(KEY, SUFFIX, POSITIONS) \
			DEFINE_COMBO(NOT_GAME, &kp KEY, POSITIONS, KEY##SUFFIX, _COMBO_TIMEOUT)

		#define COMBO_KP_LAYER(KEY, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS,   &kp KEY, POSITIONS, KEY##SUFFIX, _COMBO_TIMEOUT)


		// macro
		#define COMBO_MACRO(MACRO, POSITIONS) \
			DEFINE_COMBO(NOT_GAME, &m_##MACRO, POSITIONS, MACRO, _COMBO_TIMEOUT)

		// macro layer
		#define COMBO_MACRO_LAYER(MACRO, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS,   &m_##MACRO, POSITIONS, MACRO##SUFFIX, _COMBO_TIMEOUT)

		// macro layer sloooowwww - for dangerous macros (xcv all)
		#define COMBO_MACRO_LAYER_SLOW(MACRO, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS,   &m_##MACRO, POSITIONS, MACRO##SUFFIX, _COMBO_TIMEOUT_SLOW)


	/*
	    0   1   2   3      4 | 5      6   7   8   9
	    10  11  12  13    14 | 15    16  17  18  19
	    20  21  22  23    24 | 25    26  27  28  29
							 |
	                   30 31 | 32 33
	*/

		// fake tab
		// COMBO(&kp SPACE &kp SPACE &kp SPACE &kp SPACE, 10 11 12 13,       gslqaiogrnqsl) // whatever name. enjoy
		// COMBO(&kp SPACE &kp SPACE &kp SPACE &kp SPACE, 16 17 18 19,       rgsaiornqsj)																	   
		COMBO_KP(SPACE,l,          11 12 13)
		COMBO_KP(SPACE,r,          16 17 18)

		// backspace and del, with and wo ctrl
		COMBO_KP( BSPC,,           11 12)
		COMBO_KP( DEL,,            21 22)
		COMBO(&kp LC(BSPC),        17 18, gslqgrnqsl) // whatever name. enjoy
		COMBO(&kp LC(DEL),         27 28, rgsrnteqsj)

		// one-shot shift on both thumb keys at once
		COMBO(&lsk FUNC LSHIFT,    30 31, dljsdiqsrt)
		COMBO(&sk  RSHIFT,         32 33, sqljqrjqsl)
								              
		COMBO_MACRO_LAYER(Q_U_,,   26 27, BASE) /* qu */  
		COMBO_MACRO_LAYER(ae,,     13 30, BASE) /* ãe */  
		COMBO_MACRO_LAYER(ao,,     13 11, BASE) /* ão */  
		COMBO_MACRO_LAYER(oe,,     11 30, BASE) /* õe */  
					                            			
		COMBO_MACRO_LAYER(cp_qu,,  26 27, CPWD) /* QU */  
		COMBO_MACRO_LAYER(cp_ae,,  13 30, CPWD) /* ÃE */  
		COMBO_MACRO_LAYER(cp_ao,,  13 11, CPWD) /* ÃO */  
		COMBO_MACRO_LAYER(cp_oe,,  11 30, CPWD) /* ÕE */  
								      
		// tab, enter, esc          
		COMBO_KP_LAYER(TAB,,         12 13, NOT_CPWD)
		COMBO_KP_LAYER(ENTER,,       16 17, NOT_CPWD)
		COMBO_KP_LAYER(ESC,,         10 11, NOT_CPWD)
								    
		COMBO_MACRO_LAYER(cw_tab,,   12 13, CPWD)
		COMBO_MACRO_LAYER(cw_entr,,  16 17, CPWD)
		COMBO_MACRO_LAYER(cw_esc,,   10 11, CPWD)
		
		// COMBO_MACRO_LAYER_SLOW(util_alt,,       20, BASE)
		// COMBO_MACRO_LAYER_SLOW(util_ctr,,       21, BASE)
		
		COMBO(            &kp LC(Z_),   20 21, rgsriaiaiqsj)
		COMBO_LAYER(FUNC, &sys_reset,    0  4, aiouaiouaiou)
		COMBO_LAYER(FUNC, &bootloader,  20 24, ayuqaioueaio)
		COMBO_LAYER(FUNC, &tog GAME,     4 14, aiouayopaipo)
		COMBO_LAYER(FUNC, &tog GAM2,    14 24, aiopoappyaio)
		
	};

	keymap {
		compatible = "zmk,keymap";

        // readability
		#define _____      &trans
		#define xxxxx      &none
		#define _________  &trans
		#define xxxxxxxxx  &none

        // readability also
		#define C_S_DEL      &kp LC(LS(DEL))    // task manager
		#define PASTEPLAIN   &kp LC(LG(LA(V_))) // power toys plaintext paste (no &kp bc used in &ht)
		#define RESET_LEFT   &sys_reset   	    // mnemonic (called on the right it resets both)

		// home-row mods
		#define HMLS    &htl     LSHIFT // left shift only works for keys on right hand
		#define HMRS    &htr     RSHIFT // rite shift only works for keys on lefft hand
		#define HMLC    &ht      LCTRL
		#define HMRC    &ht      RCTRL
		#define HMLA    &ht      LALT
		#define HMRA    &ht      RALT
		#define HMLG    &htslow  LGUI // i kept holding GUI by accident, so i made it slower
		#define HMRG    &htslow  RGUI // 
		
		 // sticky mods in nav layer
		#define SKLS    &htsk   LSHIFT
		#define SKLC    &htsk   LCTRL
		#define SKLA    &htsk   LALT
		#define SKLG    &htsk   LGUI

		// tap/hold  (□ = space, ■ = nbsp)              
		// TAP    HOLD
		/*  $     €    */ #define DLLR_EURO   &htslow    EURO_  DLLR_     
		/*  =     ≠    */ #define EQUL_DIFF   &htslow    DIFF_  EQUL_     
											 		   
		/* (?)    ■?   */ #define NBSP_QMRK   &ht_qmrk   0      QMRK_     
		/*  ¿     ¡    */ #define IEXCL_IQMRK &htslow RA(EXCL_) RA(QMRK_) 
		/* (!)    ■!   */ #define NBSP_EXCL   &ht_excl   0      EXCL_     
		/* (.)    ■:□  */ #define DOT_COLN    &ht_coln   0      DOT_      
		/* (,)    ■;□  */ #define COMM_SCLN   &ht_scln   0      COMM_     
									  	      	       
		/* «■     («)  */ #define NBSP_LGLM   &ht_lglm   LGLM_  0         
		/*  ■»    (»)  */ #define NBSP_RGLM   &ht_rglm   RGLM_  0         

		#define CUT_ALL     &sechold_cutall   0 &none   //         cut   all	// DANGEROUS STUFF!
		#define COPY_ALL    &sechold_copyall  0 &none   //         copy  all	//  must hold for
		#define PASTE_ALL   &sechold_pasteall 0 &none   //         paste all	//  very long time
		
		#define UTCTRL &util_ctrl 0
		#define UTALT  &util_alt  0
															      
		// #define HT_CTRZ      &ht     LC(Y_)  LC(Z_)  // ^Z      ^Y
		// #define HT_CTRV      &ht PASTEPLAIN  LC(V_)  // ^V      plaintext paste (powertoys)

		// thumb keys
		#define TH_L_MAIN      &lt   NUM E_
		#define TH_L_MAIN_CW   &lt   NUM LS(E_)

		#define TH_L_AUX       &lsl    SYM  SYM
		#define TH_L_AUX_CW    &lsl_cw_sym 0 0

		#define TH_R_MAIN      &lt    NAV SPACE
		#define TH_R_MAIN_CW   &ht_cw_nav_spc 0 0

		#define TH_R_AUX       &lsl  ACNT ACNT
		#define TH_R_AUX_CW    &lsl  ACCW ACCW


                                      // --- left hand --- //         // --- right hand --- //
		#define _THUMBS_LEFT_         TH_L_MAIN     TH_L_AUX        
		#define _THUMBS_RIGHT_                                          TH_R_AUX      TH_R_MAIN
		#define _THUMBS_CAPSWORD_     TH_L_MAIN_CW  TH_L_AUX_CW         TH_R_AUX_CW  TH_R_MAIN_CW
		#define _THUMBS_DEFAULT_            _THUMBS_LEFT_                    _THUMBS_RIGHT_
	 


		// todo reorder layers according to thumbs
		base_layer {
			bindings = <
				&kp    Q_  HMRA   MIN_   &kp  Y_  DOT_COLN   NBSP_QMRK         &kp K_   &kp  C_   &kp  H_   &kp  W_   &kp  J_
				HMLG   U_  HMLA   O_     HMLC I_  HMLS A_    &kp F_            &kp G_   HMRS T_   HMRC R_   HMRA S_   HMRG N_
				UTALT Z_   UTCTRL EACT_  &kp  P_  COMM_SCLN  &kp X_            &kp V_   &kp  D_   &kp  M_   &kp  L_   &kp  B_
				//
															       _THUMBS_DEFAULT_
			>;
		};

		caps_word_layer {
			bindings = <
				&kp  LS(Q_)	 HMRA MIN_       &kp  LS(Y_)  DOT_COLN       _________          &kp LS(K_)    &kp  LS(C_)  &kp  LS(H_)  &kp  LS(W_)  &kp  LS(J_)
				HMLG LS(U_)	 HMLA LS(O_)	 HMLC LS(I_)  HMLS LS(A_)    &kp LS(F_)         &kp LS(G_)    HMRS LS(T_)  HMRC LS(R_)  HMRA LS(S_)  HMRG LS(N_)
				&kp  LS(Z_)	 &kp  LS(EACT_)	 &kp  LS(P_)  COMM_SCLN      &kp LS(X_)         &kp LS(V_)    &kp  LS(D_)  &kp  LS(M_)  &kp  LS(L_)  &kp  LS(B_)
				//
														                     _THUMBS_CAPSWORD_
			>;
		};

		num_layer {
			bindings = <
				&kp PIPE_  &kp N7_  &kp N8_  &kp N9_    xxxxxxxxx         DLLR_EURO    &kp  LBRK_  &kp  RBRK_   &kp  HASH_   &kp  PCNT_
				&kp N0_    &kp N1_  &kp N2_  &kp N3_    &kp DOT_          xxxxxxxxx    HMRS PLUS_  HMRC MIN_    HMLA STAR_   HMRG FSLA_
				xxxxxxxxx  &kp N4_  &kp N5_  &kp N6_    &kp COMM_         xxxxxxxxx    &kp  LT_    &kp  GT_	    EQUL_DIFF    &kp  BSLA_
				//
				                                    _THUMBS_LEFT_         &kp ULIN_    _________
			>;
		};

		utility_layer {
			bindings = <
				_________   _________    _________        _________      _____         _____    _________   _________    _________        _________
				_________   _________    _________        &m_util_guitab _____         _____    _________   _________    _________        _________
				_________   _________    _________        _________      _____         _____    _________   _________    _________        _________
				//
			                                              &kp TAB   &kp LS(TAB)        xxxxx    xxxxx
			>;
		};

		sym_layer {
			bindings = <
				&kp AE_		 &kp AT_       &kp AMPR_   &kp OE_       NBSP_EXCL         xxxxx    DLLR_EURO    xxxxxxxxx    xxxxxxxxx    xxxxxxxxx
				SKLG LCRL_	 SKLA RCRL_    SKLC LPAR_  SKLS RPAR_    &kp MDSH_         xxxxx    HMRS xxxxx   HMRC xxxxx   HMRA xxxxx   HMRG PIPE_
				&kp NDSH_	 &kp MDSH_     NBSP_LGLM   NBSP_RGLM     xxxxxxxxx         xxxxx    xxxxxxxxx    &m_grvloos   &m_cfxloos   xxxxxxxxx
				//
								                       _________     &kp ULIN_        _THUMBS_RIGHT_
			>;
		};

		accent_layer {
			bindings = <
				&m_CFLX_U_  &m_CFLX_O_  &m_CFLX_I_  &m_CFLX_A_    IEXCL_IQMRK        xxxxxxxxx    &kp  CCED_  &kp  APST_  &kp  QUOT_  &m_B_J_
				&m_ACUT_U_  &m_ACUT_O_  &m_ACUT_I_  &m_ACUT_A_    &m_TILD_A_         xxxxxxxxx    HMRS ACUT_  HMRC GRAV_  HMLA CFLX_  &m_TILD_N_
				&m_GRAV_U_  &m_TILD_O_  &m_TRMA_I_  &kp AGRV_     xxxxxxxxx          xxxxxxxxx    &kp  TRMA_  xxxxxxxxx   &m_eszett   &kp TILD_
				//
												    &m_CFLX_E_    &kp EGRV_         _THUMBS_RIGHT_
			>;
		};

		accent_caps_layer {
			bindings = <
				&m_cp_CFLX_U_  &m_cp_CFLX_O_  &m_cp_CFLX_I_  &m_cp_CFLX_A_    xxxxxxxxx             xxxxxxxxx    &kp  CCED_  &kp  APST_  &kp  QUOT_  &m_cp_bj
				&m_cp_ACUT_U_  &m_cp_ACUT_O_  &m_cp_ACUT_I_  &m_cp_ACUT_A_    &m_cp_TILD_A_         xxxxxxxxx    HMRS ACUT_  HMRC GRAV_  HMLA CFLX_  &m_cp_tl_n
				&m_cp_GRAV_U_  &m_cp_TILD_O_  &m_cp_TRMA_I_  &kp LS(AGRV_)    xxxxxxxxx             xxxxxxxxx    &kp  TRMA_  xxxxxxxxx   &m_cp_sztt  &kp TILD_
				//
												             &m_cp_CFLX_E_    &kp LS(EGRV_)        _THUMBS_RIGHT_
			>;
		};

		nav_layer {
			bindings = <
				&kp xxxxx	CUT_ALL	    COPY_ALL     PASTE_ALL     C_S_DEL            &sk  RALT    HMLS LC(HOME)   HMLC PG_DN   HMLA PG_UP   HMRG LC(END)
				HMLG LC(Y_) HMLA INSERT	HMLC PSCRN	 HMLS PSBRK    &kp CAPS           &tog CPWD    &kp  LC(LEFT)   &kp  DOWN	&kp  UP	     &kp  LC(RIGHT)
				&kp  LC(Z_)	&kp  LC(X_)	&kp  LC(C_)	 &kp  LC(V_)   PASTEPLAIN         xxxxxxxxx    &kp  HOME       &kp  LEFT	&kp  RIGHT   &kp  END
				//
												                           _THUMBS_DEFAULT_
			>;
		};

		func_layer {
			bindings = <
				&bt  BT_CLR     &bt  BT_SEL 0   &bt  BT_SEL 1   &bt  BT_SEL 2  &bt BT_SEL 3         RESET_LEFT    &kp F7  &kp F8  &kp F9  &kp F12
				HMLG C_BRI_UP   HMLA C_NEXT     HMLC C_VOL_UP   HMLS C_PP  	   &kp LSLCK            &out OUT_BLE  &kp F1  &kp F2  &kp F3  &kp F10
				&kp  C_BRI_DN   &kp  C_PREV     &kp  C_VOL_DN   &kp  C_MUTE    &kp LNLCK            &out OUT_USB  &kp F4  &kp F5  &kp F6  &kp F11
				//
															                           _THUMBS_DEFAULT_
			>;
		};

		game_layer {
			bindings = <
				&kp Q_      &kp MIN_   &kp Y_     &kp DOT_     &kp R_            &kp  K_      &kp C_     &kp H_     &kp W_     &kp J_
				&kp U_      &kp O_     &kp I_     &kp A_       &kp F_            &kp  G_      &kp LEFT   &kp UP     &kp RIGHT  &kp N_
				&kp Z_      &kp S_     &kp P_     &kp COMM_    &kp X_            &tog GAME    &kp D_     &kp DOWN   &kp L_     &kp B_
				//
											      &kp ENTER    &kp SPACE         &kp  TAB     &kp LALT
			>;
		};

		game_layer_2 {
			bindings = <
				&kp LSHIFT  &kp A_     &kp EACT_  &kp I_      &kp O_            &kp  Y_      &kp U_     &kp I_     &kp O_     &kp P_
				&kp LCTRL   &kp B_     &kp U_     &kp P_      &kp E_            &kp  H_      &kp J_     &kp K_     &kp L_     &kp N_
				&kp ESC     &kp AGRV_  &kp Y_     &kp X_      &kp DOT           &tog GAM2    &kp M_     &kp COMM_	 &kp DOT_   &kp BSPC
				//
												  &kp ENTER   &kp SPACE         &kp  TAB   &kp LALT
			>;
		};

		/* FOR DEBUGGING:
			bindings = <
				xxxxx xxxxx xxxxx xxxxx   xxxxx         xxxxx   xxxxx xxxxx xxxxx xxxxx
				xxxxx xxxxx xxxxx xxxxx   xxxxx         xxxxx   xxxxx xxxxx xxxxx xxxxx
				xxxxx xxxxx xxxxx xxxxx   xxxxx         xxxxx   xxxxx xxxxx xxxxx xxxxx
			                   xxxxx   xxxxx         xxxxx   xxxxx
			>;
		*/
	};
};