#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/outputs.h>

#include "bepo_bindings.h"

// SETTINGS
#define _MACRO_INTERVAL      3    // tested: 3+. how long to wait between key presses
#define _MACRO_TAP_FOR       3    // tested: 3+. how long to tap for in macros

// combo: maximum interval between keys to form combo
#define _COMBO_TIMEOUT       18   // tested: 16
#define _COMBO_TIMEOUT_SLOW  50   // tested: 16

// holdtap: how long must hold to not be tap
#define _TAP_TERM_SLOWEST    1200 // for dangerous xcv-all
#define _TAP_TERM_SLOW       300
#define _TAP_TERM            300  //tested: 250
#define _TAP_TERM_FAST       200
#define _TAP_TERM_FASTER     120
						    
// holdtap: how fast must press twice for second to start repeating tap
#define _QUICK_TAP           200
						    
#define _STICKY_TIMEOUT      2000 // tested: 1000+

// LAYERS
#define L_BASE 0 
#define L_CPWD 1 
#define L_NUM  2 
#define L_UTIL 3 
#define L_SYM  4 
#define L_ACNT 5 
#define L_ACCW 6 
#define L_NAV  7
#define L_FUNC 8 
#define L_GAME 9 
#define L_GAM2 10

// combos shouldn't work on game layer, to minimize delay
#define L_ALL_LAYERS   L_BASE  L_CPWD  L_UTIL  L_SYM  L_ACNT  L_ACCW  L_NUM  L_NAV  L_FUNC  L_GAME  L_GAM2
#define L_NOT_GAME     L_BASE  L_CPWD  L_UTIL  L_SYM  L_ACNT  L_ACCW  L_NUM  L_NAV  L_FUNC
#define L_NOT_CPWD     L_BASE          L_UTIL  L_SYM  L_ACNT  L_ACCW  L_NUM  L_NAV  L_FUNC


&lt { // tap for kp, hold for layer
	tapping-term-ms = <_TAP_TERM>;
	flavor = "balanced";
	quick-tap-ms = <_QUICK_TAP>;
};

&mt { // hold-tap
	tapping-term-ms = <_TAP_TERM_FASTER>;
	quick-tap-ms = <_QUICK_TAP>;
};

&sk { // one-shot layer
	release-after-ms = <_STICKY_TIMEOUT>;
	quick-release;
};

/ {
	behaviors {
		#define DEFINE_HOLDTAP(NAME, FLAVOR, DELAY, BINDINGS...) \
			NAME: ht_##NAME { \
				label = #NAME; \
				flavor = #FLAVOR; \
				tapping-term-ms = <DELAY>; \
				bindings = BINDINGS; \
				#binding-cells = <2>; \
				compatible = "zmk,behavior-hold-tap"; \
				quick-tap-ms = <_QUICK_TAP>;

		#define HOLDTAP(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM, BINDINGS) \
			};

		#define HOLDTAP_QUICK(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM_FAST, BINDINGS) \
			};

		#define HOLDTAP_BAL(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, balanced, _TAP_TERM, BINDINGS) \
			};

		#define HRMOD_POS(NAME, POSITIONS) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM, <&kp>, <&kp>) \
					hold-trigger-key-positions = <POSITIONS>; \
			};

		#define HOLDTAP_SLOW(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM_SLOW, BINDINGS) \
			};
			
		#define SECURITY_HOLD(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, _TAP_TERM_SLOWEST, BINDINGS) \
			};

		// home-row mods                    // PRESS           HOLD
		HOLDTAP(     ht,     <&kp>, <&kp>) // &kp             &kp
		HOLDTAP(     htsk,   <&sk>, <&kp>) // &kp             sticky layer
		HOLDTAP(     ltt,    <&mo>, <&kp>) // &kp             hold layer    (inherits tap-preferred from HOLDTAP)
		HOLDTAP_BAL( lsk,    <&mo>, <&sk>) // one-shot mod    hold layer
		HOLDTAP_BAL( lsl,    <&mo>, <&sl>) // one-shot layer  hold layer
		
		HOLDTAP_SLOW(htslow, <&kp>, <&kp>) // !! UNUSED !!

		// hrm for opposite hand only (used for shift)
		HRMOD_POS(htl, 5 6 7 8 9 15 16 17 18 19 25 26 27 28 29 32 33)
		HRMOD_POS(htr, 0 1 2 3 4 10 11 12 13 14 20 21 22 23 24 30 31)
		
		
		// gotta hold these for a long time just to make sure
		SECURITY_HOLD(sechold_cutall,   <&m_cut_all>,   <&kp>)
		SECURITY_HOLD(sechold_copyall,  <&m_copy_all>,  <&kp>)
		SECURITY_HOLD(sechold_pasteall, <&m_paste_all>, <&kp>)
		
		//deactivates capsword, then...                       // PRESS           HOLD
		HOLDTAP_BAL( ht_cw_L_NAV_spc, <&m_mo_cw_L_NAV>,  <&m_cw_spc>)    // space           hold L_NAV
		HOLDTAP_BAL(lsl_cw_L_SYM,     <&m_mo_cw_L_SYM>,  <&m_sk_cw_L_SYM>) // one-shot L_SYM    hold L_SYM
		
		
		HOLDTAP(util_layer, <&m_util_layer>, <&kp>) // &kp             hold layer    (inherits tap-preferred from HOLDTAP)

		// automatic nbsp on tap
		HOLDTAP(ht_lglm, <&kp>, <&m_nbsp_lglm>)
		HOLDTAP(ht_rglm, <&kp>, <&m_nbsp_rglm>)

		// automatic nbsp on hold
		HOLDTAP_QUICK(ht_coln, <&m_nbsp_coln>, <&kp>)
		HOLDTAP_QUICK(ht_scln, <&m_nbsp_scln>, <&kp>)
		HOLDTAP_QUICK(ht_qmrk, <&m_nbsp_qmrk>, <&kp>)
		HOLDTAP_QUICK(ht_excl, <&m_nbsp_excl>, <&kp>)
	};

	macros {
		// convenience
		#define RELEASE_SHIFT <&macro_release &kp LSHFT &kp RSHFT>
	
		#define ALL_MODS    &kp LSHFT &kp LALT &kp LCTRL // notepad++ bugs if ctrl is not last
		#define M_TAP       &macro_tap
		#define M_TAP_KP    &macro_tap &kp
		#define M_HOLD      &macro_press
		#define M_REL       &macro_release
		#define M_WAIT_REL <&macro_pause_for_release>
		
		// macro macros
		#define MACRO(NAME, BINDINGS...) \
			ZMK_MACRO(m_##NAME, \
				tap-ms   = <_MACRO_TAP_FOR>; \
				wait-ms  = <_MACRO_INTERVAL>; \
				bindings = BINDINGS; \
				)

		// names the macro "m_FIRST##SECOND", eg "m_Q_U_"
		#define MACRO_SIMPLE(FIRST, SECOND) \
			MACRO(FIRST##SECOND, <&macro_tap &kp FIRST>, RELEASE_SHIFT, <&macro_tap &kp SECOND>)
			
		#define MACRO_TAP(NAME, BINDINGS...) \
			MACRO(NAME, <&macro_tap BINDINGS>)
					
		// #define MACRO_LAST_UPPER(FIRST, UPPERCASE...) \
			// MACRO(cw_##FIRST##SECOND, <&macro_tap &kp FIRST>, <&macro_press &kp LSHFT>, <&macro_tap UPPERCASE>, <&macro_release &kp LSHFT>)
						
						
		// #define MACRO_ACCENT_COMPLEX(NAME, FIRST, UPPERCASE...) \
			// MACRO(NAME, <&macro_tap &kp FIRST>, <&macro_tap UPPERCASE>) \ //need this redundant macro_tap?
			// \
			// MACRO(cw_##NAME, <&macro_tap &kp FIRST>, <&macro_press &kp LSHFT>, <&macro_tap UPPERCASE>, <&macro_release &kp LSHFT>)
			
		// why does this bug out if i use RELEASE_SHIFT but MACRO_SIMLE doesn't?
		#define MACRO_ACCENT(FIRST, SECOND) \
			MACRO(FIRST##SECOND, <&macro_tap &kp FIRST>, <&macro_release &kp LSHFT &kp RSHFT>, <&macro_tap &kp SECOND>) \
			\
			MACRO(cw_##FIRST##SECOND, <&macro_tap &kp FIRST>, <&macro_press &kp LSHFT>, <&macro_tap &kp SECOND>, <&macro_release &kp LSHFT>)

			
			// #define MACRO_ACCENT_COMPLEX(FIRST##SECOND, FIRST, &kp SECOND)

		// ACCENTED LETTERS
		// also defines a caps version (eg &m_cw_ACUT_A_)
		MACRO_ACCENT(ACUT_, A_)
		MACRO_ACCENT(ACUT_, I_)
		MACRO_ACCENT(ACUT_, O_)
		MACRO_ACCENT(ACUT_, U_)
		
		MACRO_ACCENT(CFLX_, A_)
		MACRO_ACCENT(CFLX_, E_)
		MACRO_ACCENT(CFLX_, I_)
		MACRO_ACCENT(CFLX_, O_)
		MACRO_ACCENT(CFLX_, U_)
		
		MACRO_ACCENT(GRAV_, E_)
		MACRO_ACCENT(GRAV_, O_)
		MACRO_ACCENT(GRAV_, U_)
		
		MACRO_ACCENT(TILD_, A_)
		MACRO_ACCENT(TILD_, O_)
		MACRO_ACCENT(TILD_, N_)
		
		MACRO_ACCENT(TRMA_, I_)

		// TODO use MACRO_ACCENT here
		/* qu  */  MACRO_SIMPLE(Q_, U_)
		/* bj  */  MACRO_SIMPLE(B_, J_)
		/* QU  */  MACRO_TAP(cw_qu,      &kp LS(Q_) &kp LS(U_))
		/* BJ  */  MACRO_TAP(cw_bj,      &kp LS(B_) &kp LS(J_))
				
		/* ãe  */  MACRO_TAP(ae,         &kp TILD_  &kp A_  &kp E_)
		/* ão  */  MACRO_TAP(ao,         &kp TILD_  &kp A_  &kp O_)
		/* õe  */  MACRO_TAP(oe,         &kp TILD_  &kp O_  &kp E_)
		/* ÃE  */  MACRO_TAP(cw_ae,      &kp TILD_  &kp LS(A_)  &kp LS(E_))
		/* ÃO  */  MACRO_TAP(cw_ao,      &kp TILD_  &kp LS(A_)  &kp LS(O_))
		/* ÕE  */  MACRO_TAP(cw_oe,      &kp TILD_  &kp LS(O_)  &kp LS(E_))
				
		/*  ß  */  MACRO_TAP(eszett,     &kp RA(S_)  &kp    S_)
		/*  ẞ  */  MACRO_TAP(cw_sztt,    &kp RA(S_)  &kp LS(S_))

		/*  Ñ  */  MACRO_TAP(cw_tl_n,    &kp TILD_  &kp LS(N_))


		// nbsp stuff (for french)
		/* ■?  */  MACRO_TAP(nbsp_qmrk,  &kp LS(SPACE)  &kp LS(QMRK_))
		/* ■!  */  MACRO_TAP(nbsp_excl,  &kp LS(SPACE)  &kp LS(EXCL_))
		/* ■:□ */  MACRO_TAP(nbsp_coln,  &kp LS(SPACE)  &kp LS(DOT_)   &kp SPACE)
		/* ■;□ */  MACRO_TAP(nbsp_scln,  &kp LS(SPACE)  &kp LS(COMM_)  &kp SPACE)
		/* ■»□ */  MACRO_TAP(nbsp_rglm,  &kp LS(SPACE)  &kp RGLM_)
		/* □«■ */  MACRO_TAP(nbsp_lglm,  &kp LGLM_      &kp LS(SPACE))
			   
			   
		// loose accents
		/*  ^  */  MACRO_TAP(cfxloos,    &kp CFLX_  &kp SPACE)
		/*  `  */  MACRO_TAP(grvloos,    &kp GRAV_  &kp SPACE)

		// CAPSWORD
		// key and turn off capsword
		MACRO_TAP(cw_spc,  &kp SPACE  &tog L_CPWD)
		MACRO_TAP(cw_tab,  &kp TAB    &tog L_CPWD)
		MACRO_TAP(cw_entr, &kp ENTER  &tog L_CPWD)
		MACRO_TAP(cw_esc,  &kp ESC    &tog L_CPWD)
		
		//layer and turn off caps word
		MACRO(mo_cw_L_NAV,   <M_TAP &to L_NAV>,  M_WAIT_REL,  <M_TAP &to L_BASE>)
		MACRO(mo_cw_L_SYM,   <M_TAP &to L_NAV>,  M_WAIT_REL,  <M_TAP &to L_BASE>)
		MACRO(mo_cw_L_ACNT,  <M_TAP &to L_NAV>,  M_WAIT_REL,  <M_TAP &to L_BASE>)
		MACRO(sk_cw_L_SYM,   <M_TAP  &to L_BASE  &sk L_SYM>)
		MACRO(sk_cw_L_ACNT,  <M_TAP  &to L_BASE  &sk L_ACNT>)
		
		
		// used with security_hold
		MACRO(cut_all,    <M_TAP_KP  LC(A_)>,  M_WAIT_REL,  <M_TAP_KP  LC(X_)>)
		MACRO(copy_all,   <M_TAP_KP  LC(A_)>,  M_WAIT_REL,  <M_TAP_KP  LC(C_)>)
		MACRO(paste_all,  <M_TAP_KP  LC(A_)>,  M_WAIT_REL,  <M_TAP_KP  LC(V_)>)
		
		
		// util layer
		MACRO(util_layer, <M_TAP  &to L_UTIL>,  <M_HOLD  ALL_MODS>,  M_WAIT_REL,  <M_REL  ALL_MODS>,  <M_TAP  &to L_BASE>)
								  
		MACRO(util_ctab,  <M_REL  &kp LSHFT             &kp LALT>,   <M_TAP_KP  TAB>,       <M_HOLD  ALL_MODS>)
		MACRO(util_cstab, <M_REL                        &kp LALT>,   <M_TAP_KP  TAB>,       <M_HOLD  ALL_MODS>)
		MACRO(util_atab,  <M_REL  &kp LSHFT  &kp LCTRL          >,   <M_TAP_KP  TAB>,       <M_HOLD  ALL_MODS>)
		MACRO(util_astab, <M_REL             &kp LCTRL          >,   <M_TAP_KP  TAB>,       <M_HOLD  ALL_MODS>)
		MACRO(util_gtab,  <M_REL  ALL_MODS>,                         <M_TAP_KP  LG(TAB)>,   <M_HOLD  ALL_MODS>)
		
	};

	combos {
		compatible = "zmk,combos";

		#define DEFINE_COMBO(LAYERS, BINDINGS, POSITIONS, NAME, TIMEOUT) \
			combo_##NAME { \
				layers = <LAYERS>; \
				bindings = <BINDINGS>; \
				key-positions = <POSITIONS>; \
				timeout-ms = <TIMEOUT>; \
			};
			

		// when not defining layers, will default to L_NOT_GAME
		// TODO: ok to omit line breaks between defs?
		// TODO: all combos define layers
		#define COMBO(BINDINGS, POSITIONS, RANDOM_NAME) \
			DEFINE_COMBO(L_NOT_GAME, BINDINGS, POSITIONS, RANDOM_NAME, _COMBO_TIMEOUT)

		#define COMBO_LAYER(LAYERS, BINDINGS, POSITIONS, RANDOM_NAME) \
			DEFINE_COMBO(LAYERS,   BINDINGS, POSITIONS, RANDOM_NAME, _COMBO_TIMEOUT)


		// single key press
		#define COMBO_KP(KEY, SUFFIX, POSITIONS) \
			DEFINE_COMBO(L_NOT_GAME, &kp KEY, POSITIONS, KEY##SUFFIX, _COMBO_TIMEOUT)

		#define COMBO_KP_LAYER(KEY, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS,   &kp KEY, POSITIONS, KEY##SUFFIX, _COMBO_TIMEOUT)


		// macro
		#define COMBO_MACRO(MACRO, POSITIONS) \
			DEFINE_COMBO(L_NOT_GAME, &m_##MACRO, POSITIONS, MACRO, _COMBO_TIMEOUT)

		// macro layer
		#define COMBO_MACRO_LAYER(MACRO, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS,   &m_##MACRO, POSITIONS, MACRO##SUFFIX, _COMBO_TIMEOUT)

		// macro layer sloooowwww - for dangerous macros (xcv all)
		#define COMBO_MACRO_LAYER_SLOW(MACRO, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS,   &m_##MACRO, POSITIONS, MACRO##SUFFIX, _COMBO_TIMEOUT_SLOW)


	/*
	    0   1   2   3      4 | 5      6   7   8   9
	    10  11  12  13    14 | 15    16  17  18  19
	    20  21  22  23    24 | 25    26  27  28  29
							 |
	                   30 31 | 32 33
	*/

		COMBO_KP(SPACE,l,                    11 12 13)
		COMBO_KP(SPACE,r,                    16 17 18)

		// backspace and del, with and wo ctrl
		COMBO_KP( BSPC,,                     11 12)
		COMBO_KP( DEL,,                      21 22)
		COMBO(&kp LC(BSPC),                  17 18, gslqgrnqsl) // whatever name. enjoy
		COMBO(&kp LC(DEL),                   27 28, rgsrnteqsj)

		// one-shot shift on both thumb keys at once
		COMBO(&lsk L_FUNC LSHIFT,              30 31, dljsdiqsrt)
		COMBO(&sk  RSHIFT,                   32 33, sqljqrjqsl)
								              
		COMBO_MACRO_LAYER(Q_U_,,   26 27, L_BASE) /* qu */  
		COMBO_MACRO_LAYER(ae,,     13 30, L_BASE) /* ãe */  
		COMBO_MACRO_LAYER(ao,,     13 11, L_BASE) /* ão */  
		COMBO_MACRO_LAYER(oe,,     11 30, L_BASE) /* õe */  
					                            			
		COMBO_MACRO_LAYER(cw_qu,,  26 27, L_CPWD) /* QU */  
		COMBO_MACRO_LAYER(cw_ae,,  13 30, L_CPWD) /* ÃE */  
		COMBO_MACRO_LAYER(cw_ao,,  13 11, L_CPWD) /* ÃO */  
		COMBO_MACRO_LAYER(cw_oe,,  11 30, L_CPWD) /* ÕE */  
								      
		// tab, enter, esc            
		COMBO_KP_LAYER(TAB,,                 12 13, L_NOT_CPWD)
		COMBO_KP_LAYER(ENTER,,               16 17, L_NOT_CPWD)
		COMBO_KP_LAYER(ESC,,                 10 11, L_NOT_CPWD)
		
		COMBO_MACRO_LAYER(cw_tab,,         12 13, L_CPWD)
		COMBO_MACRO_LAYER(cw_entr,,        16 17, L_CPWD)
		COMBO_MACRO_LAYER(cw_esc,,         10 11, L_CPWD)
		
		COMBO(              &kp LC(Z_),        20 21, rgsriaiaiqsj)
		COMBO_LAYER(L_FUNC, &sys_reset,         0  4, aiouaiouaiou)
		COMBO_LAYER(L_FUNC, &bootloader,       20 24, ayuqaioueaio)
		COMBO_LAYER(L_FUNC, &tog L_GAME,          4 14, aiouayopaipo)
		COMBO_LAYER(L_FUNC, &tog L_GAM2,         14 24, aiopoappyaio)
	};

	keymap {
		compatible = "zmk,keymap";

        // readability
		#define _____      &trans
		#define xxxxx      &none
		#define _________  &trans
		#define xxxxxxxxx  &none
		
		#define C_S_DEL      &kp LC(LS(DEL))    // task manager
		#define PASTEPLAIN   &kp LC(LG(LA(V_))) // power toys plaintext paste (no &kp bc used in &ht)
		#define RESET_LEFT   &sys_reset   	    // mnemonic (called on the right it resets both)

		// home-row mods
		#define HMLS    &htl     LSHIFT // left shift only works for keys on right hand
		#define HMRS    &htr     RSHIFT // rite shift only works for keys on lefft hand
		#define HMLC    &ht      LCTRL
		#define HMRC    &ht      RCTRL
		#define HMLA    &ht      LALT
		#define HMRA    &ht      RALT
		#define HMLG    &htslow  LGUI // i kept holding GUI by accident,
		#define HMRG    &htslow  RGUI // so i made it slower
		
		 // sticky mods in nav layer
		#define SKLS    &htsk   LSHIFT
		#define SKLC    &htsk   LCTRL
		#define SKLA    &htsk   LALT
		#define SKLG    &htsk   LGUI

		// tap/hold  (□ = space, ■ = nbsp)              // TAP    HOLD
		#define DLLR_EURO   &htslow    EURO_  DLLR_     //  $     €
		#define EQUL_DIFF   &htslow    DIFF_  EQUL_     //  =     ≠
											 		   
		#define NBSP_QMRK   &ht_qmrk   0      QMRK_     // (?)    ■?
		#define IEXCL_IQMRK &htslow RA(EXCL_) RA(QMRK_) //  ¿     ¡
		#define NBSP_EXCL   &ht_excl   0      EXCL_     // (!)    ■!
		#define DOT_COLN    &ht_coln   0      DOT_      // (.)    ■:□
		#define COMM_SCLN   &ht_scln   0      COMM_     // (,)    ■;□
									  	      	       
		#define NBSP_LGLM   &ht_lglm   LGLM_  0         // «■     («)
		#define NBSP_RGLM   &ht_rglm   RGLM_  0         //  ■»    (»)

		// DANGEROUS STUFF! must hold for very long time
		#define CUT_ALL     &sechold_cutall   0 &none   // &none   cut all    
		#define COPY_ALL    &sechold_copyall  0 &none   // &none   copy all
		#define PASTE_ALL   &sechold_pasteall 0 &none   // &none   paste all
		
		
		#define UTLAYR &util_layer 0
										
		// #define HT_CTRV      &ht PASTEPLAIN  LC(V_)  // ^V      plaintext paste (powertoys)

		// thumb keys
		#define TH_L_MAIN      &lt  L_NUM E_
		#define TH_L_MAIN_CW   &lt  L_NUM LS(E_) // capsword

		#define TH_L_AUX       &lsl    L_SYM L_SYM
		#define TH_L_AUX_CW    &lsl_cw_L_SYM 0 0

		#define TH_R_MAIN      &lt    L_NAV SPC
		#define TH_R_MAIN_CW   &ht_cw_L_NAV_spc 0 0

		#define TH_R_AUX       &lsl  L_ACNT L_ACNT
		#define TH_R_AUX_CW    &lsl  L_ACCW L_ACCW

                                      // ---- left hand ---- //      // ---- right hand ---- //
		#define _THUMBS_LEFT_         TH_L_MAIN     TH_L_AUX
		#define _THUMBS_RIGHT_                                        TH_R_AUX     TH_R_MAIN
		#define _THUMBS_CAPSWORD_     TH_L_MAIN_CW  TH_L_AUX_CW       TH_R_AUX_CW  TH_R_MAIN_CW
		#define _THUMBS_DEFAULT_           _THUMBS_LEFT_                 _THUMBS_RIGHT_
	


		// todo reorder layers according to thumbs
		base_layer {
			bindings = <
				&kp    Q_  HMRA   MIN_   &kp  Y_  DOT_COLN   NBSP_QMRK         &kp K_   &kp  C_   &kp  H_   &kp  W_   &kp  J_
				UTLAYR U_  HMLA   O_     HMLC I_  HMLS A_    &kp F_            &kp G_   HMRS T_   HMRC R_   HMRA S_   &kp  N_
				HMLG   Z_  HMLC   EACT_  &kp  P_  COMM_SCLN  &kp X_            &kp V_   &kp  D_   &kp  M_   &kp  L_   HMRG B_
				//
															       _THUMBS_DEFAULT_
			>;
		};

		caps_word_layer { // todo cancel shift when using caps word mods
			bindings = <
				&kp  LS(Q_)	 _________       &kp  LS(Y_)  _________      _________          &kp LS(K_)    &kp  LS(C_)  &kp  LS(H_)  &kp  LS(W_)  &kp  LS(J_)
				HMLG LS(U_)	 HMLA LS(O_)	 HMLC LS(I_)  HMLS LS(A_)    &kp LS(F_)         &kp LS(G_)    HMRS LS(T_)  HMRC LS(R_)  HMRA LS(S_)  HMRG LS(N_)
				&kp  LS(Z_)	 HMLC LS(EACT_)	 &kp  LS(P_)  COMM_SCLN      &kp LS(X_)         &kp LS(V_)    &kp  LS(D_)  &kp  LS(M_)  &kp  LS(L_)  &kp  LS(B_)
				//
														                     _THUMBS_CAPSWORD_
			>;
		};

		num_layer {
			bindings = <
				&kp PIPE_  &kp N7_  &kp N8_  &kp N9_    xxxxxxxxx         DLLR_EURO    &kp  LBRK_  &kp  RBRK_   &kp  HASH_   &kp  PCNT_
				&kp N0_    &kp N1_  &kp N2_  &kp N3_    &kp DOT_          xxxxxxxxx    HMRS PLUS_  HMRC MIN_    HMLA STAR_   HMRG FSLA_
				xxxxxxxxx  &kp N4_  &kp N5_  &kp N6_    &kp COMM_         xxxxxxxxx    &kp  LT_    &kp  GT_	    EQUL_DIFF    &kp  BSLA_
				//
				                                    _THUMBS_LEFT_         &kp ULIN_    _________
			>;
		};

		utility_layer {
			bindings = <
				xxxxxxxxx   xxxxxxxxx    xxxxxxxxx      xxxxxxxxx       xxxxx             xxxxx    xxxxxxxxx   xxxxxxxxx   xxxxxxxxx   xxxxxxxxx
				xxxxxxxxx   xxxxxxxxx    &m_util_astab  &m_util_atab    xxxxx             xxxxx    xxxxxxxxx   xxxxxxxxx   xxxxxxxxx   xxxxxxxxx
				xxxxxxxxx   xxxxxxxxx    &m_util_cstab  &m_util_ctab    xxxxx             xxxxx    xxxxxxxxx   xxxxxxxxx   xxxxxxxxx   xxxxxxxxx
		
				//
			                                            xxxxxxxxx       &m_util_gtab      xxxxx    xxxxx
			>;
		};

		sym_layer {
			bindings = <
				&kp AE_		 &kp AT_       &kp AMPR_   &kp OE_       NBSP_EXCL         xxxxx    DLLR_EURO    xxxxxxxxx    xxxxxxxxx    xxxxxxxxx
				SKLG LCRL_	 SKLA RCRL_    SKLC LPAR_  SKLS RPAR_    &kp MDSH_         xxxxx    HMRS xxxxx   HMRC xxxxx   HMRA xxxxx   HMRG PIPE_
				&kp NDSH_	 &kp MDSH_     NBSP_LGLM   NBSP_RGLM     xxxxxxxxx         xxxxx    xxxxxxxxx    &m_grvloos   &m_cfxloos   xxxxxxxxx
				//
								                       _________     &kp ULIN_        _THUMBS_RIGHT_
			>;
		};

		accent_layer {
			bindings = <
				&m_CFLX_U_  &m_CFLX_O_  &m_CFLX_I_  &m_CFLX_A_    IEXCL_IQMRK        xxxxxxxxx    &kp  CCED_  &kp  APST_  &kp  QUOT_  &m_B_J_
				&m_ACUT_U_  &m_ACUT_O_  &m_ACUT_I_  &m_ACUT_A_    &m_TILD_A_         xxxxxxxxx    HMRS ACUT_  HMRC GRAV_  HMLA CFLX_  &m_TILD_N_
				&m_GRAV_U_  &m_TILD_O_  &m_TRMA_I_  &kp AGRV_     xxxxxxxxx          xxxxxxxxx    &kp  TRMA_  xxxxxxxxx   &m_eszett   &kp TILD_
				//
												    &m_CFLX_E_    &kp EGRV_         _THUMBS_RIGHT_
			>;
		};

		accent_caps_layer {
			bindings = <
				&m_cw_CFLX_U_  &m_cw_CFLX_O_  &m_cw_CFLX_I_  &m_cw_CFLX_A_    xxxxxxxxx             xxxxxxxxx    &kp  CCED_  &kp  APST_  &kp  QUOT_  &m_cw_bj
				&m_cw_ACUT_U_  &m_cw_ACUT_O_  &m_cw_ACUT_I_  &m_cw_ACUT_A_    &m_cw_TILD_A_         xxxxxxxxx    HMRS ACUT_  HMRC GRAV_  HMLA CFLX_  &m_cw_tl_n
				&m_cw_GRAV_U_  &m_cw_TILD_O_  &m_cw_TRMA_I_  &kp LS(AGRV_)    xxxxxxxxx             xxxxxxxxx    &kp  TRMA_  xxxxxxxxx   &m_cw_sztt  &kp TILD_
				//
												             &m_cw_CFLX_E_    &kp LS(EGRV_)        _THUMBS_RIGHT_
			>;
		};

		nav_layer {
			bindings = <
				&kp xxxxx	CUT_ALL	    COPY_ALL     PASTE_ALL     C_S_DEL            &sk  RALT    HMLS LC(HOME)   HMLC PG_DN   HMLA PG_UP   HMRG LC(END)
				HMLG LC(Y_) HMLA INSERT	HMLC PSCRN	 HMLS PSBRK    &kp CAPS           &tog L_CPWD    &kp  LC(LEFT)   &kp  DOWN	&kp  UP	     &kp  LC(RIGHT)
				&kp  LC(Z_)	&kp  LC(X_)	&kp  LC(C_)	 &kp  LC(V_)   PASTEPLAIN         xxxxxxxxx    &kp  HOME       &kp  LEFT	&kp  RIGHT   &kp  END
				//
												                           _THUMBS_DEFAULT_
			>;
		};

		func_layer {
			bindings = <
				&bt  BT_CLR     &bt  BT_SEL 0   &bt  BT_SEL 1   &bt  BT_SEL 2  &bt BT_SEL 3         RESET_LEFT    &kp F7  &kp F8  &kp F9  &kp F12
				HMLG C_BRI_UP   HMLA C_NEXT     HMLC C_VOL_UP   HMLS C_PP  	   &kp LSLCK            &out OUT_BLE  &kp F1  &kp F2  &kp F3  &kp F10
				&kp  C_BRI_DN   &kp  C_PREV     &kp  C_VOL_DN   &kp  C_MUTE    &kp LNLCK            &out OUT_USB  &kp F4  &kp F5  &kp F6  &kp F11
				//
															                           _THUMBS_DEFAULT_
			>;
		};

		game_layer {
			bindings = <
				&kp Q_      &kp MIN_   &kp Y_     &kp DOT_     &kp R_            &kp  K_      &kp C_     &kp H_     &kp W_     &kp J_
				&kp U_      &kp O_     &kp I_     &kp A_       &kp F_            &kp  G_      &kp LEFT   &kp UP     &kp RIGHT  &kp N_
				&kp Z_      &kp S_     &kp P_     &kp COMM_    &kp X_            &tog L_GAME    &kp D_     &kp DOWN   &kp L_     &kp B_
				//
											      &kp ENTER    &kp SPACE         &kp  TAB     &kp LALT
			>;
		};

		game_layer_2 {
			bindings = <
				&kp LSHIFT  &kp A_     &kp EACT_  &kp I_      &kp O_            &kp  Y_      &kp U_     &kp I_     &kp O_     &kp P_
				&kp LCTRL   &kp B_     &kp U_     &kp P_      &kp E_            &kp  H_      &kp J_     &kp K_     &kp L_     &kp N_
				&kp ESC     &kp AGRV_  &kp Y_     &kp X_      &kp DOT           &tog L_GAM2    &kp M_     &kp COMM_	 &kp DOT_   &kp BSPC
				//
												  &kp ENTER   &kp SPACE         &kp  TAB   &kp LALT
			>;
		};

		/* FOR DEBUGGING:
			bindings = <
				xxxxx xxxxx xxxxx xxxxx   xxxxx         xxxxx   xxxxx xxxxx xxxxx xxxxx
				xxxxx xxxxx xxxxx xxxxx   xxxxx         xxxxx   xxxxx xxxxx xxxxx xxxxx
				xxxxx xxxxx xxxxx xxxxx   xxxxx         xxxxx   xxxxx xxxxx xxxxx xxxxx
			                   xxxxx   xxxxx         xxxxx   xxxxx
			>;
		*/
	};
};