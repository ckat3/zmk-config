#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/outputs.h>

#include "bepo_bindings.h"

/* SETTINGS */
#define MACRO_WAIT 3 /* max 5 */
#define MACRO_TAP_DELAY 3 /* max 5 */

#define COMBO_TIMEOUT 16 /* max 17, 15 maybe too little */

#define MT_TAPPING_TERM 120
#define LT_TAPPING_TERM 250
#define HT_TAPPING_TERM 250
#define HT_TAPPING_TERM_QUICK 200
#define HT_QUICK_TAP 200
#define STICKY_KEY_RELEASE_DELAY 2000 /* min 1000 */

/* LAYERS */
#define BASE 0
#define CAPL 1
#define SYM 2
#define ACNT 3
#define ACPS 4
#define NUM 5
#define NAV 6
#define FUNC 7
#define GAME 8

// combos shouldn't work on game layer, to minimize delay
#define NOT_GAME BASE CAPL SYM ACNT ACPS NUM NAV FUNC

&lt {
	tapping-term-ms = <LT_TAPPING_TERM>;
	flavor = "balanced";
};

&mt {
	tapping-term-ms = <MT_TAPPING_TERM>;
};

&sk {
	release-after-ms = <STICKY_KEY_RELEASE_DELAY>;
	quick-release;
};

/ { 
	behaviors {
		#define DEFINE_HOLDTAP(NAME, FLAVOR, DELAY, BINDINGS...) \
			NAME: ht_##NAME { \
				label = #NAME; \
				flavor = #FLAVOR; \
				tapping-term-ms = <DELAY>; \
				bindings = BINDINGS; \
				#binding-cells = <2>; \
				compatible = "zmk,behavior-hold-tap"; \
				quick-tap-ms = <HT_QUICK_TAP>;
				
		#define HOLDTAP(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, HT_TAPPING_TERM, BINDINGS) \
			};
				
		#define HOLDTAP_QUICK(NAME, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, tap-preferred, HT_TAPPING_TERM_QUICK, BINDINGS) \
			};
				
		#define HOLDTAP_FLAVOR(NAME, FLAVOR, BINDINGS...) \
				DEFINE_HOLDTAP(NAME, FLAVOR, HT_TAPPING_TERM, BINDINGS) \
			};
			
		#define HRMOD_POS(NAME, POSITIONS) \
				DEFINE_HOLDTAP(NAME, tap-preferred, HT_TAPPING_TERM, <&kp>, <&kp>) \
					hold-trigger-key-positions = <POSITIONS>; \
			};
		
		HOLDTAP_FLAVOR(lsk, balanced, <&mo>, <&sk>) // lsk: layer if held, one-shot kp if pressed
		HOLDTAP_FLAVOR(lsl, balanced, <&mo>, <&sl>) // lsl: layer if held, one-shot layer if pressed
		
		HOLDTAP_FLAVOR(ht_layer_spcaps, balanced, <&mo>, <&m_sp_togcaps>)
		
		// home-row mods
		HOLDTAP(hm,      <&kp>, <&kp>)
		HOLDTAP(hmsk,    <&sk>, <&kp>)		
		HOLDTAP(hm_qu,   <&kp>, <&m_Q_U_>)
		HOLDTAP(hm_quc,  <&kp>, <&m_cp_qu>)
		HOLDTAP(hm_aact, <&kp>, <&m_ACUT_A_>)
		HOLDTAP(hm_uact, <&kp>, <&m_ACUT_U_>)
		HOLDTAP(hm_iact, <&kp>, <&m_ACUT_I_>)

		// hrm for opposite hand only (used for shift)
		HRMOD_POS(hml, 5 6 7 8 9 15 16 17 18 19 25 26 27 28 29 32 33)
		HRMOD_POS(hmr, 0 1 2 3 4 10 11 12 13 14 20 21 22 23 24 30 31)
		
		// for chars with automatic nbsp on tap
		HOLDTAP(ht_lglm, <&kp>, <&m_nbsp_lglm>)
		HOLDTAP(ht_rglm, <&kp>, <&m_nbsp_rglm>)
		
		// for chars with automatic nbsp on hold
		HOLDTAP_QUICK(ht_coln, <&m_nbsp_coln>, <&kp>)
		HOLDTAP_QUICK(ht_scln, <&m_nbsp_scln>, <&kp>)
	};

	macros {
		#define MACRO(NAME, BINDINGS...) \
			ZMK_MACRO(m_##NAME, \
				tap-ms = <MACRO_TAP_DELAY>; \
				wait-ms = <MACRO_WAIT>; \
				bindings = BINDINGS; \
				)
				
		// MACRO_SIMPLE names the macro "m_FIRST##SECOND", eg "m_Q_U_".
		// it cannot contain parentheses (i think?) or complex sequences. 
		#define MACRO_SIMPLE(FIRST, SECOND) \
			MACRO(FIRST##SECOND, <&macro_tap &kp FIRST &kp SECOND>)
				
		#define MACRO_SIMPLE_OLD(FIRST, SECOND) \
			ZMK_MACRO(m_##FIRST##SECOND, \
				tap-ms = <MACRO_TAP_DELAY>; \
				wait-ms = <MACRO_WAIT>; \
				bindings = <&macro_tap &kp FIRST &kp SECOND>; \
				)
	
		// áíóú
		MACRO_SIMPLE(ACUT_, A_)
		//MACRO_SIMPLE(ACUT_, E_)
		MACRO_SIMPLE(ACUT_, I_)
		MACRO_SIMPLE(ACUT_, O_)
		MACRO_SIMPLE(ACUT_, U_)
		
		MACRO_SIMPLE(CFLX_, A_)
		MACRO_SIMPLE(CFLX_, E_)
		MACRO_SIMPLE(CFLX_, I_)
		MACRO_SIMPLE(CFLX_, O_)
		MACRO_SIMPLE(CFLX_, U_)
		
		//MACRO_SIMPLE(GRAV_, E_)
		MACRO_SIMPLE(GRAV_, O_)
		MACRO_SIMPLE(GRAV_, U_)
		
		MACRO_SIMPLE(TILD_, A_)
		MACRO_SIMPLE(TILD_, O_)
		MACRO_SIMPLE(TILD_, N_)
		MACRO_SIMPLE(TRMA_, I_)
		
		MACRO_SIMPLE(Q_, U_)
		MACRO_SIMPLE(B_, J_)
		
		MACRO(cp_ac_a, <&macro_tap &kp ACUT_ &kp LS(A_)>)
		//MACRO(cp_ac_e, <&macro_tap &kp ACUT_ &kp LS(E_)>)
		MACRO(cp_ac_i, <&macro_tap &kp ACUT_ &kp LS(I_)>)
		MACRO(cp_ac_o, <&macro_tap &kp ACUT_ &kp LS(O_)>)
		MACRO(cp_ac_u, <&macro_tap &kp ACUT_ &kp LS(U_)>)
		
		MACRO(cp_cf_a, <&macro_tap &kp CFLX_ &kp LS(A_)>)
		MACRO(cp_cf_e, <&macro_tap &kp CFLX_ &kp LS(E_)>)
		MACRO(cp_cf_i, <&macro_tap &kp CFLX_ &kp LS(I_)>)
		MACRO(cp_cf_o, <&macro_tap &kp CFLX_ &kp LS(O_)>)
		MACRO(cp_cf_u, <&macro_tap &kp CFLX_ &kp LS(U_)>)
		
		//MACRO(cp_gv_a, <&macro_tap &LS(GRAV_) &kp LS(A_)>)
		MACRO(cp_gv_e, <&macro_tap &kp GRAV_ &kp LS(E_)>)
		MACRO(cp_gv_o, <&macro_tap &kp GRAV_ &kp LS(O_)>)
		MACRO(cp_gv_u, <&macro_tap &kp GRAV_ &kp LS(U_)>)
		
		MACRO(cp_tl_a, <&macro_tap &kp TILD_ &kp LS(A_)>)
		MACRO(cp_tl_o, <&macro_tap &kp TILD_ &kp LS(O_)>)
		MACRO(cp_tl_n, <&macro_tap &kp TILD_ &kp LS(N_)>)
		MACRO(cp_tr_i, <&macro_tap &kp TRMA_ &kp LS(I_)>)
		
		MACRO(cp_qu, <&macro_tap &kp LS(Q_) &kp LS(U_)>)
		MACRO(cp_bj, <&macro_tap &kp LS(B_) &kp LS(J_)>)
		
		// «»:; with nbsp
		MACRO(nbsp_lglm, <&macro_tap &kp LGLM_ 	   &kp LS(SPACE)>)
		MACRO(nbsp_rglm, <&macro_tap &kp LS(SPACE) &kp RGLM_>)
		MACRO(nbsp_coln, <&macro_tap &kp LS(SPACE) &kp LS(DOT_) &kp SPACE>)
		MACRO(nbsp_scln, <&macro_tap &kp LS(SPACE) &kp LS(COMM_) &kp SPACE>)
		
		// ãe ão õe
		MACRO(ae,  <&macro_tap &kp TILD_ &kp A_ &kp E_>)
		MACRO(ao,  <&macro_tap &kp TILD_ &kp A_ &kp O_>)
		MACRO(oe,  <&macro_tap &kp TILD_ &kp O_ &kp E_>)
		MACRO(cp_ae, <&macro_tap &kp TILD_ &kp LS(A_) &kp LS(E_)>)
		MACRO(cp_ao, <&macro_tap &kp TILD_ &kp LS(A_) &kp LS(O_)>)
		MACRO(cp_oe, <&macro_tap &kp TILD_ &kp LS(O_) &kp LS(E_)>)
		
		// loose ^ `
		MACRO(cfxloos, <&macro_tap &kp CFLX_  &kp SPACE>)
		MACRO(grvloos, <&macro_tap &kp GRAV_  &kp SPACE>)
		
		// ß
		MACRO(eszett,  <&macro_tap &kp RA(S_) &kp S_>)
		MACRO(cp_sztt, <&macro_tap &kp RA(S_) &kp LS(S_)>)
		
		// to turn off capsword
		// MACRO(sp_togcaps, <&macro_tap &kp SPACE &tog CAPL>)
	};
			  
	combos {
		compatible = "zmk,combos";
		
		#define DEFINE_COMBO(LAYERS, BINDINGS, POSITIONS, NAME) \
			combo_##NAME { \
				layers = <LAYERS>; \
				bindings = <BINDINGS>; \
				key-positions = <POSITIONS>; \
				timeout-ms = <COMBO_TIMEOUT>; \
			};
		
		// when not defining layers, will default to NOT_GAME
		#define COMBO(BINDINGS, POSITIONS, NAME) \
			DEFINE_COMBO(NOT_GAME, BINDINGS, POSITIONS, NAME)		
			
		#define COMBO_LAYER(LAYERS, BINDINGS, POSITIONS, NAME) \
			DEFINE_COMBO(LAYERS, BINDINGS, POSITIONS, NAME)

		
		#define COMBO_KP(KEY, SUFFIX, POSITIONS) \
			DEFINE_COMBO(NOT_GAME, &kp KEY, POSITIONS, KEY##SUFFIX)	
			
		#define COMBO_KP_LAYER(KEY, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS, &kp KEY, POSITIONS, KEY##SUFFIX)
			
		
		#define COMBO_MACRO(MACRO, POSITIONS) \
			DEFINE_COMBO(NOT_GAME, &m_##MACRO, POSITIONS, MACRO)		
			
		#define COMBO_MACRO_LAYER(MACRO, SUFFIX, POSITIONS, LAYERS) \
			DEFINE_COMBO(LAYERS, &m_##MACRO, POSITIONS, MACRO##SUFFIX)
		
			
	/*
	    0   1   2   3      4 | 5      6   7   8   9
	    10  11  12  13    14 | 15    16  17  18  19
	    20  21  22  23    24 | 25    26  27  28  29
							 |
	                   30 31 | 32 33
					   
					   
	     0  11  12  13  |  16  17  18  9
	    10  21  22  23  |  26  27  28  19
					    |
	              30 31 | 32 33
	*/
	
		COMBO_KP(TAB,,   12 13)
		COMBO_KP(ENTER,, 16 17)
		
		COMBO_KP(SPACE,l, 11 12 13)
		COMBO_KP(SPACE,r, 16 17 18)
		
		COMBO_KP(ESC,, 10 11)
		
		COMBO_KP(BSPC,, 11 12)
		COMBO_KP(DEL,, 21 22)
		COMBO(&kp LC(BSPC), 17 18, gslqgrnqsl)
		COMBO(&kp LC(DEL), 27 28, rgsrnqsj)
				
		COMBO(&lsk FUNC LSHIFT, 30 31, dljsdqsrt)
		COMBO(&sk RSHIFT,       32 33, sqljqrjqsl)
		
		COMBO_MACRO_LAYER(Q_U_,, 26 27, BASE)
		COMBO_MACRO_LAYER(ae,,   13 30, BASE)
		COMBO_MACRO_LAYER(ao,,   13 11, BASE)
		COMBO_MACRO_LAYER(oe,,   11 30, BASE)
		
		COMBO_MACRO_LAYER(cp_qu,, 26 27, CAPL)
		COMBO_MACRO_LAYER(cp_ae,, 13 30, CAPL)
		COMBO_MACRO_LAYER(cp_ao,, 13 11, CAPL)
		COMBO_MACRO_LAYER(cp_oe,, 11 30, CAPL)
		
		combo_ctrlz {
			bindings = <&kp LC(Z_)>;
			key-positions = <20 21>;
			timeout-ms = <COMBO_TIMEOUT>;
		};
		
		combo_reset_left {
			bindings = <&reset>;
			key-positions = <0 4>;
			layers = <FUNC>;
			timeout-ms = <COMBO_TIMEOUT>;
		};
		
		combo_bootloader {
			bindings = <&bootloader>;
			key-positions = <20 24>;
			layers = <FUNC>;
			timeout-ms = <COMBO_TIMEOUT>;
		};
		
		combo_game_layer {
			bindings = <&tog GAME>;
			key-positions = <0 1 2>;
			layers = <FUNC>;
			timeout-ms = <COMBO_TIMEOUT>;
		};
	};

	keymap {
		compatible = "zmk,keymap";
		
		#define xxxx &none
		#define ____ &trans
		
		// home-row mods
		#define HMLS  &hml LSHIFT
		#define HMRS  &hmr RSHIFT
		#define HMLC  &hm LCTRL
		#define HMRC  &hm RCTRL
		#define HMLA  &hm LALT
		#define HMRA  &hm RALT
		#define HMLG  &hm LGUI
		#define HMRG  &hm RGUI
		
		#define SKLS  &hmsk LSHIFT
		#define SKLC  &hmsk LCTRL
		#define SKLA  &hmsk LALT
		#define SKLG  &hmsk LGUI
		
		#define HMLG_QU		&hm_qu LGUI 0
		#define HMLG_QUC	&hm_quc LGUI 0
		#define HMRA_IACT	&hm_iact RALT 0
		#define HMLA_AACT	&hm_aact LALT 0
		#define HMLG_UACT	&hm_uact LGUI 0
		
		#define EXCL_QMRK	&mt EXCL_ QMRK_
		#define EURO_DLLR_  &mt EURO_ DLLR_
		
		// «» with nbsp on tap
		#define MTLGLM &ht_lglm LGLM_ 0
		#define MTRGLM &ht_rglm RGLM_ 0
		
		// :; with nbsp on hold
		#define MTDOT  &ht_coln 0 DOT_
		#define MTCOMM &ht_scln 0 COMM_
		
		// thumb keys
		#define L_INNER	&lt NUM E_
		#define L_OUTER	&lsl SYM SYM
		
		#define L_INNERCAPS &lt NUM LS(E_)
		
		#define R_INNER	&lt NAV SPACE
		#define R_OUTER	&lsl ACNT ACNT
		
		#define R_INNERCAPS &ht_layer_spcaps NAV 0
		#define R_OUTERCAPS &lsl ACPS ACPS
		
		base_layer {
			bindings = <
				&kp  Q_		 HMRA MIN_		 &kp  Y_	  MTDOT	   	   EXCL_QMRK			&kp K_		 &kp  C_	  &kp  H_	   &kp  W_		&kp  J_
				HMLG U_		 HMLA O_		 HMLC I_	  HMLS A_	   &kp F_				&kp G_		 HMRS T_	  HMRC R_	   HMRA S_		HMRG N_
				&kp  Z_		 HMLC EACT_		 &kp  P_	  MTCOMM	   &kp X_				&kp V_		 &kp  D_	  &kp  M_	   &kp  L_		&kp  B_
														  L_INNER	   L_OUTER				R_OUTER		 R_INNER
			>;
		};
		
		caps_layer {
			bindings = <
				xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
				xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
				xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
				xxxx xxxx xxxx xxxx
			>;
		};
		
		sym_layer {
			bindings = <
				xxxx		 &kp AT_		 &kp AMPR_	  &kp OE_	   &kp AE_				xxxx		 xxxx		  xxxx		   xxxx		   xxxx
				SKLG LBRK_	 SKLA RBRK_		 SKLC LPAR_	  SKLS RPAR_   &kp MDSH_			xxxx		 HMRS LCRL_	  HMRC RCRL_   HMLA		   HMRG xxxx
				&kp NDSH_	 &kp MDSH_		 MTLGLM		  MTRGLM	   xxxx					xxxx		 xxxx		  &m_cfxloos   &m_grvloos  xxxx
														  ____		   ____					____		 ____
			>;
		};
		
		accent_layer {
			bindings = <
				&m_CFLX_U_	 &m_CFLX_O_		 &m_CFLX_I_   &m_CFLX_A_   xxxx					xxxx		 &kp  CCED_	  &kp  APST_   &kp  QUOT_  &m_B_J_
				&m_ACUT_U_	 &m_ACUT_O_		 &m_ACUT_I_	  &m_ACUT_A_   &m_TILD_A_			xxxx		 HMRS ACUT_   HMRC CFLX_   HMLA GRAV_  &m_TILD_N_
				&m_GRAV_U_	 &m_TILD_O_		 &m_TRMA_I_	  &kp AGRV_    xxxx					xxxx		 &kp  TRMA_	  xxxx		   &m_eszett   &kp TILD_
														  &m_CFLX_E_   &kp EGRV_			____		 ____
			>;
		};
		
		accent_caps_layer {
			bindings = <
				xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
				xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
				xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
				xxxx xxxx xxxx xxxx
			>;
		};
		
		num_layer {
			bindings = <
				xxxx		&kp N7_		&kp N8_		&kp N9_		xxxx				xxxx		EURO_DLLR_	&kp HASH_	&kp PCNT_	&kp PIPE_
				&kp N0_		&kp N1_		&kp N2_		&kp	N3_		&kp DOT_			xxxx		HMRS PLUS_	HMRC MIN_	HMLA STAR_	HMRG FSLA_
				xxxx		&kp N4_		&kp N5_		&kp	N6_		&kp COMM_			xxxx		&kp LT_		&kp GT_		&kp EQUL_	&kp BSLA_
													____		____				&kp ULIN_	____
			>;
		};
		
		nav_layer {
			bindings = <
				&kp INSERT	&sk RALT	&kp PSCRN	&kp PSBRK	xxxx				xxxx		&kp LC(HOME)	&kp PG_DN	&kp PG_UP	&kp LC(END)
				HMRG LGUI	HMLA LALT	HMLC LCTRL	HMLS LSHIFT	&kp CAPS			&tog CAPL	&kp LC(LEFT)	&kp DOWN	&kp UP		&kp LC(RIGHT)
				&kp LC(Z_)	&kp LC(X_)	&kp LC(C_)	&kp LC(V_)	xxxx				xxxx		&kp HOME		&kp LEFT	&kp RIGHT	&kp END
													&kp ULIN_	____				____		____
			>;
		};
		
		func_layer {
			bindings = <
				&bt  BT_CLR    &bt  BT_SEL 0  &bt  BT_SEL 1  &bt  BT_SEL 2  &bt BT_SEL 3			&reset        &kp F7  &kp F8  &kp F9  &kp F10
				HMLG C_BRI_UP  HMLA C_NEXT	  HMLC C_VOL_UP  HMLS C_PP  	&kp LSLCK				&out OUT_BLE  &kp F1  &kp F2  &kp F3  &kp F11
				&kp  C_BRI_DN  &kp  C_PREV    &kp  C_VOL_DN  &kp  C_MUTE    &kp LNLCK				&out OUT_USB  &kp F4  &kp F5  &kp F6  &kp F12
															 ____			____					____		  ____
			>;
		};
		
		game_layer {
			bindings = <
				&kp ESC		&kp A_		&kp W_		&kp D_		&kp T_				&kp Y_		&kp U_		&kp I_		&kp O_		&kp P_
				&kp LSHIFT	&kp F_		&kp S_		&kp E_		&kp R_				&kp H_		&kp J_		&kp K_		&kp L_		&kp N_
				&kp LCTRL	&kp Z_		&kp X_		&kp C_		&kp V_				&kp N_		&kp M_		&kp COMM_	&kp DOT_	&kp BSPC
													&kp SPACE	&kp TAB				&tog GAME	&kp LALT
			>;
		};
		
		/* FOR DEBUGGING:
			bindings = <
				xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
				xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
				xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
				xxxx xxxx xxxx xxxx
			>;
		*/
	};
};
